<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zhang-kg.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="安得广厦千万间">
<meta property="og:type" content="article">
<meta property="og:title" content="Lab5 掰开揉碎">
<meta property="og:url" content="https://zhang-kg.github.io/2022/06/08/BUAA-OS/index.html">
<meta property="og:site_name" content="Zhang-kg">
<meta property="og:description" content="安得广厦千万间">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:/Users/86150/AppData/Roaming/Typora/typora-user-images/image-20220605140130015.png">
<meta property="article:published_time" content="2022-06-08T15:07:29.000Z">
<meta property="article:modified_time" content="2022-06-08T15:15:47.342Z">
<meta property="article:author" content="Zhang-kg">
<meta property="article:tag" content="BUAA_OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/Users/86150/AppData/Roaming/Typora/typora-user-images/image-20220605140130015.png">


<link rel="canonical" href="https://zhang-kg.github.io/2022/06/08/BUAA-OS/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://zhang-kg.github.io/2022/06/08/BUAA-OS/","path":"2022/06/08/BUAA-OS/","title":"Lab5 掰开揉碎"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Lab5 掰开揉碎 | Zhang-kg</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Zhang-kg</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="nav-number">1.</span> <span class="nav-text">宏定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#include-fs-h"><span class="nav-number">1.1.</span> <span class="nav-text">include&#x2F;fs.h</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fs-fs-h"><span class="nav-number">1.2.</span> <span class="nav-text">fs&#x2F;fs.h</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#user-fd-h"><span class="nav-number">1.3.</span> <span class="nav-text">user&#x2F;fd.h</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">2.</span> <span class="nav-text">结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#include-fs-h-1"><span class="nav-number">2.1.</span> <span class="nav-text">include&#x2F;fs.h</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fs-fsformat-c"><span class="nav-number">3.</span> <span class="nav-text">fs&#x2F;fsformat.c</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6%E5%BC%95%E7%94%A8"><span class="nav-number">3.1.</span> <span class="nav-text">头文件引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#disk-init%E5%87%BD%E6%95%B0"><span class="nav-number">3.1.1.</span> <span class="nav-text">disk_init函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#next-block"><span class="nav-number">3.1.2.</span> <span class="nav-text">next_block</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#save-block-link"><span class="nav-number">3.1.3.</span> <span class="nav-text">save_block_link</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#make-link-block"><span class="nav-number">3.1.4.</span> <span class="nav-text">make_link_block</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#create-file"><span class="nav-number">3.1.5.</span> <span class="nav-text">create_file</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#write-file"><span class="nav-number">3.1.6.</span> <span class="nav-text">write_file</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#flush-bitmap"><span class="nav-number">3.1.7.</span> <span class="nav-text">flush_bitmap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#finish-fs"><span class="nav-number">3.1.8.</span> <span class="nav-text">finish_fs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reverse-block-amp-amp-reverse"><span class="nav-number">3.1.9.</span> <span class="nav-text">reverse_block &amp;&amp; reverse</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#main"><span class="nav-number">3.1.10.</span> <span class="nav-text">main</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fs-Makefile"><span class="nav-number">4.</span> <span class="nav-text">fs&#x2F;Makefile</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9D%97%E7%BC%93%E5%AD%98"><span class="nav-number">5.</span> <span class="nav-text">块缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fs-fs-c"><span class="nav-number">6.</span> <span class="nav-text">fs&#x2F;fs.c</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6%E5%92%8C%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="nav-number">6.0.1.</span> <span class="nav-text">头文件和宏定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#diskaddr"><span class="nav-number">6.0.2.</span> <span class="nav-text">diskaddr</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#va-is-mapped"><span class="nav-number">6.0.3.</span> <span class="nav-text">va_is_mapped</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#block-is-mapped"><span class="nav-number">6.0.4.</span> <span class="nav-text">block_is_mapped</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#va-is-dirty"><span class="nav-number">6.0.5.</span> <span class="nav-text">va_is_dirty</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#block-is-dirty"><span class="nav-number">6.0.6.</span> <span class="nav-text">block_is_dirty</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#map-block"><span class="nav-number">6.0.7.</span> <span class="nav-text">map_block</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unmap-block"><span class="nav-number">6.0.8.</span> <span class="nav-text">unmap_block</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#read-block"><span class="nav-number">6.0.9.</span> <span class="nav-text">read_block</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#write-block"><span class="nav-number">6.0.10.</span> <span class="nav-text">write_block</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#block-is-free"><span class="nav-number">6.0.11.</span> <span class="nav-text">block_is_free</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#free-block"><span class="nav-number">6.0.12.</span> <span class="nav-text">free_block</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#alloc-block-num"><span class="nav-number">6.0.13.</span> <span class="nav-text">alloc_block_num</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#alloc-block%E2%80%94%E2%80%94%E5%B0%81%E8%A3%85%E5%87%BD%E6%95%B0"><span class="nav-number">6.0.14.</span> <span class="nav-text">alloc_block——封装函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#read-super"><span class="nav-number">6.0.15.</span> <span class="nav-text">read_super</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#read-bitmap"><span class="nav-number">6.0.16.</span> <span class="nav-text">read_bitmap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#check-write-block"><span class="nav-number">6.0.17.</span> <span class="nav-text">check_write_block</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fs-init"><span class="nav-number">6.0.18.</span> <span class="nav-text">fs_init</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#file-block-walk"><span class="nav-number">6.0.19.</span> <span class="nav-text">file_block_walk</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#file-map-block"><span class="nav-number">6.0.20.</span> <span class="nav-text">file_map_block</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#file-clear-block"><span class="nav-number">6.0.21.</span> <span class="nav-text">file_clear_block</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#file-get-block"><span class="nav-number">6.0.22.</span> <span class="nav-text">file_get_block</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#file-dirty"><span class="nav-number">6.0.23.</span> <span class="nav-text">file_dirty</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dir-lookup%E2%80%94%E6%B2%A1%E6%97%B6%E9%97%B4%E4%BA%86%EF%BC%8C%E4%B8%8D%E7%BB%86%E8%87%B4%E5%86%99%E4%BA%86"><span class="nav-number">6.0.24.</span> <span class="nav-text">dir_lookup—没时间了，不细致写了</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dir-alloc-file"><span class="nav-number">6.0.25.</span> <span class="nav-text">dir_alloc_file</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#skip-slash"><span class="nav-number">6.0.26.</span> <span class="nav-text">skip_slash</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#walk-path"><span class="nav-number">6.0.27.</span> <span class="nav-text">walk_path</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#file-open%E2%80%94%E2%80%94%E5%B0%81%E8%A3%85%E5%87%BD%E6%95%B0"><span class="nav-number">6.0.28.</span> <span class="nav-text">file_open——封装函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#file-create"><span class="nav-number">6.0.29.</span> <span class="nav-text">file_create</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#file-truncate"><span class="nav-number">6.0.30.</span> <span class="nav-text">file_truncate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#file-set-size"><span class="nav-number">6.0.31.</span> <span class="nav-text">file_set_size</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#file-flush"><span class="nav-number">6.0.32.</span> <span class="nav-text">file_flush</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fs-sync"><span class="nav-number">6.0.33.</span> <span class="nav-text">fs_sync</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#file-close"><span class="nav-number">6.0.34.</span> <span class="nav-text">file_close</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#file-remove"><span class="nav-number">6.0.35.</span> <span class="nav-text">file_remove</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fs-ide-c"><span class="nav-number">7.</span> <span class="nav-text">fs&#x2F;ide.c</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-number">7.1.</span> <span class="nav-text">头文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">7.2.</span> <span class="nav-text">函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fs-serv-c"><span class="nav-number">8.</span> <span class="nav-text">fs&#x2F;serv.c</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%AE%8F%E5%AE%9A%E4%B9%89-amp-amp-%E5%BF%85%E8%A6%81%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">8.1.</span> <span class="nav-text">文件宏定义&amp;&amp;必要结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E5%85%B3%E5%BF%85%E5%A4%87%E5%87%BD%E6%95%B0"><span class="nav-number">8.2.</span> <span class="nav-text">通关必备函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#serve-init%E6%9C%8D%E5%8A%A1%E8%BF%9B%E7%A8%8B%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">8.3.</span> <span class="nav-text">serve_init服务进程初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#serve-%E6%9C%8D%E5%8A%A1%E4%B8%BB%E4%BD%93"><span class="nav-number">8.4.</span> <span class="nav-text">serve 服务主体</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FSREQ-OPEN"><span class="nav-number">8.4.1.</span> <span class="nav-text">FSREQ_OPEN</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FSREQ-MAP"><span class="nav-number">8.4.2.</span> <span class="nav-text">FSREQ_MAP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FSREQ-SET-SIZE"><span class="nav-number">8.4.3.</span> <span class="nav-text">FSREQ_SET_SIZE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FSREQ-CLOSE"><span class="nav-number">8.4.4.</span> <span class="nav-text">FSREQ_CLOSE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FSREQ-DIRTY"><span class="nav-number">8.4.5.</span> <span class="nav-text">FSREQ_DIRTY</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FSREQ-REMOVE"><span class="nav-number">8.4.6.</span> <span class="nav-text">FSREQ_REMOVE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FSREQ-SYNC"><span class="nav-number">8.4.7.</span> <span class="nav-text">FSREQ_SYNC</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#user-fsipc-c"><span class="nav-number">9.</span> <span class="nav-text">user&#x2F;fsipc.c</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#fsipc-open"><span class="nav-number">9.0.1.</span> <span class="nav-text">fsipc_open</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fsipc-map"><span class="nav-number">9.0.2.</span> <span class="nav-text">fsipc_map</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fsipc-set-size"><span class="nav-number">9.0.3.</span> <span class="nav-text">fsipc_set_size</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fsipc-close"><span class="nav-number">9.0.4.</span> <span class="nav-text">fsipc_close</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fsipc-dirty"><span class="nav-number">9.0.5.</span> <span class="nav-text">fsipc_dirty</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fsipc-remove"><span class="nav-number">9.0.6.</span> <span class="nav-text">fsipc_remove</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fsipc-sync"><span class="nav-number">9.0.7.</span> <span class="nav-text">fsipc_sync</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#user-fd-c"><span class="nav-number">10.</span> <span class="nav-text">user&#x2F;fd.c</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dev-lookup"><span class="nav-number">10.0.1.</span> <span class="nav-text">dev_lookup</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fd-alloc"><span class="nav-number">10.0.2.</span> <span class="nav-text">fd_alloc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fd-close"><span class="nav-number">10.0.3.</span> <span class="nav-text">fd_close</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fd-lookup"><span class="nav-number">10.0.4.</span> <span class="nav-text">fd_lookup</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fd2data"><span class="nav-number">10.0.5.</span> <span class="nav-text">fd2data</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fd2num"><span class="nav-number">10.0.6.</span> <span class="nav-text">fd2num</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#num2fd"><span class="nav-number">10.0.7.</span> <span class="nav-text">num2fd</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#close"><span class="nav-number">10.0.8.</span> <span class="nav-text">close</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#close-all"><span class="nav-number">10.0.9.</span> <span class="nav-text">close_all</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dup"><span class="nav-number">10.0.10.</span> <span class="nav-text">dup</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#read"><span class="nav-number">10.0.11.</span> <span class="nav-text">read</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#readn"><span class="nav-number">10.0.12.</span> <span class="nav-text">readn</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#write"><span class="nav-number">10.0.13.</span> <span class="nav-text">write</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#seek"><span class="nav-number">10.0.14.</span> <span class="nav-text">seek</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fstat"><span class="nav-number">10.0.15.</span> <span class="nav-text">fstat</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stat"><span class="nav-number">10.0.16.</span> <span class="nav-text">stat</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#user-file-c"><span class="nav-number">11.</span> <span class="nav-text">user&#x2F;file.c</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#open"><span class="nav-number">11.0.1.</span> <span class="nav-text">open</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#file-close-1"><span class="nav-number">11.0.2.</span> <span class="nav-text">file_close</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#file-read"><span class="nav-number">11.0.3.</span> <span class="nav-text">file_read</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#read-map"><span class="nav-number">11.0.4.</span> <span class="nav-text">read_map</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#file-write"><span class="nav-number">11.0.5.</span> <span class="nav-text">file_write</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#file-stat"><span class="nav-number">11.0.6.</span> <span class="nav-text">file_stat</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ftruncate"><span class="nav-number">11.0.7.</span> <span class="nav-text">ftruncate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#remove"><span class="nav-number">11.0.8.</span> <span class="nav-text">remove</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sync"><span class="nav-number">11.0.9.</span> <span class="nav-text">sync</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#user-pipe-c"><span class="nav-number">12.</span> <span class="nav-text">user&#x2F;pipe.c</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#user-console-c"><span class="nav-number">13.</span> <span class="nav-text">user&#x2F;console.c</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-number">14.</span> <span class="nav-text">问题</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhang-kg"
      src="/images/%E6%AD%8C.png">
  <p class="site-author-name" itemprop="name">Zhang-kg</p>
  <div class="site-description" itemprop="description">description</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhang-kg.github.io/2022/06/08/BUAA-OS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E6%AD%8C.png">
      <meta itemprop="name" content="Zhang-kg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang-kg">
      <meta itemprop="description" content="description">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Lab5 掰开揉碎 | Zhang-kg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Lab5 掰开揉碎
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-06-08 23:07:29 / 修改时间：23:15:47" itemprop="dateCreated datePublished" datetime="2022-06-08T23:07:29+08:00">2022-06-08</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>36k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>33 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>安得广厦千万间</p>
<span id="more"></span>
<h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><h3 id="include-fs-h"><a href="#include-fs-h" class="headerlink" title="include/fs.h"></a><code>include/fs.h</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BY2BLK		BY2PG	<span class="comment">// 一个块有多少个字节,这里定义为一个页,</span></span></span><br><span class="line">							<span class="comment">// 说明一个块大小为4096B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIT2BLK		(BY2BLK*8)	<span class="comment">// 一个块有多少个字(bit),是一个块字节*8</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXNAMELEN	128 <span class="comment">// 文件名长度最多128个字符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXPATHLEN	1024 <span class="comment">// 文件路径长度最多1024个字符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDIRECT		10 <span class="comment">// 直接文件的块指针有10个</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NINDIRECT	(BY2BLK/4) <span class="comment">// 间接文件快指针最多有1024个</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFILESIZE	(NINDIRECT*BY2BLK) <span class="comment">// 文件最大大小是1024*4KB=4MB</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BY2FILE     256 <span class="comment">// 一个File结构体的大小是256B</span></span></span><br></pre></td></tr></table></figure>
<h3 id="fs-fs-h"><a href="#fs-fs-h" class="headerlink" title="fs/fs.h"></a><code>fs/fs.h</code></h3><h3 id="user-fd-h"><a href="#user-fd-h" class="headerlink" title="user/fd.h"></a><code>user/fd.h</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFD 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILEBASE 0x60000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDTABLE (FILEBASE - PDMAP) <span class="comment">// PDMAP = 4 * 1024 * 1024</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INDEX2FD(i) (FDTABLE + (i) * BY2PG)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INDEX2DATA(i) (FILEBASE + (i) * PDMAP</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DEV 结构体</span></span><br><span class="line"><span class="comment">// Device struct:</span></span><br><span class="line"><span class="comment">// It is used to read and write data from corresponding device.</span></span><br><span class="line"><span class="comment">// We can use the five functions to handle data.</span></span><br><span class="line"><span class="comment">// There are three devices in this OS: file, console and pipe.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> {</span></span><br><span class="line">	<span class="type">int</span> dev_id;</span><br><span class="line">	<span class="type">char</span> *dev_name;</span><br><span class="line">	<span class="type">int</span> (*dev_read)(<span class="keyword">struct</span> Fd *, <span class="type">void</span> *, u_int, u_int);</span><br><span class="line">	<span class="type">int</span> (*dev_write)(<span class="keyword">struct</span> Fd *, <span class="type">const</span> <span class="type">void</span> *, u_int, u_int);</span><br><span class="line">	<span class="type">int</span> (*dev_close)(<span class="keyword">struct</span> Fd *);</span><br><span class="line">	<span class="type">int</span> (*dev_stat)(<span class="keyword">struct</span> Fd *, <span class="keyword">struct</span> Stat *);</span><br><span class="line">	<span class="type">int</span> (*dev_seek)(<span class="keyword">struct</span> Fd *, u_int);</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Devise 结构体用于针对特定的设备进行读写数据。其中包含了 5 个方法。在MOS中，有 3 个设备。分别是 file、console和 pipe</p>
<p>感觉这个结构体的定义非常像接口</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件描述符</span></span><br><span class="line"><span class="comment">// file descriptor</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> {</span></span><br><span class="line">	u_int fd_dev_id;</span><br><span class="line">	u_int fd_offset;</span><br><span class="line">	u_int fd_omode;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// State</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stat</span> {</span></span><br><span class="line">	<span class="type">char</span> st_name[MAXNAMELEN];</span><br><span class="line">	u_int st_size;</span><br><span class="line">	u_int st_isdir;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> *<span class="title">st_dev</span>;</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file descriptor + file</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> {</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> <span class="title">f_fd</span>;</span></span><br><span class="line">	u_int f_fileid;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">f_file</span>;</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="include-fs-h-1"><a href="#include-fs-h-1" class="headerlink" title="include/fs.h"></a><code>include/fs.h</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> {</span></span><br><span class="line">	u_char f_name[MAXNAMELEN];	<span class="comment">// filename</span></span><br><span class="line">	u_int f_size;			<span class="comment">// file size in bytes</span></span><br><span class="line">	u_int f_type;			<span class="comment">// file type</span></span><br><span class="line">	u_int f_direct[NDIRECT];</span><br><span class="line">	u_int f_indirect;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f_dir</span>;</span>		<span class="comment">// the pointer to the dir where this file is in, valid only in memory.</span></span><br><span class="line">	u_char f_pad[BY2FILE - MAXNAMELEN - <span class="number">4</span> - <span class="number">4</span> - NDIRECT * <span class="number">4</span> - <span class="number">4</span> - <span class="number">4</span>];</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<p>这是一个File结构体,包含文件名,文件大小(字节为单位),文件类型(只有普通文件和文件夹类型)</p>
<p>进一步定义一个块中可以有多少个文件呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FILE2BLK (BY2BLK/sizeof(struct File)) <span class="comment">// 因为一个磁盘块的大小是4096B，一个File结构体的大小是256B所以一个磁盘块中可以有16个File结构体</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FTYPE_REG 0<span class="comment">//常规文件类型File</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FTYPE_DIR 1<span class="comment">//文件夹类型FIle</span></span></span><br></pre></td></tr></table></figure>
<p>进一步在文件中定义OS魔数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FS_MAGIC 0x68286097</span></span><br></pre></td></tr></table></figure>
<p>和Super结构体，Super结构体占一个磁盘块 4096B</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Super</span> {</span></span><br><span class="line">	u_int s_magic;		<span class="comment">// Magic number: FS_MAGIC</span></span><br><span class="line">	u_int s_nblocks;	<span class="comment">// Total number of blocks on disk</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">s_root</span>;</span>	<span class="comment">// Root directory node</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h2 id="fs-fsformat-c"><a href="#fs-fsformat-c" class="headerlink" title="fs/fsformat.c"></a><code>fs/fsformat.c</code></h2><blockquote>
<p>指导书的描述：这个文件的功能是创建磁盘镜像</p>
</blockquote>
<h3 id="头文件引用"><a href="#头文件引用" class="headerlink" title="头文件引用"></a>头文件引用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>从头文件可以看出来，这个文件不是我们系统内的文件，而是Linux本身的文件。</p>
<p>fsformat文件的功能是创建磁盘镜像。在这个文件里面，就初始化了1024个Block结构体（称为disk[]）。相当于磁盘有多少个块，每个磁盘块的大小是4096B。根据指导书的描述，磁盘块是一个虚拟概念。在磁盘中，扇区是一个真实的概念，磁盘中确实有扇区，但是没有磁盘块。一个扇区一般512B。所以在咱们的设计中一个磁盘块包含8个扇区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block</span> {</span></span><br><span class="line">    <span class="type">uint8_t</span> data[BY2BLK];</span><br><span class="line">    <span class="type">uint32_t</span> type;</span><br><span class="line">} disk[NBLOCK];</span><br></pre></td></tr></table></figure>
<h4 id="disk-init函数"><a href="#disk-init函数" class="headerlink" title="disk_init函数"></a>disk_init函数</h4><p>这个函数是main函数中第一个调用的函数。用于磁盘的设置。</p>
<ul>
<li>设置第0块的磁盘块类型：<code>BLOCK_BOOT</code></li>
<li>接下来初始化磁盘块位图。磁盘是一个比较大的空间，管理这个空间有很多种方法。在虚拟内存物理内存管理的时候我们使用的是链表法，但是介绍过位图法，往年内存管理部分也考过位图法。今年的文件处理（磁盘中）使用位图法管理磁盘的每个块。在位图法中，一位代表一块。首先根据磁盘的总块数确定需要多少个位来管理这些块；进一步，位图也需要保存在磁盘中，所以需要计算出位图需要占用几个磁盘块（这里应该使用向上取整），位图开始于第二次磁盘块disk[2]。例如需要1.2个块或者3.5个块，就要分配给位图2个块或者4个块。位图不见得占用分配的磁盘块的所有空间，所以需要将没有占用的部分舍弃掉。在位图的使用中，用1代表磁盘块的空闲；0代表磁盘块使用。</li>
<li>初始化完位图之后，需要初始化super块，它设置在第1块磁盘块disk[1]的位置。在这个函数中，我们先将内容保存到super结构体中，包括磁盘魔数、总磁盘块个数、根目录文件类型和文件名”/“等。super块的内容最后会写到磁盘中，在这里可能是为了存取方便。</li>
</ul>
<h4 id="next-block"><a href="#next-block" class="headerlink" title="next_block"></a>next_block</h4><p>接受一个type，返回当前空闲的磁盘块号。它的作用是分配一个磁盘块，并且将这个磁盘块的类型设置为type。全局变量nextbno记录了当前分配到哪个磁盘块了</p>
<h4 id="save-block-link"><a href="#save-block-link" class="headerlink" title="save_block_link"></a>save_block_link</h4><p>这个函数传入一个文件结构体指针（<code>struct File * f</code>），一个文件中块指针号(<code>int nblk</code>)和磁盘块号（<code>int bno</code>）。这个函数的作用是将一个磁盘块号（bno）对应的磁盘块和文件的某个磁盘指针（<code>f_direct[nblk]</code> 或者 <code>(disk[f_indirect].data)[nblk]</code>）对应起来。一个磁盘块的大小很有可能超过一个磁盘块大小（4KB），文件结构体中保存了10个直接指针（保存磁盘块号），如果10个不够用，可以申请且仅能申请一个空白的块专门用来存储间接的磁盘块号（其中这里的每个磁盘块号对应的磁盘存储着文件的内容）。</p>
<h4 id="make-link-block"><a href="#make-link-block" class="headerlink" title="make_link_block"></a>make_link_block</h4><p>传入：一个文件结构体指针（<code>struct File * dirf</code>），一个块指针号（<code>int nblk</code>）。</p>
<p>传出：分配的磁盘块号（<code>int bno</code>）</p>
<p>在这个函数中首先进行磁盘块的分配（next_block），然后将新分配出来的磁盘块号对应到文件结构体中的块指针（nblk）使用sava_block_link。并且将这个文件的大小相应的增加BY2PG，最后返回分配的磁盘块号。这个函数和上面的函数的区别是，这个函数不确定当前需要给文件对应哪个磁盘块好，主要功能是给文件增加一页空间。但是上面的函数需要确定哪一页放到哪里，要求更高。（<strong>缺陷：</strong>这个函数没有判定nblk对应的位置是否已经有一个磁盘块；也没确定nblk是不是在文件大小之内，就是说有可能nblk前面的指针还没分配呢，后面的指针先分配的问题。<strong>需要看看调用的时候是否解决这个问题</strong>）</p>
<h4 id="create-file"><a href="#create-file" class="headerlink" title="create_file"></a>create_file</h4><p>传入：一个文件结构体指针（<code>struct File * dirf</code>）</p>
<p>传出：一个文件结构体指针</p>
<p>函数的含义是在当前的文件夹下创建一个文件。先来说说如果dirf为一个文件夹。则它的直接指针和间接指针总共1024个。每个指针指向一个磁盘块。每个磁盘块的大小是4KB。一个<code>struct File</code> 结构体256B。所以一个磁盘块可以保存16个文件结构体（File 结构体）。每个File结构体代表这个文件夹下的一个文件or一个子文件夹。所以如果要在dirf这个文件夹内创造文件，就是找到一个内部的文件结构体就完事了。所以首先得到dirf目前用了多少个直接指针和间接指针了（nblk）；进一步遍历每个指针所指的磁盘块；在磁盘块中，遍历所有的File结构体，如果某个File结构体对应的name为空（说明这个文件结构体没用），就把这个文件结构体作为承载新文件的地址。如果遍历了当前文件夹所有的指针，都没有空闲的File结构体，则需要分配一个新的文件指针，因为是新分配的，所以这个磁盘块的第一个File结构体肯定是没被用过的，所以返回<code>(struct File *)disk[bno].data</code>。</p>
<h4 id="write-file"><a href="#write-file" class="headerlink" title="write_file"></a>write_file</h4><p>传入：一个文件结构指针（<code>struct File * dirf</code>），一个文件路径（<code>const char * path</code>）</p>
<p>函数的功能是在特定的文件夹下把文件写入磁盘。首先，需要使用系统调用打开path对应的文件。然后使用create_file在dirf文件夹中创建一个文件（文件结构体指针为target），然后使用不断将文件中的内容写入到target中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>((r = read(fd, disk[nextbno].data, n)) &gt; <span class="number">0</span>) {</span><br><span class="line">    save_block_link(target, iblk++, next_block(BLOCK_DATA));</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这里iblk从0开始，next_block函数对nextbno进行更新，确保每次使用read的时候可以将文件中的数据正确的写入nextbno对应的磁盘块中，然后使用save_block_link将iblk于nextbno对应的块进行连接。</p>
<h4 id="flush-bitmap"><a href="#flush-bitmap" class="headerlink" title="flush_bitmap"></a>flush_bitmap</h4><p>无传入传出。这个函数的功能是将nextbno之前的磁盘块都标记成已经使用过（在位图块中标记）。由于之间的各种分配和使用磁盘块都没有设置位图，所以这里可以统一将之前的位图都标记为正在使用（对应的位为0）</p>
<p><strong>可以加入一些图片和代码帮助理解</strong></p>
<h4 id="finish-fs"><a href="#finish-fs" class="headerlink" title="finish_fs"></a>finish_fs</h4><p>传入：待写入文档的名字（<code>char * name</code>）</p>
<p>无传出。</p>
<p>首先将super存到第一个磁盘块中（disk[1]）。然后打开name对应的文件，将大小端调整好（因为fsformat文件不是在MOS系统上运行的，之前也说过，直接运行的系统采用的小端存取，而MIPS对应的MOS使用大端存取，所以要调整大小端），将每个磁盘的内容存到文件中，这个文件就相当于磁盘了。<strong>注意：</strong>这里存回去的时候，存入的是<code>disk[i].data</code>，这部分的大小是4KB，然而一个Block结构体的大小是4096+4B。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fd = open(name, O_RDWR|O_CREAT, <span class="number">0666</span>);</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; ++i) {</span><br><span class="line">    reverse_block(disk+i);</span><br><span class="line">    write(fd, disk[i].data, BY2BLK);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="reverse-block-amp-amp-reverse"><a href="#reverse-block-amp-amp-reverse" class="headerlink" title="reverse_block && reverse"></a>reverse_block &amp;&amp; reverse</h4><p>自己来吧，一看就会</p>
<h4 id="main"><a href="#main" class="headerlink" title="main"></a>main</h4><p>传入：argc（指示传入参数个数），传入的参数数组（<code>char ** argv</code>）</p>
<p>这就是完整的创建磁盘镜像过程：首先初始化磁盘（init_disk）。这里需要先介绍一下，创建的磁盘文件只支持创建包含一堆文件的磁盘镜像或者一个文件夹的磁盘镜像。</p>
<p>如果需要创建带有文件夹的磁盘镜像，则创建出的磁盘在根目录下有<strong>一个</strong>文件夹（使用write_directory，<strong>注意：</strong>虽然从代码上看是使用了一个for循环，好像出创建一堆文件夹，但是实际上如果使用创建文件夹的模式，argc只能为4，说明只能创建一个文件夹）；如果不是创建文件夹的模式，则创建出来的磁盘镜像在根目录下有很多的文件（使用write_file）。</p>
<p>然后更新bitmap（flush_bitmap）；完成磁盘创建（<code>finish_fs(argv[1])</code>）<strong>注意：</strong>使用的时候<code>argv[1]</code>为<code>gxemul/fs.img</code>，即为磁盘的名字。</p>
<h2 id="fs-Makefile"><a href="#fs-Makefile" class="headerlink" title="fs/Makefile"></a><code>fs/Makefile</code></h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FSIMGFILES := motd newmotd</span><br><span class="line"><span class="section">fs.img: <span class="variable">$(FSIMGFILES)</span></span></span><br><span class="line">	dd if=/dev/zero of=../gxemul/fs.img bs=4096 count=1024 2&gt;dev/null</span><br></pre></td></tr></table></figure>
<p><strong>见强哥的解析</strong>，我就不班门弄斧了</p>
<h2 id="块缓存"><a href="#块缓存" class="headerlink" title="块缓存"></a>块缓存</h2><p>文件服务进程是一个单独的进程（用户进程），每个进程有4GB的空间。在这4GB空间中，拿出来1GB（大小0x40000000）单独作为存储磁盘块的存储缓存。从磁盘读入内存时，就是先把数据保存到缓存区，然后其他用户进程如果需要，也是从缓存区读取数据，不会单独读取数据。这段空间从0x10000000到0x50000000，共1GB。当把一个磁盘块载入内存时，需要为之分配空间；结束使用这个磁盘块的时候需要将磁盘块写回磁盘，并且释放对应的物理内存。<code>fs/fs.c</code> 中的<code>map_block</code>函数和<code>unmap_block</code>函数实现了这一功能。</p>
<p>read_block 函数和 write_block 函数用于读写磁盘块。read_block 函数将指定编号的磁盘块读入到内存中，首先检查这块磁盘块是否已经在内存中，如果不在，先分配一页物理内存，<strong>然后调用 <code>ide_read</code>函数来读取磁盘上的数据到对应的虚存地址处</strong>。</p>
<p><strong><code>file_get_block</code>函数用于将某个指定的文件指向的磁盘块读入内存</strong>。其主要分为 2 个步骤：首先为即将读入内存的磁盘块分配物理内存，然后使用<code>read_block</code>函数将磁盘内容以块为单位读入内存中的相应位置。这两个步骤对应的函数都借助了系统调用来完成。</p>
<h2 id="fs-fs-c"><a href="#fs-fs-c" class="headerlink" title="fs/fs.c"></a><code>fs/fs.c</code></h2><h4 id="头文件和宏定义"><a href="#头文件和宏定义" class="headerlink" title="头文件和宏定义"></a>头文件和宏定义</h4><p>先来看看<code>fs/fs.h</code>中的宏定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DISKNO 1		<span class="comment">// ide磁盘号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BY2SECT 512		<span class="comment">// 扇区大小512B</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECT2BLK (BY2BLK/BY2SECT) <span class="comment">// 一个块有几个扇区 4096/512 = 8个扇区</span></span></span><br></pre></td></tr></table></figure>
<h4 id="diskaddr"><a href="#diskaddr" class="headerlink" title="diskaddr"></a>diskaddr</h4><p>传入：磁盘块的编号（<code>int blockno</code>）</p>
<p>传出：编号对应的，在块缓存区的磁盘块基地址va。</p>
<p>这里需要介绍一下块缓存机制。缓存区可以缓存1GB的大小，相当于262144个磁盘块。远远大于正常磁盘中的磁盘块个数。所以在缓存区内，磁盘块和缓存的地方是一一映射的。所以通过blockno到va是线性映射的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> addr = blockno * BY2BLK + DISKMAP;</span><br></pre></td></tr></table></figure>
<h4 id="va-is-mapped"><a href="#va-is-mapped" class="headerlink" title="va_is_mapped"></a>va_is_mapped</h4><p>传入：虚拟地址va</p>
<p>传出：是否映射（0/1）</p>
<p>函数的功能是判断va地址是否被映射到某个物理页面。由于文件系统服务进程也是用户进程，所以需要逐级查找页表确定。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (((*vpd)[PDX(va)] &amp; (PTE_V)) &amp;&amp; ((*vpt)[VPN(va)] &amp; (PTE_V)));</span><br></pre></td></tr></table></figure>
<h4 id="block-is-mapped"><a href="#block-is-mapped" class="headerlink" title="block_is_mapped"></a>block_is_mapped</h4><p>传入：磁盘块的编号（<code>int blockno</code>）</p>
<p>传出：是否映射（0/1）</p>
<p>函数的功能是判断某个磁盘块对应的、在缓存中的虚拟地址是否映射到某个物理地址，方法就是获得va、在调用va_is_mapped</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u_int va = diskaddr(blockno);</span><br><span class="line"><span class="keyword">if</span> (va_is_mapped(va)) {</span><br><span class="line">    <span class="keyword">return</span> va;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="va-is-dirty"><a href="#va-is-dirty" class="headerlink" title="va_is_dirty"></a>va_is_dirty</h4><p>传入：虚拟地址va</p>
<p>传出：是否脏（0/1）</p>
<p>检查va对应的虚拟地址是否是写过的（dirty）的。同样是查页表的PTE_DIRTY位。<strong>注意：</strong>这里没有检查PTE_V，不确定是否有错</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (* vpt)[VPN(va)] &amp; PTE_D;</span><br></pre></td></tr></table></figure>
<h4 id="block-is-dirty"><a href="#block-is-dirty" class="headerlink" title="block_is_dirty"></a>block_is_dirty</h4><p>传入：磁盘块的编号（<code>int blockno</code>）</p>
<p>传出：是否脏（0/1）</p>
<p>检查磁盘块对应的虚拟地址是不是脏的。<strong>注意：</strong>在这里检查了是否已经map</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u_int va = diskaddr(blockno);</span><br><span class="line"><span class="keyword">return</span> va_is_mapped(va) &amp;&amp; va_is_dirty(va);</span><br></pre></td></tr></table></figure>
<h4 id="map-block"><a href="#map-block" class="headerlink" title="map_block"></a>map_block</h4><p>传入：磁盘块的编号（<code>int blockno</code>）</p>
<p>传出：返回分配物理空间的返回值</p>
<p>当磁盘中的磁盘块载入文件服务进程的时候，需要在缓存区中给磁盘块分配物理空间，存储磁盘块。当磁盘块不需要使用的时候，将对应的缓存器的磁盘块内容写回磁盘块，并且取消掉磁盘块对应空间的物理页面。map_block就是给磁盘块的缓存地址分配空间。因此需要知道编号为blockno的磁盘块将会缓存到文件服务进程的哪个位置；然后分配好空间。<strong>注意：</strong>分配空间需要使用系统调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> va = diskaddr(blockno);</span><br><span class="line"><span class="type">int</span> perm = PTE_R | PTE_V;<span class="comment">//这里不需要使用LIBRARY因为共享的权限是文件服务进程给的，这里也不需要fork所以不用</span></span><br><span class="line"><span class="type">int</span> r = syscall_mem_alloc(<span class="number">0</span>, va, perm);</span><br></pre></td></tr></table></figure>
<h4 id="unmap-block"><a href="#unmap-block" class="headerlink" title="unmap_block"></a>unmap_block</h4><p>传入：磁盘块的编号（<code>int blockno</code>）</p>
<p>接触某个磁盘块在缓存区的物理空间，并且如果这个block不是free而且dirty了，就将磁盘块中的新值写回磁盘（write_block）。最后使用系统调用取消掉物理页的映射。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> isfree = block_is_free(blockno);</span><br><span class="line"><span class="type">int</span> isdirty = block_is_dirty(blockno);</span><br><span class="line"><span class="keyword">if</span> (!isfree &amp;&amp; isdirty) {</span><br><span class="line">    write_block(blockno);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// Step 3: use 'syscall_mem_unmap' to unmap corresponding virtual memory.</span></span><br><span class="line"><span class="type">int</span> va = diskaddr(blockno);</span><br><span class="line"><span class="keyword">if</span> ((r = syscall_mem_unmap(<span class="number">0</span>, va)))</span><br><span class="line">    user_panic(<span class="string">"unmap_block: syscall_mem_unmap err\n"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="read-block"><a href="#read-block" class="headerlink" title="read_block"></a>read_block</h4><p>传入：磁盘块的编号（<code>int blockno</code>）</p>
<p>传出：是否成功（return）、磁盘块在缓存空间的虚拟地址（<code>void ** blk</code>）、是否是刚刚载入到缓存区（<code>u_int * isnew</code>）</p>
<p>如果调用这个函数的时候已经将磁盘块保存在缓存空间中了，则isnew为0；否则isnew为1，而且需要先为这个地址映射一个物理页面，再读取磁盘中的数据到这个位置（ide_read）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (block_is_mapped(blockno)) {	<span class="comment">// the block is in memory</span></span><br><span class="line">    <span class="keyword">if</span> (isnew) {</span><br><span class="line">        *isnew = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">} <span class="keyword">else</span> {			<span class="comment">// the block is not in memory</span></span><br><span class="line">    <span class="keyword">if</span> (isnew) {</span><br><span class="line">        *isnew = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    syscall_mem_alloc(<span class="number">0</span>, va, PTE_V | PTE_R);</span><br><span class="line">    ide_read(<span class="number">0</span>, blockno * SECT2BLK, (<span class="type">void</span> *)va, SECT2BLK);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (blk) *blk = (<span class="type">void</span> *)va;</span><br></pre></td></tr></table></figure>
<h4 id="write-block"><a href="#write-block" class="headerlink" title="write_block"></a>write_block</h4><p>传入：磁盘块的编号（<code>int blockno</code>）</p>
<p>使用ide_write把磁盘块写回到磁盘中，最后使用系统调用（syscall_mem_map）更新页面的权限位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">va = diskaddr(blockno);</span><br><span class="line">ide_write(<span class="number">0</span>, blockno * SECT2BLK, (<span class="type">void</span> *)va, SECT2BLK);</span><br><span class="line">syscall_mem_map(<span class="number">0</span>, va, <span class="number">0</span>, va, (PTE_V | PTE_R | PTE_LIBRARY));</span><br></pre></td></tr></table></figure>
<p><strong>这里为啥map了</strong></p>
<h4 id="block-is-free"><a href="#block-is-free" class="headerlink" title="block_is_free"></a>block_is_free</h4><p>传入：磁盘块的编号（<code>int blockno</code>）</p>
<p>通过查阅bitmap确定这个块是否是free的</p>
<h4 id="free-block"><a href="#free-block" class="headerlink" title="free_block"></a>free_block</h4><p>传入：磁盘块的编号（<code>int blockno</code>）</p>
<p>把磁盘块编号的磁盘在bitmap中设置为free</p>
<h4 id="alloc-block-num"><a href="#alloc-block-num" class="headerlink" title="alloc_block_num"></a>alloc_block_num</h4><p>传出：一个free的磁盘块的编号</p>
<p>从磁盘号为3开始查找如果找到一个磁盘块为free，将其设置为不free，并且返回它的磁盘号；</p>
<h4 id="alloc-block——封装函数"><a href="#alloc-block——封装函数" class="headerlink" title="alloc_block——封装函数"></a>alloc_block——封装函数</h4><p>传出：分配好的磁盘块的编号</p>
<p>使用alloc_block_num找到一个free的磁盘块，然后使用map_block给这个磁盘块分派一下物理空间，最后返回这个磁盘块的编号。</p>
<p><strong>相当于包装了一下map_block，现在直接调用这个函数就能获得一个准备好的磁盘块</strong></p>
<h4 id="read-super"><a href="#read-super" class="headerlink" title="read_super"></a>read_super</h4><p>从磁盘中读取super块</p>
<h4 id="read-bitmap"><a href="#read-bitmap" class="headerlink" title="read_bitmap"></a>read_bitmap</h4><p>从磁盘中读取bitmap块</p>
<h4 id="check-write-block"><a href="#check-write-block" class="headerlink" title="check_write_block"></a>check_write_block</h4><p>存取一下super块看看能不能用</p>
<h4 id="fs-init"><a href="#fs-init" class="headerlink" title="fs_init"></a>fs_init</h4><p>初始化文件系统进程。先读super块，检查一下能不能用，在读bitmap</p>
<h4 id="file-block-walk"><a href="#file-block-walk" class="headerlink" title="file_block_walk"></a>file_block_walk</h4><p>传入：文件结构体指针（<code>struct File * f</code>），文件直接or间接指针号（<code>int filebno</code>），如果需要间接指针是否分配物理页(<code>int alloc</code>)</p>
<p>传出：返回值（return），文件直接or间接磁盘号的指针（<code>u_int ** ppdiskbno</code>）</p>
<p>获得f文件中直接or间接指针中的对应的磁盘号的地址保存到ppdiskbno中，使得<code>**ppdiskbno = bno</code></p>
<h4 id="file-map-block"><a href="#file-map-block" class="headerlink" title="file_map_block"></a>file_map_block</h4><p>传入：文件结构体指针（<code>struct File * f</code>），文件直接or间接指针号（<code>int filebno</code>），是否创建（<code>u_int alloc</code>）</p>
<p>传出：返回值成功与否（return），文件直接or间接磁盘号的指针（<code>int * diskbno</code>）</p>
<p><strong>file_block_walk只有一个查询的功能，查询文件中对应的位置是否有一个直接or间接指针</strong>，但是这个函数需要实打实的分配一个空间，如果alloc为1，那么f文件的filebno这个位置一定会指向一个磁盘块。如果本身这个位置指向一个磁盘块的话，就不用再指向了。</p>
<h4 id="file-clear-block"><a href="#file-clear-block" class="headerlink" title="file_clear_block"></a>file_clear_block</h4><p>传入：文件结构体指针（<code>struct File * f</code>），文件直接or间接指针号（<code>int filebno</code>）</p>
<p>传出：返回值成功与否（return）</p>
<p>file_block_walk看看这个文件f中的filebno这个号的指针里面存的值。如果不是0，就将其设置为0，并且将这指向的块free掉。<strong>这里没有用syscall_unmap去掉物理页映射</strong></p>
<h4 id="file-get-block"><a href="#file-get-block" class="headerlink" title="file_get_block"></a>file_get_block</h4><p>传入：文件结构体指针（<code>struct File * f</code>），文件直接or间接指针号（<code>int filebno</code>）</p>
<p>传出：返回值成功与否（return），块的虚拟地址（<code>void ** blk</code>）</p>
<p>先用file_block_walk获得文件f中的filebno号指针存的磁盘块号，然后再用read_block把这个磁盘号对应的虚拟地址保存到blk中（<code>*blk  = (void *)va</code>）<strong>注意：</strong>文件file对应的磁盘块可能已经在缓存区中了，但是f指向的各个磁盘块可能还不在缓存区中。</p>
<h4 id="file-dirty"><a href="#file-dirty" class="headerlink" title="file_dirty"></a>file_dirty</h4><p>传入：文件结构体指针（<code>struct File * f</code>），文件中偏移量（offset）</p>
<p>把文件中偏移量为offset的磁盘块标记为dirty</p>
<h4 id="dir-lookup—没时间了，不细致写了"><a href="#dir-lookup—没时间了，不细致写了" class="headerlink" title="dir_lookup—没时间了，不细致写了"></a>dir_lookup—没时间了，不细致写了</h4><p>传入：<code>(struct File *dir, char *name, struct File **file)</code></p>
<p>在dir文件夹中查找名为name的文件or文件夹，如果找到了则令<code>*file</code>指向这个文件（这个文件的虚拟地址）</p>
<h4 id="dir-alloc-file"><a href="#dir-alloc-file" class="headerlink" title="dir_alloc_file"></a>dir_alloc_file</h4><p>传入：</p>
<p>在dir文件夹中找到一个空的文件控制块（遍历dir的每个直接or间接指针找到“外接”磁盘块，再在磁盘块中遍历File，找空的File结构体），如果找到了则<code>*file</code>指向这个虚拟地址；如果遍历完都没找到，则分配一个新的</p>
<h4 id="skip-slash"><a href="#skip-slash" class="headerlink" title="skip_slash"></a>skip_slash</h4><p>跳过当前位置开始的<code>/</code></p>
<h4 id="walk-path"><a href="#walk-path" class="headerlink" title="walk_path"></a>walk_path</h4><p>传入：<code>(char *path, struct File **pdir, struct File **pfile, char *lastelem)</code></p>
<p>从根目录开始找，沿着path中的路径一路找下去，直到最后的文件，如果找到了则</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pdir) {</span><br><span class="line">    *pdir = dir;</span><br><span class="line">}</span><br><span class="line">*pfile = file;</span><br></pre></td></tr></table></figure>
<p>如果中间有一个文件夹没找到，直接返回</p>
<p>如果中间找到个File但是不是问价夹，则报错。</p>
<h4 id="file-open——封装函数"><a href="#file-open——封装函数" class="headerlink" title="file_open——封装函数"></a>file_open——封装函数</h4><p>传入：<code>(char *path, struct File **file)</code></p>
<p>封装好walk_path，找到path对应的文件。</p>
<h4 id="file-create"><a href="#file-create" class="headerlink" title="file_create"></a>file_create</h4><p>传入参数和上一个函数一样</p>
<p>先去找path上的文件。如果差最后一步（那个文件没有创建好），则创建一下。如果中间某个文件夹没创建好，则直接报错（因为返回的r是E_NOT_FOUND</p>
<h4 id="file-truncate"><a href="#file-truncate" class="headerlink" title="file_truncate"></a>file_truncate</h4><p>传入：<code>(struct File *f, u_int newsize)</code></p>
<p>把文件截断，并且将大于newsize的空间设为空闲</p>
<h4 id="file-set-size"><a href="#file-set-size" class="headerlink" title="file_set_size"></a>file_set_size</h4><p>传入：<code>(struct File *f, u_int newsize)</code></p>
<p>可以扩大文件大小，也可以缩小文件大小，反正设置好文件的新大小</p>
<p>把这个文件所在的目录中的所有文件整个写入磁盘中（更新）</p>
<h4 id="file-flush"><a href="#file-flush" class="headerlink" title="file_flush"></a>file_flush</h4><p>传入：<code>(struct File *f)</code></p>
<p>把这个文件中所有直接or间接引用的磁盘块写回磁盘（如果dirty，就是更新过的块）</p>
<h4 id="fs-sync"><a href="#fs-sync" class="headerlink" title="fs_sync"></a>fs_sync</h4><p>在缓存区中把整个磁盘所有更新过的块写回磁盘（dirty）</p>
<h4 id="file-close"><a href="#file-close" class="headerlink" title="file_close"></a>file_close</h4><p>传入：<code>(struct File *f)</code></p>
<p>关闭一个文件，把本文件中在缓存中的所有块写回磁盘</p>
<p>并且把整个文件所在的文件夹整个写回磁盘</p>
<h4 id="file-remove"><a href="#file-remove" class="headerlink" title="file_remove"></a>file_remove</h4><p>传入：<code>(char *path)</code></p>
<p>walk_path找到这个文件。然后截断这个文件大小为0，然后设置文件的name为0，然后把文件写入磁盘，然后把这个文件所在的文件夹写入磁盘</p>
<h2 id="fs-ide-c"><a href="#fs-ide-c" class="headerlink" title="fs/ide.c"></a><code>fs/ide.c</code></h2><blockquote>
<p>指导书中的描述：文件系统通过这个文件来和磁盘镜像进行交互</p>
</blockquote>
<h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"fs.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"lib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mmu.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ide_read</span><span class="params">(u_int diskno, u_int secno, <span class="type">void</span> *dst, u_int nsecs)</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">// 0x200: the size of a sector: 512 bytes.</span></span><br><span class="line">	<span class="type">int</span> offset_begin = secno * <span class="number">0x200</span>;</span><br><span class="line">	<span class="type">int</span> offset_end = offset_begin + nsecs * <span class="number">0x200</span>;</span><br><span class="line">	<span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line">	u_int dev_addr = <span class="number">0x13000000</span>;</span><br><span class="line">	u_char status = <span class="number">0</span>;</span><br><span class="line">	u_char read_value = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (offset_begin + offset &lt; offset_end) {</span><br><span class="line">		<span class="comment">// Your code here</span></span><br><span class="line">		<span class="comment">// error occurred, then panic.</span></span><br><span class="line">		u_int now_offset = offset_begin + offset;</span><br><span class="line">		<span class="keyword">if</span> (syscall_write_dev((u_int)&amp;diskno, dev_addr + <span class="number">0x10</span>, <span class="number">4</span>) &lt; <span class="number">0</span>) {</span><br><span class="line">			user_panic(<span class="string">"ide read: diskno write err\n"</span>);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (syscall_write_dev(&amp;now_offset, dev_addr, <span class="number">4</span>) &lt; <span class="number">0</span>) {</span><br><span class="line">			user_panic(<span class="string">"ide read: offset write err\n"</span>);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (syscall_write_dev(&amp;read_value, dev_addr + <span class="number">0x20</span>, <span class="number">1</span>) &lt; <span class="number">0</span>) {</span><br><span class="line">			user_panic(<span class="string">"ide read: write value write err\n"</span>);</span><br><span class="line">		}</span><br><span class="line">		status = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (syscall_read_dev((u_int)&amp;status, dev_addr + <span class="number">0x30</span>, <span class="number">1</span>) &lt; <span class="number">0</span>) {</span><br><span class="line">			user_panic(<span class="string">"ide read: read status err\n"</span>);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (status == <span class="number">0</span>) {</span><br><span class="line">			user_panic(<span class="string">"ide read: read status err\n"</span>);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (syscall_read_dev((u_int)(dst + offset), dev_addr + <span class="number">0x4000</span>, <span class="number">0x200</span>) &lt; <span class="number">0</span>) {</span><br><span class="line">			user_panic(<span class="string">"ide read: get data err\n"</span>);</span><br><span class="line">		}</span><br><span class="line">		offset += <span class="number">0x200</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>在这个文件中有两个函数，一个是 <code>ide_read</code> 另一个是 <code>ide_write</code>。这里展示一下 read 函数。</p>
<p>函数的参数：</p>
<ul>
<li>diskno：磁盘号，不同的磁盘可以根据不同的磁盘号进行访问</li>
<li>secno：扇区号，表示这个磁盘起始开始读的扇区</li>
<li>dst：目标位置，把内容读到这里</li>
<li>nsecs：需要读的扇区个数</li>
</ul>
<p>这个函数的功能是：在磁盘号为diskno的磁盘中，把扇区号从secno到secno+nsecs总共nsecs个扇区的内容，读到dst开始的位置</p>
<h2 id="fs-serv-c"><a href="#fs-serv-c" class="headerlink" title="fs/serv.c"></a><code>fs/serv.c</code></h2><blockquote>
<p>指导书描述：文件系统进程通过 ide.c 和磁盘镜像进行交互，进程主要运行在这个文件上</p>
</blockquote>
<p>整个文件用于界定文件服务进程的结构、功能和任务。</p>
<h3 id="文件宏定义-amp-amp-必要结构体"><a href="#文件宏定义-amp-amp-必要结构体" class="headerlink" title="文件宏定义&&必要结构体"></a>文件宏定义&amp;&amp;必要结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXOPEN 1024		<span class="comment">// 在文件系统中最大打开的文件个数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILEVA 	0x60000000	<span class="comment">// 文件Filefd开始位置</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REQVA 	0x0ffff000	<span class="comment">// REQ开始位置</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Open</span> {</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">o_file</span>;</span>	<span class="comment">// mapped descriptor for open file</span></span><br><span class="line">	u_int o_fileid;		<span class="comment">// file id</span></span><br><span class="line">	<span class="type">int</span> o_mode;		<span class="comment">// open mode</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">o_ff</span>;</span>	<span class="comment">// va of filefd page</span></span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Open</span> <span class="title">opentab</span>[<span class="title">MAXOPEN</span>] =</span> {{<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>}}; <span class="comment">// 会在opentab中记录所有进程打开文件的信息</span></span><br></pre></td></tr></table></figure>
<h3 id="通关必备函数"><a href="#通关必备函数" class="headerlink" title="通关必备函数"></a>通关必备函数</h3><p><strong>user/pageref.c</strong>中的<code>pageref</code>函数用于返回物理页面映射的次数ref</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pageref</span><span class="params">(<span class="type">void</span> *v)</span></span><br><span class="line">{</span><br><span class="line">	u_int pte;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!((* vpd)[PDX(v)]&amp;PTE_V)) {</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	pte = (* vpt)[VPN(v)];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(pte &amp; PTE_V)) {</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pages[PPN(pte)].pp_ref;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这里的pages同vpd和vpt一样都是由于pmap中将用户地址空间和内核地址空间映射到相同的物理页导致的，其具体定义也在entry.S中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># user/entry.S</span><br><span class="line">	.globl pages</span><br><span class="line">pages:</span><br><span class="line">	.word UPAGES</span><br></pre></td></tr></table></figure>
<p>UPAGES就是在pmap中映射pages的位置，具体可以看<code>mips_vm_init()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mips_vm_init()</span></span><br><span class="line">pages = (<span class="keyword">struct</span> Page *)alloc(npage * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Page), BY2PG, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"to memory %x for struct Pages.\n"</span>, freemem);</span><br><span class="line">n = ROUND(npage * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Page), BY2PG);</span><br><span class="line">boot_map_segment(pgdir, UPAGES, n, PADDR(pages), PTE_R);</span><br></pre></td></tr></table></figure>
<p><strong>本文件中的<code>open_alloc</code></strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//	Allocate an open file.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">open_alloc</span><span class="params">(<span class="keyword">struct</span> Open **o)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> i, r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find an available open-file table entry</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXOPEN; i++) {</span><br><span class="line">		<span class="keyword">switch</span> (pageref(opentab[i].o_ff)) {</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">				<span class="keyword">if</span> ((r = syscall_mem_alloc(<span class="number">0</span>, (u_int)opentab[i].o_ff,</span><br><span class="line">										   PTE_V | PTE_R | PTE_LIBRARY)) &lt; <span class="number">0</span>) {</span><br><span class="line">					<span class="keyword">return</span> r;</span><br><span class="line">				}</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">				opentab[i].o_fileid += MAXOPEN;</span><br><span class="line">				*o = &amp;opentab[i];</span><br><span class="line">				user_bzero((<span class="type">void</span> *)opentab[i].o_ff, BY2PG);</span><br><span class="line">				<span class="keyword">return</span> (*o)-&gt;o_fileid;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> -E_MAX_OPEN;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>函数的行为是从0开始遍历。如果找到了一个从来没有分配过页面的位置，则首先使用系统调用给这个位置分配一个页面。这里设置页面权限为<strong>存在、可写、共享</strong>。这个页面是在文件服务进程的对应位置上进行设置的。</p>
<p>如果第一次找到的不是未分配的或者从未分配到分配，则进入case 1. 在这里，首先将文件id设置为本地id+1024。我认为这样很容易寻找，取模1024之后都在同一个位置。设置好文件id之后，把返回的o设置好，说明找到了。然后把这个页面清空，表示分配好位置了，最后把id传递回去。</p>
<p><strong>本文件中open_lookup</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//	Look up an open file for envid.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">open_lookup</span><span class="params">(u_int envid, u_int fileid, <span class="keyword">struct</span> Open **po)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Open</span> *<span class="title">o</span>;</span></span><br><span class="line">	o = &amp;opentab[fileid % MAXOPEN];	<span class="comment">// 这里就充分利用了id+1024 * n的好处了，便于通过取余确定fileid在opentab中的位置</span></span><br><span class="line">	<span class="keyword">if</span> (pageref(o-&gt;o_ff) == <span class="number">1</span> || o-&gt;o_fileid != fileid) {<span class="comment">//意思应该是说这里找到不是那个文件</span></span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	}</span><br><span class="line">	*po = o;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="serve-init服务进程初始化"><a href="#serve-init服务进程初始化" class="headerlink" title="serve_init服务进程初始化"></a><code>serve_init</code>服务进程初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//	Initialize file system server process.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">serve_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	u_int va;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set virtual address to map.</span></span><br><span class="line">	va = FILEVA;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initial array opentab.</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXOPEN; i++) {</span><br><span class="line">		opentab[i].o_fileid = i;</span><br><span class="line">		opentab[i].o_ff = (<span class="keyword">struct</span> Filefd *)va;</span><br><span class="line">		va += BY2PG;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>初始化1024个文件的offset和id。</p>
<h3 id="serve-服务主体"><a href="#serve-服务主体" class="headerlink" title="serve 服务主体"></a><code>serve</code> 服务主体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">serve</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">	u_int req, whom, perm;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) {</span><br><span class="line">		perm = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		req = ipc_recv(&amp;whom, REQVA, &amp;perm);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">// All requests must contain an argument page</span></span><br><span class="line">		<span class="keyword">if</span> (!(perm &amp; PTE_V)) {</span><br><span class="line">			writef(<span class="string">"Invalid request from %08x: no argument page\n"</span>, whom);</span><br><span class="line">			<span class="keyword">continue</span>; <span class="comment">// just leave it hanging, waiting for the next request.</span></span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (req) {</span><br><span class="line">			<span class="keyword">case</span> FSREQ_OPEN:</span><br><span class="line">				serve_open(whom, (<span class="keyword">struct</span> Fsreq_open *)REQVA);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> FSREQ_MAP:</span><br><span class="line">				serve_map(whom, (<span class="keyword">struct</span> Fsreq_map *)REQVA);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> FSREQ_SET_SIZE:</span><br><span class="line">				serve_set_size(whom, (<span class="keyword">struct</span> Fsreq_set_size *)REQVA);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> FSREQ_CLOSE:</span><br><span class="line">				serve_close(whom, (<span class="keyword">struct</span> Fsreq_close *)REQVA);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> FSREQ_DIRTY:</span><br><span class="line">				serve_dirty(whom, (<span class="keyword">struct</span> Fsreq_dirty *)REQVA);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> FSREQ_REMOVE:</span><br><span class="line">				serve_remove(whom, (<span class="keyword">struct</span> Fsreq_remove *)REQVA);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> FSREQ_SYNC:</span><br><span class="line">				serve_sync(whom);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				writef(<span class="string">"Invalid request code %d from %08x\n"</span>, whom, req);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		syscall_mem_unmap(<span class="number">0</span>, REQVA);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>整个函数是一个死循环，不断使用<code>ipc_recv(&amp;whom, REQVA, &amp;perm)</code>接受其他用户进程发来的消息，用于进行文件服务。对于服务的要求，所有的请求都必须有一个存在的页面来保存请求的具体信息。因此，函数中先检查PTE_V。进而根据不同的请求选择不同的函数。在这个进程中，其他用户进程会将信息保存到0x0ffff000开始的页面上（REQVA），然后在后续的处理过程中，调用不同的处理函数，使用不同的结构体来解释页面内部的数据。</p>
<h4 id="FSREQ-OPEN"><a href="#FSREQ-OPEN" class="headerlink" title="FSREQ_OPEN"></a>FSREQ_OPEN</h4><p>调用<code>serve_open(whom,(struct Fsreq_open *)REQVA)</code>，使用<code>Fsreq_open</code>解释页面内的数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_open</span> {</span></span><br><span class="line">	<span class="type">char</span> req_path[MAXPATHLEN];</span><br><span class="line">	u_int req_omode;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<p>结构体内部包含一个文件路径和打开的权限</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Serve requests, sending responses back to envid.</span></span><br><span class="line"><span class="comment">// To send a result back, ipc_send(envid, r, 0, 0).</span></span><br><span class="line"><span class="comment">// To include a page, ipc_send(envid, r, srcva, perm).</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">serve_open</span><span class="params">(u_int envid, <span class="keyword">struct</span> Fsreq_open *rq)</span></span><br><span class="line">{</span><br><span class="line">	writef(<span class="string">"serve_open %08x %x 0x%x\n"</span>, envid, (<span class="type">int</span>)rq-&gt;req_path, rq-&gt;req_omode);</span><br><span class="line"></span><br><span class="line">	u_char path[MAXPATHLEN];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">ff</span>;</span></span><br><span class="line">	<span class="type">int</span> fileid;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Open</span> *<span class="title">o</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Copy in the path, making sure it's null-terminated</span></span><br><span class="line">	user_bcopy(rq-&gt;req_path, path, MAXPATHLEN);</span><br><span class="line">	path[MAXPATHLEN - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find a file id.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = open_alloc(&amp;o)) &lt; <span class="number">0</span>) {</span><br><span class="line">		user_panic(<span class="string">"open_alloc failed: %d, invalid path: %s"</span>, r, path);</span><br><span class="line">		ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	fileid = r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Open the file.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = file_open((<span class="type">char</span> *)path, &amp;f)) &lt; <span class="number">0</span>) {</span><br><span class="line">	<span class="comment">//	user_panic("file_open failed: %d, invalid path: %s", r, path);</span></span><br><span class="line">		ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Save the file pointer.</span></span><br><span class="line">	o-&gt;o_file = f;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fill out the Filefd structure</span></span><br><span class="line">	ff = (<span class="keyword">struct</span> Filefd *)o-&gt;o_ff;</span><br><span class="line">	ff-&gt;f_file = *f;</span><br><span class="line">	ff-&gt;f_fileid = o-&gt;o_fileid;</span><br><span class="line">	o-&gt;o_mode = rq-&gt;req_omode;</span><br><span class="line">	ff-&gt;f_fd.fd_omode = o-&gt;o_mode;</span><br><span class="line">	ff-&gt;f_fd.fd_dev_id = devfile.dev_id;</span><br><span class="line"></span><br><span class="line">	ipc_send(envid, <span class="number">0</span>, (u_int)o-&gt;o_ff, PTE_V | PTE_R | PTE_LIBRARY);</span><br><span class="line">    <span class="comment">//这个返回值的意思是给原来那个用户进程插入一个off所在的页面，并且设置为共享。</span></span><br><span class="line">    <span class="comment">//这个off对应的都是Filefd</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>注释提示这个函数需要对于请求进行服务，然后将返回信息发送回envid对应的用户进程。</p>
<p>将待打开的文件路径复制到path；找到一个空闲的位置。然后打开path对应的文件。第一步将opentab中的文件指针设置为f，然后定位opentab中的Filefd指针。Filefd结构体中包含文件描述符、fileid、和File结构体f_file。在这里需要将f_file正确赋值、fileid赋值正确、文件描述符中的打开方式、对应的devid</p>
<h4 id="FSREQ-MAP"><a href="#FSREQ-MAP" class="headerlink" title="FSREQ_MAP"></a>FSREQ_MAP</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_map</span> {</span></span><br><span class="line">	<span class="type">int</span> req_fileid;</span><br><span class="line">	u_int req_offset;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">serve_map</span><span class="params">(u_int envid, <span class="keyword">struct</span> Fsreq_map *rq)</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Open</span> *<span class="title">pOpen</span>;</span></span><br><span class="line">	u_int filebno;</span><br><span class="line">	<span class="type">void</span> *blk;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="keyword">if</span> ((r = open_lookup(envid, rq-&gt;req_fileid, &amp;pOpen)) &lt; <span class="number">0</span>) {<span class="comment">//第一步找到这个文件。通过fileid，找到的文件保存在pOpen中</span></span><br><span class="line">		ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	filebno = rq-&gt;req_offset / BY2BLK;<span class="comment">//通过请求的offset获得这是第几个块</span></span><br><span class="line">	<span class="keyword">if</span> ((r = file_get_block(pOpen-&gt;o_file, filebno, &amp;blk)) &lt; <span class="number">0</span>) {<span class="comment">//把这个块的内容从磁盘中调到内存中</span></span><br><span class="line">		ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	ipc_send(envid, <span class="number">0</span>, (u_int)blk, PTE_V | PTE_R | PTE_LIBRARY);</span><br><span class="line">    <span class="comment">// 给原来调用这个服务的进程的地址中插入一下相同的页面，并且设置为共享。可以一块查看和修改。</span></span><br><span class="line">    <span class="comment">//这里传过去的页面是一个个磁盘块的地址</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="FSREQ-SET-SIZE"><a href="#FSREQ-SET-SIZE" class="headerlink" title="FSREQ_SET_SIZE"></a>FSREQ_SET_SIZE</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_set_size</span> {</span></span><br><span class="line">	<span class="type">int</span> req_fileid;</span><br><span class="line">	u_int req_size;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">serve_set_size</span><span class="params">(u_int envid, <span class="keyword">struct</span> Fsreq_set_size *rq)</span>{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Open</span> *<span class="title">pOpen</span>;</span></span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="keyword">if</span> ((r = open_lookup(envid, rq-&gt;req_fileid, &amp;pOpen)) &lt; <span class="number">0</span>) {<span class="comment">//找一下这个文件</span></span><br><span class="line">		ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> ((r = file_set_size(pOpen-&gt;o_file, rq-&gt;req_size)) &lt; <span class="number">0</span>) {<span class="comment">//使用fs.c中的函数，将文件的大小设置为需求中的大小</span></span><br><span class="line">		ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	ipc_send(envid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="FSREQ-CLOSE"><a href="#FSREQ-CLOSE" class="headerlink" title="FSREQ_CLOSE"></a>FSREQ_CLOSE</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_close</span> {</span></span><br><span class="line">	<span class="type">int</span> req_fileid;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">erve_close</span><span class="params">(u_int envid, <span class="keyword">struct</span> Fsreq_close *rq)</span>{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Open</span> *<span class="title">pOpen</span>;</span></span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="keyword">if</span> ((r = open_lookup(envid, rq-&gt;req_fileid, &amp;pOpen)) &lt; <span class="number">0</span>) {<span class="comment">//找到文件</span></span><br><span class="line">		ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	file_close(pOpen-&gt;o_file);<span class="comment">//使用fs.c中的函数，把这个文件关闭</span></span><br><span class="line">	ipc_send(envid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="FSREQ-DIRTY"><a href="#FSREQ-DIRTY" class="headerlink" title="FSREQ_DIRTY"></a>FSREQ_DIRTY</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_dirty</span> {</span></span><br><span class="line">	<span class="type">int</span> req_fileid;</span><br><span class="line">	u_int req_offset;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">serve_dirty</span><span class="params">(u_int envid, <span class="keyword">struct</span> Fsreq_dirty *rq)</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">// Your code here</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Open</span> *<span class="title">pOpen</span>;</span></span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="keyword">if</span> ((r = open_lookup(envid, rq-&gt;req_fileid, &amp;pOpen)) &lt; <span class="number">0</span>) { <span class="comment">// 先找到文件</span></span><br><span class="line">		ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> ((r = file_dirty(pOpen-&gt;o_file, rq-&gt;req_offset)) &lt; <span class="number">0</span>) { <span class="comment">// 然后调用fs中的函数，将这个文件设置为dirty</span></span><br><span class="line">		ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	ipc_send(envid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="FSREQ-REMOVE"><a href="#FSREQ-REMOVE" class="headerlink" title="FSREQ_REMOVE"></a>FSREQ_REMOVE</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_remove</span> {</span></span><br><span class="line">	u_char req_path[MAXPATHLEN];</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">serve_remove</span><span class="params">(u_int envid, <span class="keyword">struct</span> Fsreq_remove *rq)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	u_char path[MAXPATHLEN];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 1: Copy in the path, making sure it's terminated.</span></span><br><span class="line">	<span class="comment">// Notice: add \0 to the tail of the path</span></span><br><span class="line">	user_bcopy(rq -&gt; req_path, path, MAXPATHLEN);</span><br><span class="line">	path[MAXPATHLEN - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">	<span class="comment">// Step 2: Remove file from file system and response to user-level process.</span></span><br><span class="line">	<span class="comment">// Call file_remove and ipc_send an approprite value to corresponding env.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = file_remove(path)) &lt; <span class="number">0</span>) {</span><br><span class="line">		ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	ipc_send(envid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>和其他的函数套路一样，先设置文件路径，然后再直接remove</p>
<h4 id="FSREQ-SYNC"><a href="#FSREQ-SYNC" class="headerlink" title="FSREQ_SYNC"></a>FSREQ_SYNC</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">serve_sync</span><span class="params">(u_int envid)</span></span><br><span class="line">{	</span><br><span class="line">	fs_sync();		<span class="comment">// 将所有的dirty块写回磁盘</span></span><br><span class="line">	ipc_send(envid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="user-fsipc-c"><a href="#user-fsipc-c" class="headerlink" title="user/fsipc.c"></a><code>user/fsipc.c</code></h2><p>这个文件中函数都是用来和serv进行交互的。每个函数都对应着serv中的一个函数，同时serv中的一个函数中可能调用fs中的函数。fs中的函数是真正的底层函数。就像前几个lab中的系统调用函数一样，系统函数被包装的非常好，对外提供的就是一个函数皮。一层一层的调用，再一层一层的返回。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> u_char fsipcbuf[BY2PG]; <span class="comment">// 这里先来一页，不知道什么东西</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">fsipc</span><span class="params">(u_int type, <span class="type">void</span> *fsreq, u_int dstva, u_int *perm)</span></span><br><span class="line">{</span><br><span class="line">	u_int whom;</span><br><span class="line">	<span class="comment">// NOTEICE: Our file system no.1 process!</span></span><br><span class="line">   	<span class="comment">// 这个函数的作用就是给文件服务进程传递一个消息并且等待返回值。</span></span><br><span class="line">    <span class="comment">// 这个估计又是底层函数了，就是说，其他啊fsipc_xxx函数最终会调用这个函数和文件服务进程通信</span></span><br><span class="line">    <span class="comment">// 这里需要特别注意，文件服务进程的id号是1，这个要格外注意和小心。</span></span><br><span class="line">	ipc_send(envs[<span class="number">1</span>].env_id, type, (u_int)fsreq, PTE_V | PTE_R);</span><br><span class="line">	<span class="keyword">return</span> ipc_recv(&amp;whom, dstva, perm);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="fsipc-open"><a href="#fsipc-open" class="headerlink" title="fsipc_open"></a>fsipc_open</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fsipc_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, u_int omode, <span class="keyword">struct</span> Fd *fd)</span></span><br><span class="line">{</span><br><span class="line">	u_int perm;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_open</span> *<span class="title">req</span>;</span></span><br><span class="line">	req = (<span class="keyword">struct</span> Fsreq_open *)fsipcbuf;</span><br><span class="line">	<span class="comment">// The path is too long.</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strlen</span>(path) &gt;= MAXPATHLEN) {</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">strcpy</span>((<span class="type">char</span> *)req-&gt;req_path, path);</span><br><span class="line">	req-&gt;req_omode = omode;</span><br><span class="line">	<span class="keyword">return</span> fsipc(FSREQ_OPEN, req, (u_int)fd, &amp;perm);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="fsipc-map"><a href="#fsipc-map" class="headerlink" title="fsipc_map"></a>fsipc_map</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fsipc_map</span><span class="params">(u_int fileid, u_int offset, u_int dstva)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	u_int perm;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_map</span> *<span class="title">req</span>;</span></span><br><span class="line">	req = (<span class="keyword">struct</span> Fsreq_map *)fsipcbuf;</span><br><span class="line">	req-&gt;req_fileid = fileid;</span><br><span class="line">	req-&gt;req_offset = offset;</span><br><span class="line">	<span class="keyword">if</span> ((r = fsipc(FSREQ_MAP, req, dstva, &amp;perm)) &lt; <span class="number">0</span>) {</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> ((perm &amp; ~(PTE_R | PTE_LIBRARY)) != (PTE_V)) {<span class="comment">//检查一下权限，必须有PTE_V，可以有PTE_R和PTE_LIBRARY</span></span><br><span class="line">		user_panic(<span class="string">"fsipc_map: unexpected permissions %08x for dstva %08x"</span>, perm,</span><br><span class="line">				   dstva);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="fsipc-set-size"><a href="#fsipc-set-size" class="headerlink" title="fsipc_set_size"></a>fsipc_set_size</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fsipc_set_size</span><span class="params">(u_int fileid, u_int size)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_set_size</span> *<span class="title">req</span>;</span></span><br><span class="line"></span><br><span class="line">	req = (<span class="keyword">struct</span> Fsreq_set_size *)fsipcbuf;</span><br><span class="line">	req-&gt;req_fileid = fileid;</span><br><span class="line">	req-&gt;req_size = size;</span><br><span class="line">	<span class="keyword">return</span> fsipc(FSREQ_SET_SIZE, req, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="fsipc-close"><a href="#fsipc-close" class="headerlink" title="fsipc_close"></a>fsipc_close</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fsipc_close</span><span class="params">(u_int fileid)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_close</span> *<span class="title">req</span>;</span></span><br><span class="line"></span><br><span class="line">	req = (<span class="keyword">struct</span> Fsreq_close *)fsipcbuf;</span><br><span class="line">	req-&gt;req_fileid = fileid;</span><br><span class="line">	<span class="keyword">return</span> fsipc(FSREQ_CLOSE, req, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="fsipc-dirty"><a href="#fsipc-dirty" class="headerlink" title="fsipc_dirty"></a>fsipc_dirty</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fsipc_dirty</span><span class="params">(u_int fileid, u_int offset)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_dirty</span> *<span class="title">req</span>;</span></span><br><span class="line"></span><br><span class="line">	req = (<span class="keyword">struct</span> Fsreq_dirty *)fsipcbuf;</span><br><span class="line">	req-&gt;req_fileid = fileid;</span><br><span class="line">	req-&gt;req_offset = offset;</span><br><span class="line">	<span class="keyword">return</span> fsipc(FSREQ_DIRTY, req, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="fsipc-remove"><a href="#fsipc-remove" class="headerlink" title="fsipc_remove"></a>fsipc_remove</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fsipc_remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_remove</span> * <span class="title">req</span>;</span></span><br><span class="line">	<span class="comment">// Step 1: Check the length of path, decide if the path is valid.</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strlen</span>(path) &gt; MAXPATHLEN) <span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">	<span class="comment">// Step 2: Transform fsipcbuf to struct Fsreq_remove*</span></span><br><span class="line">	req = (<span class="keyword">struct</span> Fsreq_remove *)fsipcbuf;</span><br><span class="line">	<span class="comment">// Step 3: Copy path to path in req.</span></span><br><span class="line">	<span class="built_in">strcpy</span>((<span class="type">char</span> *)req -&gt; req_path, path);</span><br><span class="line">	<span class="comment">// Step 4: Send request to fs server with IPC.</span></span><br><span class="line">	<span class="keyword">return</span> fsipc(FSREQ_REMOVE, req, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="fsipc-sync"><a href="#fsipc-sync" class="headerlink" title="fsipc_sync"></a>fsipc_sync</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fsipc_sync</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> fsipc(FSREQ_SYNC, fsipcbuf, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="user-fd-c"><a href="#user-fd-c" class="headerlink" title="user/fd.c"></a><code>user/fd.c</code></h2><blockquote>
<p>指导书描述：在这个文件中引入文件描述符</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> *<span class="title">devtab</span>[] =</span> {	<span class="comment">// 这是所有dev的数组，记录了所有的dev，在MOS中包括三个dev，分别是devfile、devcons和devpipe</span></span><br><span class="line">	&amp;devfile,</span><br><span class="line">	&amp;devcons,</span><br><span class="line">	&amp;devpipe,</span><br><span class="line">	<span class="number">0</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h4 id="dev-lookup"><a href="#dev-lookup" class="headerlink" title="dev_lookup"></a>dev_lookup</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dev_lookup</span><span class="params">(<span class="type">int</span> dev_id, <span class="keyword">struct</span> Dev **dev)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; devtab[i]; i++)</span><br><span class="line">		<span class="keyword">if</span> (devtab[i]-&gt;dev_id == dev_id) {<span class="comment">//遍历devtab，寻找devid等于传进来参数的设备</span></span><br><span class="line">			*dev = devtab[i];</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">	writef(<span class="string">"[%08x] unknown device type %d\n"</span>, env-&gt;env_id, dev_id);</span><br><span class="line">	<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="fd-alloc"><a href="#fd-alloc" class="headerlink" title="fd_alloc"></a>fd_alloc</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fd_alloc</span><span class="params">(<span class="keyword">struct</span> Fd **fd)</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">// Find the smallest i from 0 to MAXFD-1 that doesn't have</span></span><br><span class="line">	<span class="comment">// its fd page mapped.  Set *fd to the fd page virtual address.</span></span><br><span class="line">	<span class="comment">// (Do not allocate a page.  It is up to the caller to allocate</span></span><br><span class="line">	<span class="comment">// the page.  This means that if someone calls fd_alloc twice</span></span><br><span class="line">	<span class="comment">// in a row without allocating the first page we return, we'll</span></span><br><span class="line">	<span class="comment">// return the same page the second time.)</span></span><br><span class="line">	<span class="comment">// Return 0 on success, or an error code on error.</span></span><br><span class="line">	u_int va;</span><br><span class="line">	u_int fdno;</span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="keyword">for</span> (fdno = <span class="number">0</span>; fdno &lt; MAXFD - <span class="number">1</span>; fdno++) {	<span class="comment">//最多有32个文件描述符（一个文件描述符占一页）</span></span><br><span class="line">		va = INDEX2FD(fdno);<span class="comment">//根据文件描述符的号查找这里的地址</span></span><br><span class="line">		<span class="comment">// 之后找到第一个没有用过的文件描述符，但是此时暂时不给他分配页，交给调用的进程分配页。</span></span><br><span class="line">        <span class="comment">// 因为如果调用的进程不分配页，则下次调用还是返回这个地址</span></span><br><span class="line">		<span class="keyword">if</span> (((* vpd)[va / PDMAP] &amp; PTE_V) == <span class="number">0</span>) {</span><br><span class="line">			*fd = (<span class="keyword">struct</span> Fd *)va;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (((* vpt)[va / BY2PG] &amp; PTE_V) == <span class="number">0</span>) {	<span class="comment">//the fd is not used</span></span><br><span class="line">			*fd = (<span class="keyword">struct</span> Fd *)va;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> -E_MAX_OPEN;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="fd-close"><a href="#fd-close" class="headerlink" title="fd_close"></a>fd_close</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fd_close</span><span class="params">(<span class="keyword">struct</span> Fd *fd)</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">// 直接系统调用将块的物理页剥夺</span></span><br><span class="line">	syscall_mem_unmap(<span class="number">0</span>, (u_int)fd);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="fd-lookup"><a href="#fd-lookup" class="headerlink" title="fd_lookup"></a>fd_lookup</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fd_lookup</span><span class="params">(<span class="type">int</span> fdnum, <span class="keyword">struct</span> Fd **fd)</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">// Check that fdnum is in range and mapped.  If not, return -E_INVAL.</span></span><br><span class="line">	<span class="comment">// Set *fd to the fd page virtual address.  Return 0.</span></span><br><span class="line">	u_int va;</span><br><span class="line">	<span class="keyword">if</span> (fdnum &gt;= MAXFD) {</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	}</span><br><span class="line">	va = INDEX2FD(fdnum);</span><br><span class="line">    <span class="comment">// 去找这个fdnum对应的虚拟地址</span></span><br><span class="line">	<span class="keyword">if</span> (((* vpt)[va / BY2PG] &amp; PTE_V) != <span class="number">0</span>) {	<span class="comment">//the fd is used</span></span><br><span class="line">		*fd = (<span class="keyword">struct</span> Fd *)va;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="fd2data"><a href="#fd2data" class="headerlink" title="fd2data"></a>fd2data</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INDEX2DATA(i)	(FILEBASE+(i)*PDMAP)</span></span><br><span class="line">u_int <span class="title function_">fd2data</span><span class="params">(<span class="keyword">struct</span> Fd *fd)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> INDEX2DATA(fd2num(fd));<span class="comment">//从fd的编号得到这块对应的data</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="fd2num"><a href="#fd2num" class="headerlink" title="fd2num"></a>fd2num</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fd2num</span><span class="params">(<span class="keyword">struct</span> Fd *fd)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> ((u_int)fd - FDTABLE) / BY2PG;<span class="comment">//通过地址获得这是第几个fd</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="num2fd"><a href="#num2fd" class="headerlink" title="num2fd"></a>num2fd</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INDEX2FD(i)	(FDTABLE+(i)*BY2PG)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">num2fd</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> fd * BY2PG + FDTABLE;<span class="comment">//这个函数和某一个宏函数重复了</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="close"><a href="#close" class="headerlink" title="close"></a>close</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fdnum)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span></span><br><span class="line">		||  (r = dev_lookup(fd-&gt;fd_dev_id, &amp;dev)) &lt; <span class="number">0</span>) { <span class="comment">// 找到这个fd，再找到这个fd对应的设备</span></span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	r = (*dev-&gt;dev_close)(fd); <span class="comment">// 调用这个设备的close方法</span></span><br><span class="line">	fd_close(fd);	<span class="comment">// 这个函数内部直接调用函数调用，取消这个虚拟地址的物理地址映射</span></span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="close-all"><a href="#close-all" class="headerlink" title="close_all"></a>close_all</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">close_all</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXFD; i++) {</span><br><span class="line">		close(i);<span class="comment">//把所有文件描述符都关闭</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h4><p>下标为oldfnum文件控制块的内容拷贝到newfdnum的文件控制块中，并将文件控制块控制的文件内容从地址fd2data(oldfd)的位置拷贝到fd2data(newfd)的位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfdnum, <span class="type">int</span> newfdnum)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> i, r;</span><br><span class="line">	u_int ova, nva, pte;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">oldfd</span>, *<span class="title">newfd</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(oldfdnum, &amp;oldfd)) &lt; <span class="number">0</span>) {<span class="comment">//先找到原来的文件描述符</span></span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	close(newfdnum);	<span class="comment">//准备好新的文件描述符</span></span><br><span class="line">	newfd = (<span class="keyword">struct</span> Fd *)INDEX2FD(newfdnum);</span><br><span class="line">	ova = fd2data(oldfd);<span class="comment">//获得新旧文件描述符的地址，准备将旧文件描述符拷贝到新的文件描述符的地址</span></span><br><span class="line">	nva = fd2data(newfd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = syscall_mem_map(<span class="number">0</span>, (u_int)oldfd, <span class="number">0</span>, (u_int)newfd,</span><br><span class="line">							 ((*vpt)[VPN(oldfd)]) &amp; (PTE_V | PTE_R | PTE_LIBRARY))) &lt; <span class="number">0</span>) {<span class="comment">//把文件控制符的拷贝过去</span></span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((* vpd)[PDX(ova)]) {<span class="comment">//从这个地址开始，将所有的页复制到新的文件描述符对应的地址</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PDMAP; i += BY2PG) {</span><br><span class="line">			pte = (* vpt)[VPN(ova + i)];</span><br><span class="line">			<span class="keyword">if</span> (pte &amp; PTE_V) {</span><br><span class="line">				<span class="comment">// should be no error here -- pd is already allocated</span></span><br><span class="line">				<span class="keyword">if</span> ((r = syscall_mem_map(<span class="number">0</span>, ova + i, <span class="number">0</span>, nva + i,</span><br><span class="line">										 pte &amp; (PTE_V | PTE_R | PTE_LIBRARY))) &lt; <span class="number">0</span>) {</span><br><span class="line">					<span class="keyword">goto</span> err;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> newfdnum;</span><br><span class="line">err:</span><br><span class="line">	syscall_mem_unmap(<span class="number">0</span>, (u_int)newfd);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PDMAP; i += BY2PG) {</span><br><span class="line">		syscall_mem_unmap(<span class="number">0</span>, nva + i);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="read"><a href="#read" class="headerlink" title="read"></a>read</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//	Read 'n' bytes from 'fd' at the current seek position into 'buf'.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Post-Condition:</span></span><br><span class="line"><span class="comment">//	Update seek position.</span></span><br><span class="line"><span class="comment">//	Return the number of bytes read successfully.</span></span><br><span class="line"><span class="comment">//		&lt; 0 on error</span></span><br><span class="line"><span class="comment">/*** exercise 5.9 ***/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fdnum, <span class="type">void</span> *buf, u_int n)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Similar to 'write' function.</span></span><br><span class="line">	<span class="comment">// Step 1: Get fd and dev.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span></span><br><span class="line">		||  (r = dev_lookup(fd-&gt;fd_dev_id, &amp;dev)) &lt; <span class="number">0</span>) {<span class="comment">//找到对应的文件描述符和设备</span></span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// Step 2: Check open mode.</span></span><br><span class="line">	<span class="keyword">if</span> ((fd-&gt;fd_omode &amp; O_ACCMODE) == O_WRONLY) {	<span class="comment">// 如果文件打开权限只能写，不能读，则报错</span></span><br><span class="line">		writef(<span class="string">"[%08x] read %d -- bad mode\n"</span>, env-&gt;env_id, fdnum);</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// Step 3: Read starting from seek position.</span></span><br><span class="line">	<span class="keyword">if</span> (debug) writef(<span class="string">"read %d %p %d via dev %s\n"</span>,</span><br><span class="line">						  fdnum, buf, n, dev-&gt;dev_name);</span><br><span class="line">	r = (*dev-&gt;dev_read)(fd, buf, n, fd-&gt;fd_offset);		<span class="comment">// 调用设备中包含的dev_read</span></span><br><span class="line">	<span class="comment">// Step 4: Update seek position and set '\0' at the end of buf.</span></span><br><span class="line">	<span class="keyword">if</span> (r &gt; <span class="number">0</span>) {</span><br><span class="line">		fd-&gt;fd_offset += r;<span class="comment">//file_read函数中每次读取都是从offset开始，这里设置下一次读取开始的位置。</span></span><br><span class="line">	}</span><br><span class="line">	((<span class="type">char</span>*)buf)[r] = <span class="string">'\0'</span>;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="readn"><a href="#readn" class="headerlink" title="readn"></a>readn</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">readn</span><span class="params">(<span class="type">int</span> fdnum, <span class="type">void</span> *buf, u_int n)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> m, tot;</span><br><span class="line">	<span class="keyword">for</span> (tot = <span class="number">0</span>; tot &lt; n; tot += m) {<span class="comment">//当需要读取大量的字符或者多次读取的时候使用这个函数</span></span><br><span class="line">        <span class="comment">//这个函数中多次调用read。每次读取之后检查是否读对了，</span></span><br><span class="line">        <span class="comment">//这个函数可以支持读取长度大于n，</span></span><br><span class="line">        <span class="comment">//而且这个函数是不断读取这里的位置</span></span><br><span class="line">        <span class="comment">//直到读取的长度为n。只许成功不许失败</span></span><br><span class="line">		m = read(fdnum, (<span class="type">char</span> *)buf + tot, n - tot);</span><br><span class="line">		<span class="keyword">if</span> (m &lt; <span class="number">0</span>) {</span><br><span class="line">			<span class="keyword">return</span> m;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (m == <span class="number">0</span>) {</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> tot;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="write"><a href="#write" class="headerlink" title="write"></a>write</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fdnum, <span class="type">const</span> <span class="type">void</span> *buf, u_int n)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span></span><br><span class="line">		||  (r = dev_lookup(fd-&gt;fd_dev_id, &amp;dev)) &lt; <span class="number">0</span>) {</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((fd-&gt;fd_omode &amp; O_ACCMODE) == O_RDONLY) {</span><br><span class="line">		writef(<span class="string">"[%08x] write %d -- bad mode\n"</span>, env-&gt;env_id, fdnum);</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (debug) writef(<span class="string">"write %d %p %d via dev %s\n"</span>,</span><br><span class="line">						  fdnum, buf, n, dev-&gt;dev_name);</span><br><span class="line"></span><br><span class="line">	r = (*dev-&gt;dev_write)(fd, buf, n, fd-&gt;fd_offset);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (r &gt; <span class="number">0</span>) {</span><br><span class="line">		fd-&gt;fd_offset += r;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="seek"><a href="#seek" class="headerlink" title="seek"></a>seek</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">seek</span><span class="params">(<span class="type">int</span> fdnum, u_int offset)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span>) {<span class="comment">//找到这个文件控制符</span></span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	fd-&gt;fd_offset = offset;<span class="comment">//将offset设置为传进来的offset</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="fstat"><a href="#fstat" class="headerlink" title="fstat"></a>fstat</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fdnum, <span class="keyword">struct</span> Stat *stat)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span></span><br><span class="line">		||  (r = dev_lookup(fd-&gt;fd_dev_id, &amp;dev)) &lt; <span class="number">0</span>) {<span class="comment">//找到这个文件和对应的设备</span></span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	}</span><br><span class="line">	stat-&gt;st_name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	stat-&gt;st_size = <span class="number">0</span>;</span><br><span class="line">	stat-&gt;st_isdir = <span class="number">0</span>;</span><br><span class="line">	stat-&gt;st_dev = dev;</span><br><span class="line">	<span class="keyword">return</span> (*dev-&gt;dev_stat)(fd, stat);<span class="comment">//调用file_stat将文件的状态保存到stat中</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="keyword">struct</span> Stat *stat)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> fd, r;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((fd = open(path, O_RDONLY)) &lt; <span class="number">0</span>) {<span class="comment">//打开文件</span></span><br><span class="line">		<span class="keyword">return</span> fd;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	r = fstat(fd, stat);<span class="comment">//获取文件的状态</span></span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="user-file-c"><a href="#user-file-c" class="headerlink" title="user/file.c"></a><code>user/file.c</code></h2><blockquote>
<p>指导书描述：用户进程在filec中实现用户接口</p>
</blockquote>
<p>操作系统中有三种设备，这是其中一个叫做devfile</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> <span class="title">devfile</span> =</span> {</span><br><span class="line">	.dev_id =	<span class="string">'f'</span>,<span class="comment">//注释说，点代表在结构体定义中选择同名的变量并且不用在意定义的顺序，用于给结构体赋值。</span></span><br><span class="line">	.dev_name =	<span class="string">"file"</span>,</span><br><span class="line">	.dev_read =	file_read,</span><br><span class="line">	.dev_write =	file_write,</span><br><span class="line">	.dev_close =	file_close,</span><br><span class="line">	.dev_stat =	file_stat,</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h4 id="open"><a href="#open" class="headerlink" title="open"></a>open</h4><p>函数的特点：这个函数的功能是打开一个文件。首先需要分配一个文件描述符。然后通过ipc命令文件服务进程打开文件。</p>
<p>因为都是通过ipc进行进程间的通信，所以都是使用ipc_send进行页面的传输。侧面印证了为什么一个fd结构体预留了1页的空间</p>
<p>获得fd结构体之后，根据其中信息，将文件的内容全部展开放到va开始的位置里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//	Open a file (or directory).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns:</span></span><br><span class="line"><span class="comment">//	the file descriptor onsuccess,</span></span><br><span class="line"><span class="comment">//	&lt; 0 on failure.</span></span><br><span class="line"><span class="comment">/*** exercise 5.8 ***/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> mode)</span> {</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">ffd</span>;</span></span><br><span class="line">	u_int size, fileid;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	u_int va;</span><br><span class="line">	u_int i;</span><br><span class="line">	<span class="comment">// Step 1: Alloc a new Fd, return error code when fail to alloc.</span></span><br><span class="line">	<span class="comment">// Hint: Please use fd_alloc.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_alloc(&amp;fd)) &lt; <span class="number">0</span>) <span class="keyword">return</span> r;</span><br><span class="line">	<span class="comment">// Step 2: Get the file descriptor of the file to open.</span></span><br><span class="line">	<span class="comment">// Hint: Read fsipc.c, and choose a function.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = fsipc_open(path, mode, fd)) &lt; <span class="number">0</span>) <span class="keyword">return</span> r;</span><br><span class="line">	<span class="comment">// Step 3: Set the start address storing the file's content. Set size and fileid correctly.</span></span><br><span class="line">	<span class="comment">// Hint: Use fd2data to get the start address.</span></span><br><span class="line">	ffd = (<span class="keyword">struct</span> Filefd*)fd;</span><br><span class="line">	va = fd2data(fd);</span><br><span class="line">	fileid = ffd -&gt; f_fileid;</span><br><span class="line">	size = ffd -&gt; f_file.f_size;</span><br><span class="line">	<span class="comment">// Step 4: Alloc memory, map the file content into memory.</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i += BY2PG) {</span><br><span class="line">		<span class="keyword">if</span> ((r = fsipc_map(fileid, i, va + i)) &lt; <span class="number">0</span>) {</span><br><span class="line">			writef(<span class="string">"cannot map the file.\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// Step 5: Return the number of file descriptor.</span></span><br><span class="line">	<span class="keyword">return</span> fd2num(fd);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="file-close-1"><a href="#file-close-1" class="headerlink" title="file_close"></a>file_close</h4><p>功能：关闭一个文件描述符。首先将dirty页面都保存回磁盘。然后告诉文件服务进程把这个文件关闭。最后把本进程中va开始的文件大小的空间全部取消映射。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//	Close a file descriptor</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">file_close</span><span class="params">(<span class="keyword">struct</span> Fd *fd)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">ffd</span>;</span></span><br><span class="line">	u_int va, size, fileid;</span><br><span class="line">	u_int i;</span><br><span class="line">	ffd = (<span class="keyword">struct</span> Filefd *)fd;</span><br><span class="line">	fileid = ffd-&gt;f_fileid;</span><br><span class="line">	size = ffd-&gt;f_file.f_size;</span><br><span class="line">	<span class="comment">// Set the start address storing the file's content.</span></span><br><span class="line">	va = fd2data(fd);</span><br><span class="line">	<span class="comment">// Tell the file server the dirty page.</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i += BY2PG) {</span><br><span class="line">		fsipc_dirty(fileid, i);</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// Request the file server to close the file with fsipc.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = fsipc_close(fileid)) &lt; <span class="number">0</span>) {</span><br><span class="line">		writef(<span class="string">"cannot close the file\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// Unmap the content of file, release memory.</span></span><br><span class="line">	<span class="keyword">if</span> (size == <span class="number">0</span>) {</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i += BY2PG) {</span><br><span class="line">		<span class="keyword">if</span> ((r = syscall_mem_unmap(<span class="number">0</span>, va + i)) &lt; <span class="number">0</span>) {</span><br><span class="line">			writef(<span class="string">"cannont unmap the file.\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="file-read"><a href="#file-read" class="headerlink" title="file_read"></a>file_read</h4><p>将文件中offset开始的n个字节读入到buf中，然后返回读进来的字符数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//	Read 'n' bytes from 'fd' at the current seek position into 'buf'. Since files</span></span><br><span class="line"><span class="comment">//	are memory-mapped, this amounts to a user_bcopy() surrounded by a little red</span></span><br><span class="line"><span class="comment">//	tape to handle the file size and seek pointer.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">file_read</span><span class="params">(<span class="keyword">struct</span> Fd *fd, <span class="type">void</span> *buf, u_int n, u_int offset)</span></span><br><span class="line">{</span><br><span class="line">	u_int size;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">f</span>;</span></span><br><span class="line">	f = (<span class="keyword">struct</span> Filefd *)fd;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Avoid reading past the end of file.</span></span><br><span class="line">	size = f-&gt;f_file.f_size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (offset &gt; size) {</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (offset + n &gt; size) {</span><br><span class="line">		n = size - offset;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	user_bcopy((<span class="type">char</span> *)fd2data(fd) + offset, buf, n);</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="read-map"><a href="#read-map" class="headerlink" title="read_map"></a>read_map</h4><p>函数功能：找到fdnum对应的文件数据从offset开始，将这个地址交给blk</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//	Find the virtual address of the page that maps the file block</span></span><br><span class="line"><span class="comment">//	starting at 'offset'.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">read_map</span><span class="params">(<span class="type">int</span> fdnum, u_int offset, <span class="type">void</span> **blk)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	u_int va;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span>) {</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fd-&gt;fd_dev_id != devfile.dev_id) {</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	va = fd2data(fd) + offset;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (offset &gt;= MAXFILESIZE) {</span><br><span class="line">		<span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!((* vpd)[PDX(va)]&amp;PTE_V) || !((* vpt)[VPN(va)]&amp;PTE_V)) {</span><br><span class="line">		<span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	*blk = (<span class="type">void</span> *)va;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="file-write"><a href="#file-write" class="headerlink" title="file_write"></a>file_write</h4><p>在文件offset开始的位置写n个字节</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//	Write 'n' bytes from 'buf' to 'fd' at the current seek position.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">file_write</span><span class="params">(<span class="keyword">struct</span> Fd *fd, <span class="type">const</span> <span class="type">void</span> *buf, u_int n, u_int offset)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	u_int tot;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">	f = (<span class="keyword">struct</span> Filefd *)fd;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Don't write more than the maximum file size.</span></span><br><span class="line">	tot = offset + n;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tot &gt; MAXFILESIZE) {</span><br><span class="line">		<span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Increase the file's size if necessary</span></span><br><span class="line">	<span class="keyword">if</span> (tot &gt; f-&gt;f_file.f_size) {</span><br><span class="line">		<span class="keyword">if</span> ((r = ftruncate(fd2num(fd), tot)) &lt; <span class="number">0</span>) {<span class="comment">//这里可以对文件大小进行扩充</span></span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Write the data</span></span><br><span class="line">	user_bcopy(buf, (<span class="type">char</span> *)fd2data(fd) + offset, n);</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="file-stat"><a href="#file-stat" class="headerlink" title="file_stat"></a>file_stat</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">file_stat</span><span class="params">(<span class="keyword">struct</span> Fd *fd, <span class="keyword">struct</span> Stat *st)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">	f = (<span class="keyword">struct</span> Filefd *)fd;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strcpy</span>(st-&gt;st_name, (<span class="type">char</span> *)f-&gt;f_file.f_name);</span><br><span class="line">	st-&gt;st_size = f-&gt;f_file.f_size;</span><br><span class="line">	st-&gt;st_isdir = f-&gt;f_file.f_type == FTYPE_DIR;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="ftruncate"><a href="#ftruncate" class="headerlink" title="ftruncate"></a>ftruncate</h4><p>函数功能：这个里面有两个步骤，如果需要对于文件大小进行扩展的话，需要对新的内容分配新的页面；如果需要对文件大小进行缩减的话，需要取消映射释放资源</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//	Truncate or extend an open file to 'size' bytes</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">ftruncate</span><span class="params">(<span class="type">int</span> fdnum, u_int size)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> i, r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">f</span>;</span></span><br><span class="line">	u_int oldsize, va, fileid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (size &gt; MAXFILESIZE) {</span><br><span class="line">		<span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span>) {<span class="comment">//找到文件</span></span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fd-&gt;fd_dev_id != devfile.dev_id) {</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	f = (<span class="keyword">struct</span> Filefd *)fd;</span><br><span class="line">	fileid = f-&gt;f_fileid;</span><br><span class="line">	oldsize = f-&gt;f_file.f_size;</span><br><span class="line">	f-&gt;f_file.f_size = size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = fsipc_set_size(fileid, size)) &lt; <span class="number">0</span>) {</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	va = fd2data(fd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Map any new pages needed if extending the file</span></span><br><span class="line">	<span class="keyword">for</span> (i = ROUND(oldsize, BY2PG); i &lt; ROUND(size, BY2PG); i += BY2PG) {</span><br><span class="line">		<span class="keyword">if</span> ((r = fsipc_map(fileid, i, va + i)) &lt; <span class="number">0</span>) {<span class="comment">//如果文件大小扩充失败</span></span><br><span class="line">			fsipc_set_size(fileid, oldsize);</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Unmap pages if truncating the file</span></span><br><span class="line">	<span class="keyword">for</span> (i = ROUND(size, BY2PG); i &lt; ROUND(oldsize, BY2PG); i += BY2PG)</span><br><span class="line">		<span class="keyword">if</span> ((r = syscall_mem_unmap(<span class="number">0</span>, va + i)) &lt; <span class="number">0</span>) {</span><br><span class="line">			user_panic(<span class="string">"ftruncate: syscall_mem_unmap %08x: %e"</span>, va + i, r);</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//	Delete a file or directory.</span></span><br><span class="line"><span class="comment">/*** exercise 5.10 ***/</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">// Your code here.</span></span><br><span class="line">	<span class="comment">// Call fsipc_remove.</span></span><br><span class="line">	<span class="keyword">return</span> fsipc_remove(path);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//	Synchronize disk with buffer cache</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sync</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> fsipc_sync();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="user-pipe-c"><a href="#user-pipe-c" class="headerlink" title="user/pipe.c"></a><code>user/pipe.c</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> <span class="title">devpipe</span> =</span> {</span><br><span class="line">	.dev_id =	<span class="string">'p'</span>,</span><br><span class="line">	.dev_name =	<span class="string">"pipe"</span>,</span><br><span class="line">	.dev_read =	<span class="literal">NULL</span>,</span><br><span class="line">	.dev_write = <span class="literal">NULL</span>,</span><br><span class="line">	.dev_close = <span class="literal">NULL</span>,</span><br><span class="line">	.dev_stat =	<span class="literal">NULL</span>,</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BY2PIPE 32		<span class="comment">// small to provoke races</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pipe</span> {</span></span><br><span class="line">	u_int p_rpos;		    <span class="comment">// read position</span></span><br><span class="line">	u_int p_wpos;		    <span class="comment">// write position</span></span><br><span class="line">	u_char p_buf[BY2PIPE];	<span class="comment">// data buffer</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h2 id="user-console-c"><a href="#user-console-c" class="headerlink" title="user/console.c"></a><code>user/console.c</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> <span class="title">devcons</span> =</span> {</span><br><span class="line">	.dev_id =	<span class="string">'c'</span>,</span><br><span class="line">	.dev_name =	<span class="string">"cons"</span>,</span><br><span class="line">	.dev_read =	<span class="literal">NULL</span>,</span><br><span class="line">	.dev_write =	<span class="literal">NULL</span>,</span><br><span class="line">	.dev_close =	<span class="literal">NULL</span>,</span><br><span class="line">	.dev_stat =	<span class="literal">NULL</span>,</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li><p>diskno是如何对应一块块磁盘的呢？比如实验中我们只有一块磁盘，但是考试中新增了几块磁盘。使用不同的diskno可以对应不同的磁盘，这是如何做到的呢？</p>
</li>
<li><p>fsformat.c 中，create_file</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nblk = dirf -&gt; f_size / BY2BLK;</span><br></pre></td></tr></table></figure>
<p>含义是nblk=当前目录的大小除以一个块字节大小（算出已经使用了多少个块）。这里直接使用的是/号，没有做向上取整，说明nblk所在文件指针可能有东西。</p>
</li>
<li><p>拼错单词了fsformat</p>
<p><img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20220605140130015.png" alt="image-20220605140130015"></p>
</li>
<li><p>fsformat write file 中，fname不是const char 吗为什么还能++</p>
</li>
<li><p>user/fd.h中定义FILEBASE和fs/serv.c中定义FILEVA都是0x60000000，这两者有什么区别和联系吗？serv中的FILEVA是在文件服务进程中，FILEBASE定义的是啥呀</p>
</li>
<li><p>使用fd的时候这是哪个进程呀</p>
</li>
<li><p>从什么过程开始文件内容是按照顺序排开的？（至少在用户进程中是排开的）</p>
</li>
</ol>

    </div>

    
    
    

    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
      
    </div>

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Zhang-kg
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://zhang-kg.github.io/2022/06/08/BUAA-OS/" title="Lab5 掰开揉碎">https://zhang-kg.github.io/2022/06/08/BUAA-OS/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/BUAA-OS/" rel="tag"># BUAA_OS</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/06/05/BUAA-OO-%E7%AC%AC%E4%B8%89%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/" rel="prev" title="BUAA_OO 第三单元总结">
                  <i class="fa fa-chevron-left"></i> BUAA_OO 第三单元总结
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/06/09/BUAA-OS-Lab5-2-Extra/" rel="next" title="BUAA_OS Lab5-2-Extra">
                  BUAA_OS Lab5-2-Extra <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang-kg</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">98k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:29</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"mhchem":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
