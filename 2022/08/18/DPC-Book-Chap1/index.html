<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zhang-kg.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="This chapter provided terminology needed for SYCL and DPC++ and provided refreshers on key aspects of parallel programming and C++ that are critical to SYCL and DPC++. Chapters 2, 3, and 4 expand on t">
<meta property="og:type" content="article">
<meta property="og:title" content="DPC++ Book Chap1">
<meta property="og:url" content="https://zhang-kg.github.io/2022/08/18/DPC-Book-Chap1/index.html">
<meta property="og:site_name" content="Zhang-kg">
<meta property="og:description" content="This chapter provided terminology needed for SYCL and DPC++ and provided refreshers on key aspects of parallel programming and C++ that are critical to SYCL and DPC++. Chapters 2, 3, and 4 expand on t">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-08-18T15:41:04.000Z">
<meta property="article:modified_time" content="2022-08-18T15:43:43.642Z">
<meta property="article:author" content="Zhang-kg">
<meta property="article:tag" content="PAC">
<meta property="article:tag" content="DPC++">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zhang-kg.github.io/2022/08/18/DPC-Book-Chap1/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://zhang-kg.github.io/2022/08/18/DPC-Book-Chap1/","path":"2022/08/18/DPC-Book-Chap1/","title":"DPC++ Book Chap1"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>DPC++ Book Chap1 | Zhang-kg</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Zhang-kg</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Key-attributes-of-DPC-and-SYCL"><span class="nav-number">1.</span> <span class="nav-text">Key attributes of DPC++ and SYCL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Single-Source"><span class="nav-number">1.1.</span> <span class="nav-text">Single-Source</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Host"><span class="nav-number">1.2.</span> <span class="nav-text">Host</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Devices"><span class="nav-number">1.3.</span> <span class="nav-text">Devices</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Sharing-Devices"><span class="nav-number">1.3.1.</span> <span class="nav-text">Sharing Devices</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kernel-Code"><span class="nav-number">1.4.</span> <span class="nav-text">Kernel Code</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Kernel-Vector-Addition-DAXPY"><span class="nav-number">1.4.1.</span> <span class="nav-text">Kernel: Vector Addition (DAXPY)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Asynchronous-Task-Graphs"><span class="nav-number">1.5.</span> <span class="nav-text">Asynchronous Task Graphs</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Race-Conditions-When-We-Make-a-Mistake"><span class="nav-number">1.5.1.</span> <span class="nav-text">Race Conditions When We Make a Mistake</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-Lambda-Functions"><span class="nav-number">1.6.</span> <span class="nav-text">C++ Lambda Functions</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Portability-and-Direct-Programming"><span class="nav-number">2.</span> <span class="nav-text">Portability and Direct Programming</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Concurrency-vs-Parallelism"><span class="nav-number">3.</span> <span class="nav-text">Concurrency vs. Parallelism</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%84%E5%BD%95%EF%BC%9ALambda%E5%87%BD%E6%95%B0%EF%BC%88%E6%9D%A5%E8%87%AAC-Primer-Plus%EF%BC%89"><span class="nav-number">4.</span> <span class="nav-text">附录：Lambda函数（来自C++ Primer Plus）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E3%80%81%E5%87%BD%E6%95%B0%E7%AC%A6%E5%92%8CLambda%E5%87%BD%E6%95%B0"><span class="nav-number">4.1.</span> <span class="nav-text">比较函数指针、函数符和Lambda函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8lambda"><span class="nav-number">4.2.</span> <span class="nav-text">为何使用lambda</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhang-kg"
      src="/images/%E6%AD%8C.png">
  <p class="site-author-name" itemprop="name">Zhang-kg</p>
  <div class="site-description" itemprop="description">description</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhang-kg.github.io/2022/08/18/DPC-Book-Chap1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E6%AD%8C.png">
      <meta itemprop="name" content="Zhang-kg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang-kg">
      <meta itemprop="description" content="description">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="DPC++ Book Chap1 | Zhang-kg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          DPC++ Book Chap1
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-08-18 23:41:04 / 修改时间：23:43:43" itemprop="dateCreated datePublished" datetime="2022-08-18T23:41:04+08:00">2022-08-18</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>10k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>This chapter provided terminology needed for SYCL and DPC++ and provided refreshers on key aspects of parallel programming and C++ that are critical to SYCL and DPC++. Chapters 2, 3, and 4 expand on three keys to SYCL programming: devices need to be given work to do (send code to run on them), be provided with data (send data to use on them), and have a method of writing code (kernels).</p>
<span id="more"></span>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;CL/sycl.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> sycl;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> std::string secret {</span><br><span class="line">    <span class="string">"Ifmmp-!xpsme\"\012J(n!tpssz-!Ebwf/!"</span></span><br><span class="line">    <span class="string">"J(n!bgsbje!J!dbo(u!ep!uibu/!.!IBM\01"</span>};</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> sz = secret.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    queue Q;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span>*result = <span class="built_in">malloc_shared</span>&lt;<span class="type">char</span>&gt;(sz, Q);</span><br><span class="line">    std::<span class="built_in">memcpy</span>(result,secret.<span class="built_in">data</span>(),sz);</span><br><span class="line">    </span><br><span class="line">    Q.<span class="built_in">parallel_for</span>(sz,[=](<span class="keyword">auto</span>&amp;i) {</span><br><span class="line">    	result[i] -= <span class="number">1</span>;</span><br><span class="line">    }).<span class="built_in">wait</span>();</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; result &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>queues are the only connection that allows an application to direct work to be done on a device. </p>
<p>Two types of actions that can be placed into a queue: </p>
<ul>
<li>code to execute: is expressed via either <code>single_task</code>, <code>parallel_for</code>, or <code>parallel_for_work_group</code></li>
<li>memory operations: perform copy operations between host and device or fill operations to initialize memory. We only need to use memory operations if we seek more control than what is done automatically for us.</li>
</ul>
<h2 id="Key-attributes-of-DPC-and-SYCL"><a href="#Key-attributes-of-DPC-and-SYCL" class="headerlink" title="Key attributes of DPC++ and SYCL"></a>Key attributes of DPC++ and SYCL</h2><h3 id="Single-Source"><a href="#Single-Source" class="headerlink" title="Single-Source"></a>Single-Source</h3><p>same translation unit contains both the code that defines the compute kernels to be executed on devices and also the host code that orchestrates execution of those compute kernels.</p>
<h3 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h3><p>Every program starts by running on a host, and most of the lines of the code in a program are usually for host.</p>
<p>Host have always been CPUs. The standard does not require this, so we carefully describe it as a host.</p>
<p>Host needs to fully support C++17 in order to support all DPC++ and SYCL programs. Devices do not need to support all of C++17.</p>
<h3 id="Devices"><a href="#Devices" class="headerlink" title="Devices"></a>Devices</h3><p>Using multiple devices in a program is what makes it heterogeneous programming.</p>
<p>We already learned that the collection of devices in a heterogeneous system can include GPUs, FPGAs, DSPs, ASICs, CPUs, and AI chips, but is not limited to any fixed list.</p>
<p>Devices are the target for <em>acceleration offload</em> that SYCL promises. The idea of offloading computation is generally to transfer work to a device that can accelerate completion of the work.</p>
<p>We have to worry about making up for time lost <strong>moving data</strong> — a topic that needs to constantly be on our minds.</p>
<h4 id="Sharing-Devices"><a href="#Sharing-Devices" class="headerlink" title="Sharing Devices"></a>Sharing Devices</h4><p>Supercomputers: when nodes (CPUs + all attached devices) are granted exclusively to a single application, sharing is not usually a concern.</p>
<p>Non-Supercomputers: we can just note that the performance of Data Parallel C++ program may be impacted if there are multiple applications using the same devices at the same time.</p>
<p>如果有多个应用同时使用同一个设备，可能性能会受到影响。</p>
<p>Everything still works, and there is no programing we need to do differently.</p>
<h3 id="Kernel-Code"><a href="#Kernel-Code" class="headerlink" title="Kernel Code"></a>Kernel Code</h3><p>Code for a device is specified as kernels. This is a concept that is not unique to SYCL or DPC++: it is a core concept in other offload acceleration languages including OpenCL and CUDA.</p>
<p>The list of features <em>not</em> supported in kernel code includes dynamic polymorphism, dynamic memory allocations (therefore no object management using new or delete operators), static variables, function pointers, runtime type information (RTTI), and exception handling. No virtual member functions, and no variadic functions, are allowed to be called from kernel code. Recursion is not allowed within kernel code.</p>
<p>内核代码中不支持的特性列表包括动态多态性、动态内存分配（因此不使用新的或删除操作符进行对象管理）、静态变量、函数指针、运行时类型信息(RTTI)和异常处理。不允许从内核代码中调用任何虚拟成员函数和任何变量函数。在内核代码中不允许递归。</p>
<h4 id="Kernel-Vector-Addition-DAXPY"><a href="#Kernel-Vector-Addition-DAXPY" class="headerlink" title="Kernel: Vector Addition (DAXPY)"></a>Kernel: Vector Addition (DAXPY)</h4><p>Consider implementing DAXPY, which stands for “Double-precision A times X Plus Y”. </p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">! Fortran loop</span></span><br><span class="line"><span class="keyword">do</span> i = <span class="number">1</span>, n</span><br><span class="line">	z(i) = alpha * x(i) + y(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ loop</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">    z[i] = alpha * x[i] + y[i];</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SYCL kernel</span></span><br><span class="line">myq.<span class="built_in">parallel_for</span>(<span class="built_in">range</span>(n), [=](id&lt;<span class="number">1</span>&gt; i) {</span><br><span class="line">    z[i] = alpha * x[i] + y[i];</span><br><span class="line">}).<span class="built_in">wait</span>();</span><br></pre></td></tr></table></figure>
<p><em>DAXPY computations in Fortran, C++, and SYCL</em></p>
<h3 id="Asynchronous-Task-Graphs"><a href="#Asynchronous-Task-Graphs" class="headerlink" title="Asynchronous Task Graphs"></a>Asynchronous Task Graphs</h3><p>Asynchronous programing is critical to understand for two reasons:</p>
<ul>
<li>proper use gives us better performance (better scaling)</li>
<li>mistakes lead to parallel programing errors (usually race conditions) that make our applications unreliable.</li>
</ul>
<p>The asynchronous nature comes about because work is transferred to devices via a “queue” of requested actions.</p>
<p>The host program submits a requested action into a queue, and the program continues without waiting for any results. This <strong>no waiting</strong> is important so that we can try to keep computational resources (devices and the host) busy all the time. </p>
<p>If we had to wait, that would tie up the host instead of allowing the host to do useful work. It would also create bottlenecks when the device finished, until we queued up new work.</p>
<p>We need to construct our programs to be moving data to and from devices while the devices are busy and keep all the computational power of the devices and host busy any time work is available.</p>
<h4 id="Race-Conditions-When-We-Make-a-Mistake"><a href="#Race-Conditions-When-We-Make-a-Mistake" class="headerlink" title="Race Conditions When We Make a Mistake"></a>Race Conditions When We Make a Mistake</h4><p>A race condition exists when two parts of a program access the same data without coordination. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... we are changing one line from 1-1</span></span><br><span class="line"><span class="type">char</span>* result = <span class="built_in">malloc_shared</span>&lt;<span class="type">char</span>&gt;(sz, Q);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Introduce protential data race!</span></span><br><span class="line"><span class="comment">// We don't define a dependence </span></span><br><span class="line"><span class="comment">// to ensure correct ordering with</span></span><br><span class="line"><span class="comment">// later operations.</span></span><br><span class="line">Q.<span class="built_in">memcpy</span>(result, secret.<span class="built_in">data</span>(), sz);</span><br><span class="line"></span><br><span class="line">Q.<span class="built_in">parallel_for</span>(sz, [=](<span class="keyword">auto</span>&amp;i) {</span><br><span class="line">    result[i] -= <span class="number">1</span>;</span><br><span class="line">}).<span class="built_in">wait</span>();</span><br></pre></td></tr></table></figure>
<p>1-3 <em>Adding a race condition to illustrate a point about being asynchronous</em></p>
<p>Since that is a queue submission, there is no guarantee that it will complete before line 10. This creates a race condition, which is a type of parallel programming bug.</p>
<h3 id="C-Lambda-Functions"><a href="#C-Lambda-Functions" class="headerlink" title="C++ Lambda Functions"></a>C++ Lambda Functions</h3><p>A feature of modern C++ that is heavily used by parallel programming techniques is the lambda function.</p>
<p>Kernels (the code to run on a device) can be expressed in multiple ways, the most common one being a lambda function.</p>
<p>The code in 1-3 has a lambda function. We can see it because it starts with the very definitive [=].</p>
<p>In C++, lambdas <strong>start with</strong> a square bracket, and information before the closing square bracket denotes <em>how to capture variables that are used within the lambda but not explicitly pass to it as parameters</em>. For kernels, the capture must be <em>by value</em> which is denoted by the inclusion of an equals sign within the brackets.</p>
<p>对于内核来说，捕获必须是by value，该值由方括号中包含一个等号表示。</p>
<p>The basic syntax for a C++ lambda expression is </p>
<p><code>[ capture-list ] (params) -&gt; ret { body }</code></p>
<ul>
<li><code>capture-list</code> is a comma-separated list of captures. We capture a variable by value by listing the variable name in the capture-list. We capture a variable by reference by prefixing it with a ampersand, for example &amp;v. (通过引用) There are also shorthands that apply to all in-scope automatic variables (有一些适用于所有范围内自动变量的简称): <ul>
<li>[=] is used to capture all automatic variables used in the body by value and the current object by reference</li>
<li>[&amp;] is used to capture all automatic variables used in the body as well as the current object by reference</li>
<li>[] captures nothing</li>
<li>SYCL中几乎都是用[=]，因为不允许通过引用捕获任何变量以在内核中使用。根据C++标准，全局变量不会在lambda中被捕获。Non-global static variables can be used in a kernel but only if they are <code>const</code>.</li>
</ul>
</li>
<li><code>params</code> is the list of function parameters, just like for a named functions.</li>
<li><code>ret</code> is the return type. If <code>-&gt; ret</code> is not specified, it is inferred from the return statements.</li>
<li><code>body</code> is the function body. For a SYCL kernel, the contents of this kernel have some restrictions (“Kernel Code” section)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">10</span>, k = <span class="number">100</span>, l = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> lambda = [i, &amp;j](<span class="type">int</span> k0, <span class="type">int</span> &amp; l0) -&gt; <span class="type">int</span> {</span><br><span class="line">    j = <span class="number">2</span> * j;</span><br><span class="line">    k0 = <span class="number">2</span> * k0;</span><br><span class="line">    l0 = <span class="number">2</span> * l0;</span><br><span class="line">    <span class="keyword">return</span> i + j + k0 + l0;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="built_in">print_values</span>(i, j, k, l);</span><br><span class="line">std::cout &lt;&lt; <span class="string">"First call returned "</span> &lt;&lt; <span class="built_in">lambda</span>(k, l) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"><span class="built_in">print_values</span>(i, j, k, l);</span><br><span class="line">std::cout &lt;&lt; <span class="string">"Second call returned "</span> &lt;&lt; <span class="built_in">lambda</span>(k, l) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"><span class="built_in">print_values</span>(i, j, k, l);</span><br></pre></td></tr></table></figure>
<p>Wherever we use a C++ lambda expression, we can substitute it with an instance of a function object like the one shown in 1-6.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1-6 Function object instead of a lambda</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Functor</span> {</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">Functor</span>(<span class="type">int</span> i, <span class="type">int</span> &amp; j): my_i{i}, my_jRef{j} {}</span><br><span class="line">    	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> k0, <span class="type">int</span> &amp; l0)</span> </span>{</span><br><span class="line">            my_jRef = <span class="number">2</span> * my_jRef;</span><br><span class="line">            k0 = <span class="number">2</span> * k0;</span><br><span class="line">            l0 = <span class="number">2</span> * l0;</span><br><span class="line">            <span class="keyword">return</span> my_i + my_jRef + k0 + l0;</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="type">int</span> my_i;</span><br><span class="line">    	<span class="type">int</span> &amp; my_jRef;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h2 id="Portability-and-Direct-Programming"><a href="#Portability-and-Direct-Programming" class="headerlink" title="Portability and Direct Programming"></a>Portability and Direct Programming</h2><p>Portability is a complex topic and includes the concept of <em>functional portability</em> as well as <em>performance portability</em>.</p>
<ul>
<li>functional portability: our program to compile and run equivalently on a wide variety of platforms.</li>
<li>performance portability: our program to get reasonable performance on a wide variety of platforms.</li>
</ul>
<p>SYCL defines a way to code that can improve performance portability.</p>
<ul>
<li>a generic kernel can run everywhere</li>
<li>More commonly, several versions of important kernels may be written for different types of devices</li>
</ul>
<h2 id="Concurrency-vs-Parallelism"><a href="#Concurrency-vs-Parallelism" class="headerlink" title="Concurrency vs. Parallelism"></a>Concurrency vs. Parallelism</h2><p><strong>并发 vs. 并行</strong></p>
<p>解释了并发和并行的概念。</p>
<h2 id="附录：Lambda函数（来自C-Primer-Plus）"><a href="#附录：Lambda函数（来自C-Primer-Plus）" class="headerlink" title="附录：Lambda函数（来自C++ Primer Plus）"></a>附录：Lambda函数（来自C++ Primer Plus）</h2><p>Lambda函数实例：</p>
<p><code>[&amp;count] (int x) {count += (x % 13 == 0);}</code></p>
<h3 id="比较函数指针、函数符和Lambda函数"><a href="#比较函数指针、函数符和Lambda函数" class="headerlink" title="比较函数指针、函数符和Lambda函数"></a>比较函数指针、函数符和Lambda函数</h3><p>一个示例，使用三种方法给STL算法传递信息：函数指针、函数符和Lambda。将三种形式通称为函数对象。假设生成一个随机整数列表，并判断其中多少个整数可以被3整除，说少个整数可被13整除。</p>
<p>生成这样的列表一种方案是使用 <code>vector&lt;int&gt;</code> 存储数字，并且使用STL算法 <code>generate()</code> 在其中填充随机数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">numbers</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">std::<span class="built_in">generate</span>(vector.<span class="built_in">begin</span>(), vector.<span class="built_in">end</span>(), std::rand);</span><br></pre></td></tr></table></figure>
<p><code>generate()</code> 接受一个区间（前两个参数指定），每个元素设置为第三个参数返回的值，第三个参数是一个不接受任何参数的函数对象。</p>
<p>通过算法 <code>count_if()</code>，很容易计算有多少个元素可被3整除</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">f3</span><span class="params">(<span class="type">int</span> x)</span> </span>{<span class="keyword">return</span> x % <span class="number">3</span> == <span class="number">0</span>;}</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">f13</span><span class="params">(<span class="type">int</span> x)</span> </span>{<span class="keyword">return</span> x % <span class="number">13</span> == <span class="number">0</span>;}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count3 = std::<span class="built_in">count_if</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), f3);</span><br><span class="line">cout &lt;&lt; <span class="string">"Count of numbers divisible by 3:"</span> &lt;&lt; count3 &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"><span class="type">int</span> count13 = std::<span class="built_in">count_if</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), f13);</span><br><span class="line">cout &lt;&lt; <span class="string">"Count of numbers divisible by 13: "</span> &lt;&lt; count13 &lt;&lt; <span class="string">"\n"</span>;</span><br></pre></td></tr></table></figure>
<p><strong>用函数符来完成这个任务：</strong>函数符是一个类对象，并非只能像函数名那样使用它，归功于类方法 operator()()。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">f_mod</span> {</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="type">int</span> dv;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">f_mod</span>(<span class="type">int</span> d = <span class="number">1</span>): <span class="built_in">dv</span>(d) {}</span><br><span class="line">    	<span class="function">boop <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> x)</span> </span>{<span class="keyword">return</span> x % dv == <span class="number">0</span>;}</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<p>可以使用构造函数创建存储指定整数值的 f_mod 对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">f_mod <span class="title">obj</span><span class="params">(<span class="number">3</span>)</span></span>; <span class="comment">// f_mod.dv set to 3</span></span><br></pre></td></tr></table></figure>
<p>可以使用operator返回一个bool值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> is_div_by_3 = <span class="built_in">obj</span>(<span class="number">7</span>); <span class="comment">// same as obj.opreator()(7)</span></span><br></pre></td></tr></table></figure>
<p>构造函数本身可以用作诸如count_if等函数的参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count3 = std::<span class="built_in">count_if</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="built_in">f_mod</span>(<span class="number">3</span>));</span><br></pre></td></tr></table></figure>
<p>count_if() 会调用 f_mod(3) 的 operator()() 函数。</p>
<p><strong>使用Lambda：</strong>可以使用匿名函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="type">int</span> x) {<span class="keyword">return</span> x % <span class="number">3</span> == <span class="number">0</span>;}</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 [] 代替了函数名</li>
<li>没有声明返回类型</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count3 = std::<span class="built_in">count_if</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [](<span class="type">int</span> x){<span class="keyword">return</span> x % <span class="number">3</span> == <span class="number">0</span>;});</span><br></pre></td></tr></table></figure>
<p>仅当lambda表达式完全由一条返回语句组成时，自动类型推断才管用，否则需要使用新增的返回后置语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="type">double</span> x) -&gt; <span class="type">double</span>{<span class="type">int</span> y = x; <span class="keyword">return</span> x - y;}</span><br></pre></td></tr></table></figure>
<h3 id="为何使用lambda"><a href="#为何使用lambda" class="headerlink" title="为何使用lambda"></a>为何使用lambda</h3><p>可以给lambda指定一个名称，并且使用这个名称多次：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> mod3 = [](<span class="type">int</span> x){<span class="keyword">return</span> x % <span class="number">3</span> == <span class="number">0</span>;}</span><br><span class="line">count1 = std::<span class="built_in">count_if</span>(n1.<span class="built_in">begin</span>(), n1.<span class="built_in">end</span>(), mod3);</span><br><span class="line">count2 = std::<span class="built_in">count_if</span>(n2.<span class="built_in">begin</span>(), n2.<span class="built_in">end</span>(), mod3);</span><br><span class="line"><span class="type">bool</span> result = <span class="built_in">mod3</span>(z); <span class="comment">// result is true if z % 3 == 0</span></span><br></pre></td></tr></table></figure>
<p>lambda 具有一些额外功能。它可以访问作用域内的任何动态变量；要捕获要使用的变量，可将其名称放在中括号内。如果指定了变量名，如[z]，将按值访问变量；如果在名称前面加上&amp;，将按引用访问变量。[&amp;]能够按引用访问所有动态变量，而[=]能够按值访问所有动态变量。还可以混合使用这两种方法，例如[ted, &amp;ed]能够按值访问ted以及按引用访问ed，[&amp;, ted]能够按值访问ted以及按引用访问其他所有动态变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count13 = <span class="number">0</span>;</span><br><span class="line">std::for_each(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [&amp;count](<span class="type">int</span> x){count13 += x % <span class="number">13</span> == <span class="number">0</span>;});</span><br></pre></td></tr></table></figure>
<p>[&amp;count13]让lambda函数在代码中使用count13，由于使用引用，所以对于count13的修改都会影响原始的count13。同样，函数可以这样改写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count3 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> count13 = <span class="number">0</span>;</span><br><span class="line">std::for_each(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [&amp;](<span class="type">int</span> x){count3 += x % <span class="number">3</span> == <span class="number">0</span>; count13 += x % <span class="number">13</span> == <span class="number">0</span>;});</span><br></pre></td></tr></table></figure>
<p>[&amp;] 能够用引用访问内部所有自动变量。所以可以修改两个值。</p>

    </div>

    
    
    

    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
      
    </div>

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Zhang-kg
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://zhang-kg.github.io/2022/08/18/DPC-Book-Chap1/" title="DPC++ Book Chap1">https://zhang-kg.github.io/2022/08/18/DPC-Book-Chap1/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/PAC/" rel="tag"># PAC</a>
              <a href="/tags/DPC/" rel="tag"># DPC++</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/06/09/BUAA-OS-Lab5-2-Extra/" rel="prev" title="BUAA_OS Lab5-2-Extra">
                  <i class="fa fa-chevron-left"></i> BUAA_OS Lab5-2-Extra
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/08/20/DPC-Book-Chap2/" rel="next" title="DPC Book Chap2">
                  DPC Book Chap2 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang-kg</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">98k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:29</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"mhchem":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
