<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zhang-kg.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Data ManagementTow ways to manage data: Unified Shared Memory (USM) and buffers. USM is pointer based, which is familiar to C++ programmers. Buffers offer a higher-level abstraction.  IntroductionIn t">
<meta property="og:type" content="article">
<meta property="og:title" content="DPC Book Chap3">
<meta property="og:url" content="https://zhang-kg.github.io/2022/08/24/DPC-Book-Chap3/index.html">
<meta property="og:site_name" content="Zhang-kg">
<meta property="og:description" content="Data ManagementTow ways to manage data: Unified Shared Memory (USM) and buffers. USM is pointer based, which is familiar to C++ programmers. Buffers offer a higher-level abstraction.  IntroductionIn t">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/img/image-20220823213324729.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/img/image-20220823224515036.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/img/image-20220824085237982.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/img/image-20220824101421642.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/img/image-20220824102622242.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/img/image-20220824110107133.png">
<meta property="article:published_time" content="2022-08-24T03:12:59.000Z">
<meta property="article:modified_time" content="2022-08-24T03:14:40.200Z">
<meta property="article:author" content="Zhang-kg">
<meta property="article:tag" content="PAC">
<meta property="article:tag" content="DPC++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/img/image-20220823213324729.png">


<link rel="canonical" href="https://zhang-kg.github.io/2022/08/24/DPC-Book-Chap3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://zhang-kg.github.io/2022/08/24/DPC-Book-Chap3/","path":"2022/08/24/DPC-Book-Chap3/","title":"DPC Book Chap3"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>DPC Book Chap3 | Zhang-kg</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Zhang-kg</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Data-Management"><span class="nav-number">1.</span> <span class="nav-text">Data Management</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Introduction"><span class="nav-number">1.1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Data-Management-Problem"><span class="nav-number">1.2.</span> <span class="nav-text">The Data Management Problem</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Device-Local-vs-Device-Remote"><span class="nav-number">1.3.</span> <span class="nav-text">Device Local vs. Device Remote</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Managing-Multiple-Memories"><span class="nav-number">1.4.</span> <span class="nav-text">Managing Multiple Memories</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Explicit-Data-Movement"><span class="nav-number">1.4.1.</span> <span class="nav-text">Explicit Data Movement</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Implicit-Data-Movement"><span class="nav-number">1.4.2.</span> <span class="nav-text">Implicit Data Movement</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Selecting-the-Right-Strategy"><span class="nav-number">1.4.3.</span> <span class="nav-text">Selecting the Right Strategy</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#USM-Buffers-and-Images"><span class="nav-number">1.5.</span> <span class="nav-text">USM, Buffers, and Images</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unified-Shared-Memory"><span class="nav-number">1.6.</span> <span class="nav-text">Unified Shared Memory</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Accessing-Memory-Through-Pointers"><span class="nav-number">1.6.1.</span> <span class="nav-text">Accessing Memory Through Pointers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#USM-and-Data-Movement"><span class="nav-number">1.6.2.</span> <span class="nav-text">USM and Data Movement</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Explicit-Data-Movement-in-USM"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">Explicit Data Movement in USM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Implicit-Data-Movement-in-USM"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">Implicit Data Movement in USM</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Buffers"><span class="nav-number">1.7.</span> <span class="nav-text">Buffers</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Creating-Buffers"><span class="nav-number">1.7.1.</span> <span class="nav-text">Creating Buffers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Accessing-Buffers"><span class="nav-number">1.7.2.</span> <span class="nav-text">Accessing Buffers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Access-Modes"><span class="nav-number">1.7.3.</span> <span class="nav-text">Access Modes</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ordering-the-Uses-of-Data"><span class="nav-number">1.8.</span> <span class="nav-text">Ordering the Uses of Data</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#In-order-Queues"><span class="nav-number">1.8.1.</span> <span class="nav-text">In-order Queues</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Out-of-Order-OoO-Queues"><span class="nav-number">1.8.2.</span> <span class="nav-text">Out-of-Order (OoO) Queues</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Explicit-Dependences-with-Events"><span class="nav-number">1.8.3.</span> <span class="nav-text">Explicit Dependences with Events</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Implicit-Dependences-with-Accessors"><span class="nav-number">1.8.4.</span> <span class="nav-text">Implicit Dependences with Accessors</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Handler-Class"><span class="nav-number">1.9.</span> <span class="nav-text">Handler Class</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhang-kg"
      src="/images/%E6%AD%8C.png">
  <p class="site-author-name" itemprop="name">Zhang-kg</p>
  <div class="site-description" itemprop="description">description</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhang-kg.github.io/2022/08/24/DPC-Book-Chap3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E6%AD%8C.png">
      <meta itemprop="name" content="Zhang-kg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang-kg">
      <meta itemprop="description" content="description">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="DPC Book Chap3 | Zhang-kg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          DPC Book Chap3
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-08-24 11:12:59 / 修改时间：11:14:40" itemprop="dateCreated datePublished" datetime="2022-08-24T11:12:59+08:00">2022-08-24</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="Data-Management"><a href="#Data-Management" class="headerlink" title="Data Management"></a>Data Management</h1><p>Tow ways to manage data: Unified Shared Memory (USM) and buffers. USM is pointer based, which is familiar to C++ programmers. Buffers offer a higher-level abstraction. </p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In traditional single-socket CPU-based systems, we have a single memory. Accelerator devices often have their own attached memories that cannot be directly accessed from the host.</p>
<span id="more"></span>
<h2 id="The-Data-Management-Problem"><a href="#The-Data-Management-Problem" class="headerlink" title="The Data Management Problem"></a>The Data Management Problem</h2><p>历史上，并行编程的共享内存模型的优点之一是它们提供了一个单一的、共享的内存视图。</p>
<p>许多离散的加速器都有自己的独立于CPU的本地内存</p>
<p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/img/image-20220823213324729.png" alt="image-20220823213324729"></p>
<h2 id="Device-Local-vs-Device-Remote"><a href="#Device-Local-vs-Device-Remote" class="headerlink" title="Device Local vs. Device Remote"></a>Device Local vs. Device Remote</h2><p>将直接附加的内存访问称为本地访问 local accesses</p>
<p>将对其他设备内存的访问称为远程访问 remote accesses</p>
<p>本地访问不需要经过更低的设备带宽和更高的延迟，所以本地访问比远程访问好。因此我们需要数据在不同的内存之间迁移保证将其移动到更接近计算的位置。</p>
<h2 id="Managing-Multiple-Memories"><a href="#Managing-Multiple-Memories" class="headerlink" title="Managing Multiple Memories"></a>Managing Multiple Memories</h2><p>两种方式管理内存：</p>
<ul>
<li>explicitly through our program</li>
<li>implicitly by the runtime</li>
</ul>
<h3 id="Explicit-Data-Movement"><a href="#Explicit-Data-Movement" class="headerlink" title="Explicit Data Movement"></a>Explicit Data Movement</h3><p>在包含加速器的系统中，我们要先将数据复制到GPU内存中，然后加速器才能计算，之后需要将计算结果复制回CPU，主机程序才能使用它</p>
<p>优点：我们显示控制数据何时移动；</p>
<p>缺点：指定所有数据移动可能出错</p>
<h3 id="Implicit-Data-Movement"><a href="#Implicit-Data-Movement" class="headerlink" title="Implicit Data Movement"></a>Implicit Data Movement</h3><p>通过 parallel runtime 或者 driver 控制的数据移动。</p>
<p>优点：it requires less effort to get an application to take advantage of faster memory attached directly to the device.</p>
<p>缺点：性能有影响</p>
<h3 id="Selecting-the-Right-Strategy"><a href="#Selecting-the-Right-Strategy" class="headerlink" title="Selecting the Right Strategy"></a>Selecting the Right Strategy</h3><p><em>大概意思是：</em>可以考虑混合使用，如果开发程序，先用自动方式；后期调整性能的时候换成手动方式</p>
<h2 id="USM-Buffers-and-Images"><a href="#USM-Buffers-and-Images" class="headerlink" title="USM, Buffers, and Images"></a>USM, Buffers, and Images</h2><p>There are three abstractions for managing memory: Unified Shared Memory (USM), buffers, and images.</p>
<p>USM是一种基于指针的方法，易于和现有的在指针操作上的C++代码集成。Buffers 是由 <code>buffer</code> 基类实现的，可以描述一维、二维、三维数组。他们提供了一个可以在主机或者设备上访问的内存抽象实体。Buffer不能通过程序直接访问，需要通过 <code>accessor</code> 对象来访问；Image是一种特殊类型的缓冲区，它提供了特定于图像处理的额外功能。支持特殊的图像格式、使用 <code>sampler</code> 对象读取图像。</p>
<h2 id="Unified-Shared-Memory"><a href="#Unified-Shared-Memory" class="headerlink" title="Unified Shared Memory"></a>Unified Shared Memory</h2><p>基于指针，对使用 <code>malloc</code> 和 <code>new</code> 来分配空间的 C 或者 C++ 程序员很熟悉。USM simplifies life when porting existin C/C++ code that makes heavy use of pointers. 支持USM的设备支持统一的虚拟地址空间。拥有一个统一的虚拟地址空间意味着在主机上使用USM分配空间返回的指针可以在设备上都能使用。</p>
<h3 id="Accessing-Memory-Through-Pointers"><a href="#Accessing-Memory-Through-Pointers" class="headerlink" title="Accessing Memory Through Pointers"></a>Accessing Memory Through Pointers</h3><p>当一个系统同时包含主机内存和与设备连接的本地内存时，这些内存并不是相等的。USM中定义了三种不同类型的内存分配：<code>device</code> <code>host</code> and <code>shared</code>。三种类型的分配都要在主机端上执行</p>
<p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/img/image-20220823224515036.png" alt="image-20220823224515036"></p>
<p>使用device分配的内存不能在主机端上访问。必须使用显示内存的拷贝操作。</p>
<p>使用host分配的内存在主机端和设备端都能访问。相同指针值在主机代码和设备内核中都有效。如果在设备中访问数据，则数据不会从主机端迁移到设备的本地内存，而是通过总线访问。</p>
<p>在主机和设备之间都能访问shared分配的内存。并且数据可以在主机端和设备端进行迁移。迁移之后，设备的访存会更快。</p>
<h3 id="USM-and-Data-Movement"><a href="#USM-and-Data-Movement" class="headerlink" title="USM and Data Movement"></a>USM and Data Movement</h3><p>USM同时支持显式和隐式的数据移动策略，并且不同的分配类型映射到不同的策略。如果是Device分配，则要求我们在主机和设备之间显式的移动设备；而host和shared分配提供了隐式数据移动。</p>
<h4 id="Explicit-Data-Movement-in-USM"><a href="#Explicit-Data-Movement-in-USM" class="headerlink" title="Explicit Data Movement in USM"></a>Explicit Data Movement in USM</h4><p>USM中通过Device分配的内存进行显示内存移动是通过在 <code>queue</code> 和 <code>handler</code> 类中的特殊的 <code>memcpy()</code> 完成的。通过将 <code>memcpy()</code> 入队来将数据从设备中复制到主机端或者从主机端复制到设备端。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;CL/sycl.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> sycl;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue Q;</span><br><span class="line">    </span><br><span class="line">    std::array&lt;<span class="type">int</span>, N&gt; host_array;</span><br><span class="line">    <span class="type">int</span>* device_array = <span class="built_in">malloc_device</span>&lt;<span class="type">int</span>&gt;(N, Q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) </span><br><span class="line">        host_array[i] = N;</span><br><span class="line">   	</span><br><span class="line">    <span class="comment">// We will learn how to simplify this example later</span></span><br><span class="line">    Q.<span class="built_in">submit</span>([&amp;](handler &amp; h) &#123;</span><br><span class="line">        <span class="comment">// copy hostArray to deviceArray</span></span><br><span class="line">        h.<span class="built_in">memcpy</span>(device_array, &amp;host_array[<span class="number">0</span>], N * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">    Q.<span class="built_in">wait</span>();</span><br><span class="line">    </span><br><span class="line">    Q.<span class="built_in">submit</span>([&amp;](handler &amp;h) &#123;</span><br><span class="line">        h.<span class="built_in">parallel_for</span>(N, [=](id&lt;<span class="number">1</span>&gt; i) &#123;device_array[i]++;&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    Q.<span class="built_in">wait</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(device_array, Q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Figure 3-4.</strong> <em>USM explicit data movement</em></p>
<h4 id="Implicit-Data-Movement-in-USM"><a href="#Implicit-Data-Movement-in-USM" class="headerlink" title="Implicit Data Movement in USM"></a>Implicit Data Movement in USM</h4><p>USM 中的隐式数据移动是在 <code>host</code> 和 <code>shared</code> 中完成的。在这两种分配方式下，我们不需要编写数据移动的代码，只需要访问内核中的指针，就可以访问任何内存。简化了代码的移植：仅仅替换原有的malloc为新的对应的内存分配代码即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;CL/sycl.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> sycl;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue Q;</span><br><span class="line">    <span class="type">int</span>* host_array = <span class="built_in">malloc_host</span>&lt;<span class="type">int</span>&gt;(N, Q);</span><br><span class="line">    <span class="type">int</span>* shared_array = <span class="built_in">malloc_shared</span>&lt;<span class="type">int</span>&gt;(N, Q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="comment">// Initialize hostArray on host</span></span><br><span class="line">        host_array[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Q.<span class="built_in">submit</span>([&amp;](handler &amp;h) &#123;</span><br><span class="line">        h.<span class="built_in">parallel_for</span>(N, [=](id&lt;<span class="number">1</span>&gt; i) &#123;</span><br><span class="line">            shared_array[i] = host_array[i] + <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    Q.<span class="built_in">wait</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        host_array[i] = shared_array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(shared_array);</span><br><span class="line">    <span class="built_in">free</span>(host_array);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Figure 3-5.</strong> <em>USM implicit data movement</em></p>
<h2 id="Buffers"><a href="#Buffers" class="headerlink" title="Buffers"></a>Buffers</h2><p>Buffers 表示给定的C++类型的一个或多个对象的数据抽象。缓冲区的数据类型可以是标量数据类型（int, float, double）、向量数据类型（Chap11）或者用户自定义的类或者结构。而且必须是简单可复制的，意味着可以逐字节安全地复制对象，而不用调用复制函数。</p>
<p>Buffers 代表数据对象，而不是特定的内存地址，不能像C++数组那样直接访问。而且由于性能原因，Buffers可能映射到多个不同设备或者同一个设备的不同内存位置。需要使用 <code>accessor</code> 对象来读写buffer</p>
<h3 id="Creating-Buffers"><a href="#Creating-Buffers" class="headerlink" title="Creating Buffers"></a>Creating Buffers</h3><p>创建缓存区的方式，最简单的是构造一个具有指定缓冲区大小的范围的新缓冲区。（不会初始化数据）</p>
<p>可以从主机上现有的数据创建缓冲区，通过调用构造器来实现。这些构造函数可以获取指向现有的主机分配的指针（a set of <code>InputIterator</code>）或者具有某些属性的容器。如果使用与OpenCL的SYCL互操作性特征，也可以从现有的 <code>cl_mem</code> 对象中创建 Buffers</p>
<h3 id="Accessing-Buffers"><a href="#Accessing-Buffers" class="headerlink" title="Accessing Buffers"></a>Accessing Buffers</h3><p>主机和设备不能直接访问缓冲区，必须使用 <code>accessor</code> 来读写缓冲区。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;CL/sycl.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> sycl;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, N&gt; my_data;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        my_data[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queue q;</span><br><span class="line">    <span class="function">buffer <span class="title">my_buffer</span><span class="params">(my_data)</span></span>;</span><br><span class="line">    </span><br><span class="line">    q.<span class="built_in">submit</span>([&amp;](handler&amp; h) &#123;</span><br><span class="line">        <span class="comment">// create an accessor to update</span></span><br><span class="line">        <span class="comment">// the buffer on the device</span></span><br><span class="line">        accessor <span class="built_in">my_accessor</span>(my_buffer, h);</span><br><span class="line">        h.<span class="built_in">parallel_for</span>(N, [=](id&lt;<span class="number">1</span>&gt; i) &#123;</span><br><span class="line">            my_accessor[i] ++;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">	<span class="comment">// create host accessor</span></span><br><span class="line">    <span class="function">host_accessor <span class="title">host_accessor</span><span class="params">(my_buffer)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="comment">// access myBuffer on host</span></span><br><span class="line">        std::cout &lt;&lt; host_accessor[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Figure 3-6.</strong> <em>Buffers and accessors</em></p>
<p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/img/image-20220824085237982.png" alt="image-20220824085237982"></p>
<h3 id="Access-Modes"><a href="#Access-Modes" class="headerlink" title="Access Modes"></a>Access Modes</h3><p>创建 accessors 的时候，可以指定它的访问模式，访问模式是一个枚举类型，定义在 <code>access::mode</code> 中。默认的访问模式是 <code>access::mode::read_write</code>。根据需要指定访问模式也许有助于runtime进行优化，如果指定 <code>access::mode::read</code> 则表示在内核可以快开始执行之前，数据需要在设备上可访问。如果设备的执行不需要对数据进行写，则不需要将数据从设备上再复制会主机，因为设备上没有操作数据。如果是<code>write</code>，则需要复制回来。</p>
<h2 id="Ordering-the-Uses-of-Data"><a href="#Ordering-the-Uses-of-Data" class="headerlink" title="Ordering the Uses of Data"></a>Ordering the Uses of Data</h2><p>Kernels在被提交时可以被视为异步任务，并且需要被提交到queue中。许多情况下，kernels必须根据特定顺序执行，以便得出正确的计算结果。</p>
<p>Kernels不是需要调度的唯一形式，数据的转移也需要调度。我们把任务和依赖关系建立一张有向无环图，节点是任务，边是依赖关系。</p>
<p>There are two different ways to model the execution of tasks, such as a launch of a kernel, in a queue: the queue could either execute tasks in the order of submission, or it could execute tasks in any order subject to any dependences that we define. There are several mechanisms for us to define the dependences needed for correct ordering.</p>
<h3 id="In-order-Queues"><a href="#In-order-Queues" class="headerlink" title="In-order Queues"></a>In-order Queues</h3><p>可以将任务提交到顺序队列对象中。有序队列的直观任务排列很简单，但是，即使独立任务之间不存在依赖关系，任务的执行也需要序列化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;CL/sycl.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> sycl;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue Q&#123;property::queue::<span class="built_in">in_order</span>()&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Task A</span></span><br><span class="line">    Q.<span class="built_in">submit</span>([&amp;](handler&amp; h) &#123;</span><br><span class="line">        h.<span class="built_in">parallel_for</span>(N, [=](id&lt;<span class="number">1</span>&gt; i) &#123;<span class="comment">/*...*/</span>&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Task B</span></span><br><span class="line">    Q.<span class="built_in">submit</span>([&amp;](handler&amp; h) &#123;</span><br><span class="line">        h.<span class="built_in">parallel_for</span>(N, [=](id&lt;<span class="number">1</span>&gt; i) &#123;<span class="comment">/*...*/</span>&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Task C</span></span><br><span class="line">    Q.<span class="built_in">submit</span>([&amp;](handler&amp; h) &#123;</span><br><span class="line">        h.<span class="built_in">parallel_for</span>(N, [=](id&lt;<span class="number">1</span>&gt; i) &#123;<span class="comment">/*...*/</span>&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Figure 3-10.</strong> <em>In-order queue usage</em></p>
<h3 id="Out-of-Order-OoO-Queues"><a href="#Out-of-Order-OoO-Queues" class="headerlink" title="Out-of-Order (OoO) Queues"></a>Out-of-Order (OoO) Queues</h3><p>只要不是通过 <code>in-order</code> 属性创建的队列都属于无序队列，对于提交给它们的任务，必须要进行排序。可以使用 command groups 来显式或者隐式的指定这些依赖关系。</p>
<p>command groups 是一个指定任务及任务之间的依赖的对象。Command groups 通常写成 C++ lambdas 并且作为参数传递给 <code>submit()</code> 函数中提交给队列对象。这个lambda的唯一参数是 <code>handler</code> 对象的引用。这个 <code>handler</code> 在 command group 中指定操作、创建访问器和指定任务之间的依赖。</p>
<h3 id="Explicit-Dependences-with-Events"><a href="#Explicit-Dependences-with-Events" class="headerlink" title="Explicit Dependences with Events"></a>Explicit Dependences with Events</h3><p>首先，可以通过显式调用一个事件的 <code>wait()</code> 方法通过主机进行同步。但是 <code>wait()</code> 可能会过度限制任务的异步执行，因为它会停止host thread所有的执行。</p>
<p>也可以在队列对象上调用 <code>wait()</code>，这会阻止主机上的执行任务，直到queue中的任务完成。</p>
<p>第二种方式：<code>handler</code> 类中包含了一个名叫 <code>depends_on()</code> 的方法。这个方法接受单个 <code>event</code> 或者 event的向量组，如下是一个示例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;CL/sycl.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> sycl;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue Q;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Task A</span></span><br><span class="line">    suto eA = Q.<span class="built_in">submit</span>([&amp;](handler&amp; h) &#123;</span><br><span class="line">        h.<span class="built_in">parallel_for</span>(N, [=](id&lt;<span class="number">1</span>&gt; i) &#123;<span class="comment">/*...*/</span>&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    ea.<span class="built_in">wait</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Task B</span></span><br><span class="line">    suto eB = Q.<span class="built_in">submit</span>([&amp;](handler&amp; h) &#123;</span><br><span class="line">        h.<span class="built_in">parallel_for</span>(N, [=](id&lt;<span class="number">1</span>&gt; i) &#123;<span class="comment">/*...*/</span>&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Task C</span></span><br><span class="line">    suto eC = Q.<span class="built_in">submit</span>([&amp;](handler&amp; h) &#123;</span><br><span class="line">        h.<span class="built_in">depends_on</span>(eB);</span><br><span class="line">        h.<span class="built_in">parallel_for</span>(N, [=](id&lt;<span class="number">1</span>&gt; i) &#123;<span class="comment">/*...*/</span>&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Task A</span></span><br><span class="line">    suto eD = Q.<span class="built_in">submit</span>([&amp;](handler&amp; h) &#123;</span><br><span class="line">        h.<span class="built_in">depends_on</span>(&#123;eB, eC&#125;);</span><br><span class="line">        h.<span class="built_in">parallel_for</span>(N, [=](id&lt;<span class="number">1</span>&gt; i) &#123;<span class="comment">/*...*/</span>&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Implicit-Dependences-with-Accessors"><a href="#Implicit-Dependences-with-Accessors" class="headerlink" title="Implicit Dependences with Accessors"></a>Implicit Dependences with Accessors</h3><p>隐式的依赖关系由数据依赖关系创建。任务之间的数据依赖关系由如下：</p>
<p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/img/image-20220824101421642.png" alt="image-20220824101421642"></p>
<p>有两种方式将数据依赖性表达给runtime，accessors和程序顺序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;CL/sycl.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> sycl;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, N&gt; a, b, c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        a[i] = b[i] = c[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    queue Q;</span><br><span class="line">    buffer A&#123;a&#125;;</span><br><span class="line">    buffer B&#123;b&#125;;</span><br><span class="line">    buffer C&#123;c&#125;;</span><br><span class="line">    Q.<span class="built_in">submit</span>([&amp;](handler&amp; h) &#123;</span><br><span class="line">        accessor <span class="built_in">accA</span>(A, h, read_only);</span><br><span class="line">        accessor <span class="built_in">accB</span>(B, h, write_only);</span><br><span class="line">        h.<span class="built_in">parallel_for</span>(	<span class="comment">// compute B</span></span><br><span class="line">        	N,</span><br><span class="line">        	[=](id&lt;<span class="number">1</span>&gt; i) &#123;accB[i] = accA[i] + <span class="number">1</span>;&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    Q.<span class="built_in">submit</span>([&amp;](handler&amp; h) &#123;</span><br><span class="line">        accessor <span class="built_in">accA</span>(A, h, read_only);</span><br><span class="line">        h.<span class="built_in">parallel_for</span>(	<span class="comment">// readA</span></span><br><span class="line">        	N,</span><br><span class="line">        	[=](id&lt;<span class="number">1</span>&gt; i) &#123;</span><br><span class="line">                <span class="comment">//Useful only as example</span></span><br><span class="line">                <span class="type">int</span> data = accA[i];</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    Q.<span class="built_in">submit</span>([&amp;](handler&amp; h) &#123;</span><br><span class="line">        <span class="comment">// RAW of buffer B</span></span><br><span class="line">        accessor <span class="built_in">accB</span>(B, h, read_only);</span><br><span class="line">        accessor <span class="built_in">accC</span>(C, h, write_only);</span><br><span class="line">        h.<span class="built_in">parallel_for</span>( <span class="comment">// computeC</span></span><br><span class="line">			N,</span><br><span class="line">			[=](id&lt;<span class="number">1</span>&gt; i) &#123; accC[i] = accB[i] + <span class="number">2</span>; &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// read C on host</span></span><br><span class="line">    <span class="function">host_accessor <span class="title">host_accC</span><span class="params">(C, read_only)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    	std::cout &lt;&lt; host_accC[i] &lt;&lt; <span class="string">&quot; &quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Figure 3-13.</strong> <em>Read-after-Write</em></p>
<p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/img/image-20220824102622242.png" alt="image-20220824102622242"></p>
<p>运行时computeB需要使用A的信息，并将其写入B中；readA中同样需要使用A的信息，并且也构造了 <code>read_only</code> 的访问器。在执行时，readA可能先执行，或者同时执行两者。</p>
<p>两个操作都需要 buffer A 被复制到设备上，但是kernel computeB 也需要bufferB被复制以防其他数据被computeB修改。这意味着runtime可能执行readA的同时进行bufferB的数据转化；也说明了，即使内核只会写入buffer，buffer中的原始内容也可能被复制到其他设备中，因为没有保证所有的值会被kernel写。</p>
<p>由于computeC在computeB之后提交，所以这两个任务之间具有RAW的关系。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;CL/sycl.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;array&gt;</span></span></span><br><span class="line">uising <span class="keyword">namespace</span> sycl;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, N&gt; a, b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        a[i] = b[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    queue Q;</span><br><span class="line">    buffer A&#123;a&#125;;</span><br><span class="line">    buffer B&#123;b&#125;;</span><br><span class="line">    Q.<span class="built_in">submit</span>([&amp;](handler &amp;h) &#123;</span><br><span class="line">        accessor <span class="built_in">accA</span>(A, h, read_only);</span><br><span class="line">        accessor <span class="built_in">accB</span>(B, h, write_only);</span><br><span class="line">        h.<span class="built_in">parallel_for</span>( <span class="comment">// computeB</span></span><br><span class="line">            N, [=](id&lt;<span class="number">1</span>&gt; i) &#123;</span><br><span class="line">            accB[i] = accA[i] + <span class="number">1</span>;</span><br><span class="line">        	&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    Q.<span class="built_in">submit</span>([&amp;](handler &amp;h) &#123;</span><br><span class="line">        <span class="comment">// WAR of buffer A</span></span><br><span class="line">        accessor <span class="built_in">accA</span>(A, h, write_only);</span><br><span class="line">        h.<span class="built_in">parallel_for</span>( <span class="comment">// rewriteA</span></span><br><span class="line">            N, [=](id&lt;<span class="number">1</span>&gt; i) &#123;</span><br><span class="line">            accA[i] = <span class="number">21</span> + <span class="number">21</span>;</span><br><span class="line">        	&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line">    </span><br><span class="line">    Q.<span class="built_in">submit</span>([&amp;](handler &amp;h) &#123;</span><br><span class="line">        <span class="comment">// WAW of buffer B</span></span><br><span class="line">        accessor <span class="built_in">accB</span>(B, h, write_only);</span><br><span class="line">        h.<span class="built_in">parallel_for</span>( <span class="comment">// rewriteB</span></span><br><span class="line">            N, [=](id&lt;<span class="number">1</span>&gt; i) &#123;</span><br><span class="line">            accB[i] = <span class="number">30</span> + <span class="number">12</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">   <span class="function">host_accessor <span class="title">host_accA</span><span class="params">(A, read_only)</span></span>;</span><br><span class="line">    <span class="function">host_accessor <span class="title">host_accB</span><span class="params">(B, read_only)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; host_accA[i] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; host_accB[i] &lt;&lt; <span class="string">&quot; &quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Figure 3-15.</strong> <em>Write-after-Read and Write-after-Write</em></p>
<p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/img/image-20220824110107133.png" alt="image-20220824110107133"></p>
<h2 id="Handler-Class"><a href="#Handler-Class" class="headerlink" title="Handler Class"></a>Handler Class</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">handler</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Specifies event(s) that must be complete before the action</span></span><br><span class="line">    <span class="comment">// defined in this command group executes.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">depends_on</span><span class="params">(&#123;event / std::vector&lt;event&gt; &amp; &#125;)</span></span>;</span><br><span class="line">    <span class="comment">// Enqueues a memset operation on the specified pointer.</span></span><br><span class="line">    <span class="comment">// Writes the first byte of Value into Count bytes.</span></span><br><span class="line">    <span class="comment">// Returns an event representing this operation.</span></span><br><span class="line">    <span class="function">event <span class="title">memset</span><span class="params">(<span class="type">void</span> *Ptr, <span class="type">int</span> Value, <span class="type">size_t</span> Count)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// Enqueues a memcpy from Src to Dest.</span></span></span><br><span class="line"><span class="function">    <span class="comment">// Count bytes are copied.</span></span></span><br><span class="line"><span class="function">    <span class="comment">// Returns an event representing this operation.</span></span></span><br><span class="line"><span class="function">    event <span class="title">memcpy</span><span class="params">(<span class="type">void</span> *Dest, <span class="type">const</span> <span class="type">void</span> *Src, <span class="type">size_t</span> Count)</span></span>;</span><br><span class="line">    <span class="comment">// Submits a kernel of one work-item for execution.</span></span><br><span class="line">    <span class="comment">// Returns an event representing this operation.</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> KernelName, <span class="keyword">typename</span> KernelType&gt;</span><br><span class="line">    <span class="function">event <span class="title">single_task</span><span class="params">(KernelType KernelFunc)</span></span>;</span><br><span class="line">    <span class="comment">// Submits a kernel with NumWork-items work-items for execution.</span></span><br><span class="line">    <span class="comment">// Returns an event representing this operation.</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> KernelName, <span class="keyword">typename</span> KernelType, <span class="type">int</span> Dims&gt;</span><br><span class="line">    <span class="function">event <span class="title">parallel_for</span><span class="params">(range&lt;Dims&gt; NumWork-items, KernelType KernelFunc)</span></span>;</span><br><span class="line">    <span class="comment">// Submits a kernel for execution over the supplied nd_range.</span></span><br><span class="line">    <span class="comment">// Returns an event representing this operation.</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> KernelName, <span class="keyword">typename</span> KernelType, <span class="type">int</span> Dims&gt;</span><br><span class="line">    <span class="function">event <span class="title">parallel_for</span><span class="params">(nd_range&lt;Dims&gt; ExecutionRange, KernelType KernelFunc)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Figure 3-17.</strong> <em>Simplified definition of the non-accessor members of the</em> </p>
<p><em>handler class</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">handler</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Specifies event(s) that must be complete before the action</span></span><br><span class="line">    <span class="comment">// Copy to/from an accessor.</span></span><br><span class="line">    <span class="comment">// Valid combinations:</span></span><br><span class="line">    <span class="comment">// Src: accessor, Dest: shared_ptr</span></span><br><span class="line">    <span class="comment">// Src: accessor, Dest: pointer</span></span><br><span class="line">    <span class="comment">// Src: shared_ptr Dest: accessor</span></span><br><span class="line">    <span class="comment">// Src: pointer Dest: accessor</span></span><br><span class="line">    <span class="comment">// Src: accesssor Dest: accessor</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T_Src, <span class="keyword">typename</span> T_Dst, </span><br><span class="line">    		  <span class="type">int</span> Dims, access::mode AccessMode,</span><br><span class="line">    		  access::target AccessTarget,</span><br><span class="line">    		  access::placeholder IsPlaceholder = </span><br><span class="line">    		  	access::placeholder::<span class="type">false_t</span>&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">copy</span>(accessor&lt;T_Src, Dims, AccessMode, </span><br><span class="line">    			  	   AccessTarget, IsPlaceholder&gt; Src,</span><br><span class="line">      				   shared_ptr_class&lt;T_Dst&gt; Dst);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">copy</span><span class="params">(shared_ptr_class&lt;T_Src&gt; Src,</span></span></span><br><span class="line"><span class="params"><span class="function">    		  accessor&lt;T_Dst, Dims, AccessMode, </span></span></span><br><span class="line"><span class="params"><span class="function">    				   AccessTarget, IsPlaceholder&gt; Dst)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">copy</span><span class="params">(accessor&lt;T_Src, Dims, AccessMode, </span></span></span><br><span class="line"><span class="params"><span class="function">    		  AccessTarget, IsPlaceholder&gt; Src,</span></span></span><br><span class="line"><span class="params"><span class="function">    		  T_Dst *Dst)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">copy</span><span class="params">(<span class="type">const</span> T_Src *Src,</span></span></span><br><span class="line"><span class="params"><span class="function">    		  accessor&lt;T_Dst, Dims, AccessMode, </span></span></span><br><span class="line"><span class="params"><span class="function">    				   AccessTarget, IsPlaceholder&gt; Dst)</span></span>;</span><br><span class="line">    <span class="keyword">template</span> &lt;</span><br><span class="line">        <span class="keyword">typename</span> T_Src, <span class="type">int</span> Dims_Src, </span><br><span class="line">        access::mode AccessMode_Src,</span><br><span class="line">        access::target AccessTarget_Src, </span><br><span class="line">        <span class="keyword">typename</span> T_Dst, <span class="type">int</span> Dims_Dst,</span><br><span class="line">        access::mode AccessMode_Dst, </span><br><span class="line">        access::target AccessTarget_Dst,</span><br><span class="line">        access::placeholder IsPlaceholder_Src = </span><br><span class="line">        	access::placeholder::<span class="type">false_t</span>,</span><br><span class="line">        access::placeholder IsPlaceholder_Dst = </span><br><span class="line">        	access::placeholder::<span class="type">false_t</span>&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">copy</span>(accessor&lt;T_Src, Dims_Src, AccessMode_Src, </span><br><span class="line">    				   AccessTarget_Src, IsPlaceholder_Src&gt;</span><br><span class="line">    		  Src,</span><br><span class="line">    		  accessor&lt;T_Dst, Dims_Dst, AccessMode_Dst, </span><br><span class="line">   					   AccessTarget_Dst, IsPlaceholder_Dst&gt;</span><br><span class="line">    		  Dst);</span><br><span class="line">    <span class="comment">// Provides a guarantee that the memory object accessed by the accessor</span></span><br><span class="line">    <span class="comment">// is updated on the host after this action executes.</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> Dims, </span><br><span class="line">    		  access::mode AccessMode,</span><br><span class="line">    		  access::target AccessTarget,</span><br><span class="line">    		  access::placeholder IsPlaceholder =</span><br><span class="line">    		  access::placeholder::<span class="type">false_t</span>&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">update_host</span>(accessor&lt;T, Dims, AccessMode, </span><br><span class="line">    				 AccessTarget, IsPlaceholder&gt; Acc);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Figure 3-18.</strong> <em>Simplified definition of the accessor members of the handler class</em></p>

    </div>

    
    
    

    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
      
    </div>

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Zhang-kg
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://zhang-kg.github.io/2022/08/24/DPC-Book-Chap3/" title="DPC Book Chap3">https://zhang-kg.github.io/2022/08/24/DPC-Book-Chap3/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/PAC/" rel="tag"># PAC</a>
              <a href="/tags/DPC/" rel="tag"># DPC++</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/08/20/DPC-Book-Chap2/" rel="prev" title="DPC Book Chap2">
                  <i class="fa fa-chevron-left"></i> DPC Book Chap2
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang-kg</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">98k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:29</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"mhchem":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
