<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BUAA_OO 第三单元总结</title>
    <url>/2022/06/05/BUAA-OO-%E7%AC%AC%E4%B8%89%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="BUAA-OO-2022-Unit3-总结"><a href="#BUAA-OO-2022-Unit3-总结" class="headerlink" title="BUAA OO 2022 Unit3 总结"></a>BUAA OO 2022 Unit3 总结</h1><h2 id="自测过程"><a href="#自测过程" class="headerlink" title="自测过程"></a>自测过程</h2><p>在本单元中，我依旧和同学相互合作，有同学负责进行数据生成，我负责对拍程序撰写。然后每次作业之后，都进行自动化测试。这个单元同前几个单元一样，黑盒测试不能完全有效的覆盖所有情况，需要针对 JML 中的描述针对性的构造特殊样例，保证测试的完全覆盖。</p>
<span id="more"></span>
<h3 id="课下测试"><a href="#课下测试" class="headerlink" title="课下测试"></a>课下测试</h3><h4 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h4><p>JUnit中有两个基本对象，一个是TestCase；一个是TestSuite。TestCase可以为测试提供一组方法。比如可以使用setup方法在每项测试开始前建立所需环境，可以用teardown方法销毁测试之后的环境。其他方法可以提供诸如检查变量是否为null、比较变量以及捕捉异常的功能。创建测试的时候只需要继承TestCase类，并且按照需要编写自己的测试方法即可。这部分甚至可以在IDEA的插件帮助下快速完成。因此可以节省大量事件用在编写测试用例上面。一个测试的例子可以详见附录A相关内容。TestSuite是由几个TestCase或者其他TestSuite组成的，通过使用TestSuite我们可以创建测试的一个树形结构。JUnit比较易用、简便。重要的是可以收集很多的Junit测试保证测试回归性。但是正如学长学姐们在讨论区的说明，我确实发现了JUnit的如下问题：</p>
<ul>
<li><p>JUnit的测试需要基于对于JML完全理解的基础上</p>
<p>比如这次JML中有限制群组上限为1111人，getReceivedMessages返回最近的4条消息等。这些条件都是不太容易发现的，如果对于JML阅读不仔细，那么这些条件就可能无法被测试到，从而使用JUnit达不到预期效果</p>
</li>
<li><p>需要提前构造好数据</p>
<p>构造数据需要在编写代码之前构造。之前没有建立起这样的习惯。</p>
</li>
</ul>
<h4 id="课下强测"><a href="#课下强测" class="headerlink" title="课下强测"></a>课下强测</h4><p>这一单元的测试和前两个单元不太一样。这个单元的测试比较固定，确定输入就可以确定输出，所以在测试上可以无脑对拍。在本单元中，我和wxg、ghy、lsz、qs同学一起完成了测试程序的编写和自动化测试部分。其中数据生成部分由wxg同学编写。在数据生成器的编写上，采用了常量池和随机数的经典做法。常量池保证了边界数据范围、随机数保证了测试数据覆盖性。数据生成器中的函数对应着一条指令。数据生成的过程，本质上是根据随机数调用函数产生指令的过程。在此基础上，我们可以编写相应的代码，生成完全图、单组的图等等特殊数据，确保数据强度，和程序鲁棒性。</p>
<h4 id="边界数据"><a href="#边界数据" class="headerlink" title="边界数据"></a>边界数据</h4><p>边界数据的构造一般是通过阅读JML和对于随机生成的数据进行手动重新构造完成的。第一点，就像刚刚提到的，随机生成的数据可能不能很好的保证覆盖到JML规定的所有行为，比如1111人和getReceivedMessages。此时就需要根据JML进行手动构造。第二点，根据随机生成的数据进行手动重新构造也是一种边界数据产生的途径。这种方法常见于前两个单元。随机数据的生成中对于某些侧重点的指令，比如qgvs，在测试的过程中可能就会出现TLE或者WA的问题，此时就可以通过分析随机数据生成的结果，手动构造针对性更强，强度更高的数据。</p>
<h3 id="互测构造"><a href="#互测构造" class="headerlink" title="互测构造"></a>互测构造</h3><p>在三次互测中，我表现的比较佛。一方面是JML规定了实现的方式，所以大家在实现的过程中都大同小异。当我在阅读他人的代码的时候，很难发现他人的问题。另一方面是卡人的数据都是我们课下造好了的，所以可以在互测的过程中直接使用。</p>
<h2 id="图模型构建和维护策略"><a href="#图模型构建和维护策略" class="headerlink" title="图模型构建和维护策略"></a>图模型构建和维护策略</h2><h3 id="作业中的结构"><a href="#作业中的结构" class="headerlink" title="作业中的结构"></a>作业中的结构</h3><p>作业的背景是一个社交网络，但是如果仔细阅读JML会发现，整个系统中person就是一个个节点，relation是点之间的边。而在Network中的各个方法都是维护这个图的方法。比如addRealtion就是在点之间加边；isCircle就是检查两个点之间的连通性；queryBlockSum就是查询这个图中连通块个数；queryLeastConnection是求某个点组成的最小生成树；sendIndirectMessage求出两个点之间最短路等等。</p>
<h3 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h3><h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><p>并查集是一种树形的数据结构，用于处理一些不相交集合的合并和查询问题。并查集通常包含两种方法，分别是查找和合并。查找是查询两个元素是否在同一个集合中；合并是将两个不相交的集合合并成一个集合。在作业中，可以将person作为一个个点，然后relation作为边，将所有认识的人看成一个集合。这样查询两个人是否认识，就是查询两个人是否在一个集合中；而addRelation中添加两个人的认识关系，就是将AB两个人分别所在的集合合并起来，这正好对应了并查集中的查找和合并操作。使用并查集后，可以简化queryBlockSum和isCircle的查询速度。具体的实现方法就是采用”代表元“法，就是每个集合选择一个固定的元素作为整个集合的代表元素。</p>
<p>这里给出一种经典的C++语言实现并查集的方法，可以作为Java语言实现参考：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 并查集的存储</span></span><br><span class="line"><span class="type">int</span> fa[SIZE];</span><br><span class="line"><span class="comment">// 2. 并查集的初始化</span></span><br><span class="line"><span class="comment">// 假设有 n 个元素，起初所有元素各自构成一个独立的集合，即有n棵1个点的树。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i] = i;</span><br><span class="line"><span class="comment">// 3. 并查集的 Get 操作</span></span><br><span class="line"><span class="comment">// 若x是树根，则x就是集合的代表，否则递归访问fa[x]直到根节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (x == fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x] = <span class="built_in">get</span>(fa[x]);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 4. 并查集的 Merge 操作</span></span><br><span class="line"><span class="comment">// 合并元素x和元素y所在的集合，等价于让x的树根作为y的树根的子节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>{</span><br><span class="line">    fa[<span class="built_in">get</span>(x)] = <span class="built_in">get</span>(y);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>并查集的算法中还有按秩合并等优化方法，但是经过实测优化程度不大。所以有兴趣自己学吧。</p>
<h4 id="克鲁斯卡尔算法（最小生成树）"><a href="#克鲁斯卡尔算法（最小生成树）" class="headerlink" title="克鲁斯卡尔算法（最小生成树）"></a>克鲁斯卡尔算法（最小生成树）</h4><p>queryLeastConnection这个函数是求某个点可达的所有点组成的最小生成树。在这个方面有prim算法和kruskal算法可选。最后我选择了kruskal算法，因为<strong>我维护了边的序列</strong>而且<strong>实现了判断两个两个点是否联通的简单方法</strong>。这个算法的思想是将所有边按照权重大小排序，从小到大选择依次选择每条边，如果这条边加入最小生成树的答案中没有使当前图出现回路即可。如果这个点所在的连通集有n个点，则根据定义，他的最小生成树一定有n-1条边。优化方法：判断加边后是否出现回路——维护一个并查集，并查集表示和某个点联通的所有点集，只要待加入的边两端的点不在同一个点集内即可；边按照权重排序——维护一个有序的边序列，这部分可以使用二分法找到合适的位置插入。这里给出一个C++经典实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">rec</span> {<span class="type">int</span> x, y, z;} edge[MAX];</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(rec a, rec b) {</span><br><span class="line">    <span class="keyword">return</span> a.z &lt; b.z;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sort</span>(edge + <span class="number">1</span>, edge + m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) {</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">get</span>(edge[i].x);</span><br><span class="line">        <span class="type">int</span> y = <span class="built_in">get</span>(edge[i].y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">continue</span>;</span><br><span class="line">        fa[x] = y;</span><br><span class="line">        ans += edge[i].z;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="迪杰斯特拉算法（最短路）"><a href="#迪杰斯特拉算法（最短路）" class="headerlink" title="迪杰斯特拉算法（最短路）"></a>迪杰斯特拉算法（最短路）</h4><p>sendIndirectMessage这个方法所求的是两个点之间的最短路。求单源最短路这个问题的模型是，给定一张有向图，（x，y，z）表示从点x到点y长度为z的有向边。这个问题中经典的方法有Dijkstra方法，这是一个贪心算法，它适用于所有边都是非负数的图。当边长z都是非负数时，全局最小值不可能被其他点更新，故选出的最短的节点x必然满足：dist[x]已经是起点到x的最短路，不断选择最短路就能对全局所有点更新最短路。这里由于求两个特定点之间的最短路，因此可以使用剪枝方法：如果当前找到的点就是id2，当即退出。这里给出一个经典的C++算法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">    <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) {</span><br><span class="line">        <span class="type">int</span> x = q.<span class="built_in">top</span>().second; q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (v[x]) <span class="keyword">continue</span>;</span><br><span class="line">        v[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = next[i]) {</span><br><span class="line">            <span class="type">int</span> y = ver[i], z = edge[i];</span><br><span class="line">            <span class="keyword">if</span> (d[y] &gt; d[x] + z) {</span><br><span class="line">                d[y] = d[x] + z;</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(-d[y], y));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这里使用了大根堆，并且插入负数变成小根堆。Java中含有堆容器，但是这里可以使用二分法就如上面一样，无非就是维护一个有序的集合。</p>
<h2 id="性能问题和修复策略"><a href="#性能问题和修复策略" class="headerlink" title="性能问题和修复策略"></a>性能问题和修复策略</h2><h3 id="容器使用"><a href="#容器使用" class="headerlink" title="容器使用"></a>容器使用</h3><p>JML之提供一个参考的数据存储容器，可以使用ArrayList，也可以根据实际需要选择不同的容器。由于每个人的id不同，我们可以选择HashMap存储每个人的id到Person的关系，来达到快速访问。</p>
<p>Network</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Integer, Person&gt; people;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Integer, Group&gt; groups;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">qbsAns</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//private final ArrayList&lt;Message&gt; messages;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Integer, Message&gt; messages;</span><br><span class="line"><span class="comment">//private HashMap&lt;Person, Person&gt; fathers = new HashMap&lt;&gt;();</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Integer, Person&gt; fathers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;Edge&gt; edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Integer, Integer&gt; emojiMessages = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Integer, Integer&gt; dist = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>Group</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> id;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Integer, Person&gt; people;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">valueSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">ageSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>Person</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> id;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> socialValue;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> money;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Integer, Person&gt; acquaintance;  <span class="comment">// id - person</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Person, Integer&gt; value; <span class="comment">// person - value</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;Message&gt; messages = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h3 id="代码编写和维护"><a href="#代码编写和维护" class="headerlink" title="代码编写和维护"></a>代码编写和维护</h3><p>在代码编写的时候随时维护答案，维护边集有序、维护并查集</p>
<p>例如qbs指令查询当前有多少个联通块，这样可以在，addPerson的时候、addRelation的时候更新qbs的值；</p>
<p>边集有序维护的方法：</p>
<p>使用二分法，找到新边的合适位置，在插入进去，用时O(logn + n)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(ArrayList&lt;Edge&gt; arrayList, Edge edge)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> arrayList.size();</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> edge.getValue();</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) {</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (value &gt; arrayList.get(mid).getValue()) {</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            r = mid;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    arrayList.add(l, edge);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>并查集维护方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//private Person findFather(HashMap&lt;Person, Person&gt; fa, Person person) {</span></span><br><span class="line"><span class="keyword">private</span> Person <span class="title function_">findFather</span><span class="params">(HashMap&lt;Integer, Person&gt; fa, Person person)</span> {</span><br><span class="line">    <span class="keyword">if</span> (fa.get(person.getId()) == person) {</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="type">Person</span> <span class="variable">father</span> <span class="operator">=</span> findFather(fa, fa.get(person.getId()));</span><br><span class="line">        <span class="comment">//fa.put(person, father);</span></span><br><span class="line">        fa.put(person.getId(), father);</span><br><span class="line">        <span class="keyword">return</span> father;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="Network-扩展"><a href="#Network-扩展" class="headerlink" title="Network 扩展"></a>Network 扩展</h2><h3 id="扩展要求"><a href="#扩展要求" class="headerlink" title="扩展要求"></a>扩展要求</h3><p>假设出现了几种不同的Person</p>
<ul>
<li>Advertiser：持续向外发送产品广告</li>
<li>Producer：产品生产商，通过Advertiser来销售产品</li>
<li>Customer：消费者，会关注广告并选择和自己偏好匹配的产品来购买 — 所谓购买，就是直接通过Advertiser给相应Producer发一个购买消息</li>
<li>Person：吃瓜群众，不发广告，不买东西，不卖东西</li>
</ul>
<p>如此Network可以支持市场营销，并能查询某种商品的销售额和销售路径等 请讨论如何对Network扩展，给出相关接口方法，并选择3个核心业务功能的接口方法撰写JML规格（借鉴所总结的JML规格模式）</p>
<h3 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h3><p><strong>框架：</strong>Advertiser、Producer和Customer继承自Person；增加Advertisement和Product，继承自Message；Customer中增加偏好，偏好用一个32位的数表示，每一位代表一种爱好；Product中同样包含着一个32位的int类型的数，表示产品的具有的属性。当产品的属性和顾客的偏好有交集时，顾客会购买产品。</p>
<p><strong>增加异常：</strong></p>
<p><strong>方法1：</strong>Advertiser发送广告</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	@ public normal_behavior</span></span><br><span class="line"><span class="comment">	@ requires (\exists int i; 0 &lt;= i &amp;&amp; i &lt; people.length; people[i].getId() == id &amp;&amp; people[i] instanceof Advertiser);</span></span><br><span class="line"><span class="comment">	@ ensures getPerson(id).advertisements.length == \old(getPerson(id).advertisements.length) - 1;</span></span><br><span class="line"><span class="comment">	@ ensures (\forall int i; 0 &lt;= i &amp;&amp; i &lt; people.length; (getPerson(id).isLinked(people[i])) ==&gt; (people[i].messages.length == \old(people[i].messages.length) + 1 &amp;&amp; people[i].messages[0] == \old(getPerson(id).advertisements[0]) &amp;&amp; (\forall int j; 1 &lt;= j &amp;&amp; j &lt; people[i].messages.length; people[i].messages[j] == \old(people[i].messages[j - 1]))));</span></span><br><span class="line"><span class="comment">	@ ensures (\forall int i; 0 &lt;= i &amp;&amp; i &lt; people.length; !(getPerson(id).isLinked(people[i])) ==&gt; (people[i].messages.length == \old(people[i].messages.length &amp;&amp; (\forall int j; 0 &lt;= j &amp;&amp; j &lt; people[i].messages.length; people[i].messages[j] == \old(people[i].messages[j]))));</span></span><br><span class="line"><span class="comment">	@ public exceptional_behavior </span></span><br><span class="line"><span class="comment">	@ signals (PersonIdNotFoundException e) (\forall int i; 0 &lt;= i &amp;&amp; i &lt; people.length; people[i].getId() != id || (people[i].getId() == id &amp;&amp; !people[i] instanceof Advertiser));</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendAdvertisement</span><span class="params">(<span class="type">int</span> id)</span> <span class="keyword">throws</span> PersonIdNotFoundException;</span><br></pre></td></tr></table></figure>
<p><strong>方法2：</strong>查询销量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	@ public normal_behavior</span></span><br><span class="line"><span class="comment">	@ requires (\exists int i; 0 &lt;= i &amp;&amp; i &lt; people.length; people[i].getId() == id &amp;&amp; people[i] instanceof Producer);</span></span><br><span class="line"><span class="comment">	@ requires (\exists int i; 0 &lt;= i &amp;&amp; i &lt; getPerson(id).products.length; getPerson(id).products[i].getId() == productId);</span></span><br><span class="line"><span class="comment">	@ \results == getPerson(id).getProduct(productId).money * (\sum int i; 0 &lt;= i &amp;&amp; i &lt; people.length; (\exists int j; 0 &lt;= j &amp;&amp; j &lt; people[i].products.length; prople[i].products[j].equals(getPerson(id).getProduct(productId))));</span></span><br><span class="line"><span class="comment">	@ public exceptional_behavior</span></span><br><span class="line"><span class="comment">	@ signals (PersonIdNotFoundException e) !(\exists int i; 0 &lt;= i &amp;&amp; i &lt; people.length; people[i].getId() == id &amp;&amp; people[i] instanceof Producer)</span></span><br><span class="line"><span class="comment">	@ public exceptional_behavior</span></span><br><span class="line"><span class="comment">	@ signals (ProductNotFoundException e) !(\exists int i; 0 &lt;= i &amp;&amp; i &lt; getPerson(id).products.length; getPerson(id).products[i].getId() == productId);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">querySalaryValue</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> productId)</span> <span class="keyword">throws</span> PersonIdNotFoundException, ProductIdNotFoundException;</span><br></pre></td></tr></table></figure>
<p><strong>方法3：</strong>顾客根据广告购买产品</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	@ public normal_behavior</span></span><br><span class="line"><span class="comment">	@ requires (\exists int i; 0 &lt;= i &amp;&amp; i &lt; people.length; people[i].getId() == id &amp;&amp; people[i] instanceof Customer);</span></span><br><span class="line"><span class="comment">	@ requires (\forall int i; 0 &lt;= i &amp;&amp; i &lt; getPerson(id).advertisemens.length; getPerson(id).money &lt; advertisements[i].money || getPerson(id).preferInfo &amp; advertisements[i].productInfo == 0 || (\exists int j; 0 &lt;= j &amp;&amp; j &lt; \old(getPerson(id).products.length); \old(getPerson(id).products[j]).equals(getPerson(id).advertisements[i].product)));</span></span><br><span class="line"><span class="comment">	@ requires \old(getPerson(id).money) == getPerson(id).money + (\sum int i; 0 &lt;= i &amp;&amp; i &lt; \old(getPerson(id).advertisements.length); (getPerson(id).advertisement.contains(\old(getPerson(id).advertisements[i]))) ==&gt; \old(getPerson(id).advertisements[i]).money);</span></span><br><span class="line"><span class="comment">	@ signals (PersonIdNotFoundExeception e) !(\exists int i; 0 &lt;= i &amp;&amp; i &lt; people.length; people[i].getId() == id &amp;&amp; people[i] instanceof Customer);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">purchase</span><span class="params">(<span class="type">int</span> id)</span> <span class="keyword">throws</span> PersonIdNotFoundException, ProductIdNotFoundException;</span><br></pre></td></tr></table></figure>
<h2 id="学习体会"><a href="#学习体会" class="headerlink" title="学习体会"></a>学习体会</h2><p><strong>规格化设计：</strong>本单元中主要学习了什么是规格化设计和契约式设计。规格化设计就是定义一个开发人员必须遵守的规约。对于一个类来说，类包含数据规格和方法规格。</p>
<ul>
<li>数据规格：类所管理的数据内容，及其有效性条件（invariant，constraint）<ul>
<li>invariant：任何时刻数据内容都必须满足的约束条件</li>
<li>constraint：任何时刻对于数据内容的修改都必须满足的条件</li>
</ul>
</li>
<li>方法规格：类所规定的操作，权利 + 义务 + 注意事项，包括前置条件 + 后置条件 + 副作用<ul>
<li>前置条件：规定了开发人员可以依赖的初始条件</li>
<li>后置条件：开发人员必须保证的需求满足结果</li>
</ul>
</li>
</ul>
<p>规格化设计中，比较重要的是契约式编程，这部分可以看<strong>附录B</strong></p>
<p><strong>基于JML的规格模式：</strong>规格是对于数据和方法方方面面的约束，规格模式是对于规格的设计。在这方面JML是一种规格设计的模型语言。</p>
<ul>
<li><p>JML定义了许多描述规格的方法和语法，具体内容可以参考<strong>附录C</strong></p>
</li>
<li><p>JML写好了可以清楚明白的传递规格的定义和编写者思想，没有自然语言的二义性，因为一切条件和限制都清清楚楚的写到规格定义中了，通过阅读JML任何人都可以或者规格的定义，即使一个人最开始不知道什么是“最短路”，什么是”连通图“，通过反复阅读JML最终也能够理解；但是JML同样也有缺点，就是比较复杂，这一点从助教团队不断的修改指导书也能看出来，刚刚Network扩展任务中我也感受到了这一点，短短几句话就能说明白的事情，往往需要写很多JML。</p>
</li>
<li>而且我认为<strong>JML</strong>具有一种依赖性，它把自然语言和抽象的规格说明分割开了。用自然语言说明一个方法的时候，可能暗含一些条件，不用说大家都能明白的那种；但是在JML中，这些应说未说的条件需要全部写出来，这对于编写者是一个挑战，因为一些理所应当、稀疏平常的条件不太容易一下子想起来。当阅读者阅读到JML的时候，又会切断自然思考的模式，就着JML推测编写者的含义，这时候如果一些条件没写出来，很容易出现读者”较真“的情况，或者<strong>在讨论区问一些看似没有必要问</strong>的问题，这一点在三四单元都很容易出现，所以<strong>第四单元助教甚至开了一个精华帖子</strong>。这种”较真“的情况恰恰说明了JML隔绝了人们使用自然语言的思考。</li>
</ul>
<h2 id="附录A-JUnit-测试方法"><a href="#附录A-JUnit-测试方法" class="headerlink" title="附录A JUnit 测试方法"></a>附录A JUnit 测试方法</h2><ol>
<li><p>确定我们要实现的契约</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">require</span><br><span class="line">    count &lt;= capacity</span><br><span class="line">    not key.empty </span><br><span class="line">ensure</span><br><span class="line">    <span class="title function_">has</span> <span class="params">(x)</span></span><br><span class="line">    item (key) = <span class="type">x</span></span><br><span class="line">    <span class="variable">count</span> <span class="operator">=</span> old count + <span class="number">1</span></span><br><span class="line">invariant</span><br><span class="line">    <span class="number">0</span> &lt;= count</span><br><span class="line">    count &lt;= capacity</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定 JUnit 测试点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">invariant count &lt;= capacity</span><br><span class="line">invariant <span class="number">0</span> &lt;= count</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span> <span class="keyword">void</span> <span class="title function_">it_creates_dictionary_with_specified_capacity</span><span class="params">()</span> {</span><br><span class="line">        assertThat(<span class="keyword">new</span> <span class="title class_">Dictionary</span>(<span class="number">5</span>).capacity(), is(equalTo(<span class="number">5</span>)));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">invariant count &lt;= capacity</span><br><span class="line">invariant <span class="number">0</span> &lt;= count</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span> <span class="keyword">void</span> <span class="title function_">on_creation_the_count_is_zero</span><span class="params">()</span> {</span><br><span class="line">        assertThat(<span class="keyword">new</span> <span class="title class_">Dictionary</span>(<span class="number">5</span>).count(), is(equalTo(<span class="number">0</span>)));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">invariant count &lt;= capacity</span><br><span class="line">invariant <span class="number">0</span> &lt;= count</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span> <span class="keyword">void</span> <span class="title function_">it_rejects_a_negative_capacity</span><span class="params">()</span> {</span><br><span class="line">        assertThrows(ContractViolationException.class, ()-&gt;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Dictionary</span>(-<span class="number">1</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">ensure <span class="title function_">has</span> <span class="params">(x)</span></span><br><span class="line">ensure <span class="title function_">item</span> <span class="params">(key)</span> = x</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span> <span class="keyword">void</span> <span class="title function_">an_entry_can_be_added_and_looked_up_by_its_key</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Dictionary</span> <span class="variable">dict</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dictionary</span>(<span class="number">1</span>);</span><br><span class="line">        dict.put(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">        assertThat(dict.get(<span class="string">"key1"</span>), is(equalTo(<span class="string">"value1"</span>)));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="type">ensure</span> <span class="variable">count</span> <span class="operator">=</span> old count + <span class="number">1</span>    </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span> <span class="keyword">void</span> <span class="title function_">after_adding_an_entry_the_count_is_increased_by_one</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Dictionary</span> <span class="variable">dict</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dictionary</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">expectedCount</span> <span class="operator">=</span> dict.count() + <span class="number">1</span>;</span><br><span class="line">        dict.put(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">        assertThat(dict.count(), is(equalTo(expectedCount)));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">require not key.empty</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span> <span class="keyword">void</span> <span class="title function_">it_will_not_accept_an_entry_with_a_null_key</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Dictionary</span> <span class="variable">dict</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dictionary</span>(<span class="number">1</span>);</span><br><span class="line">        assertThrows(ContractViolationException.class, ()-&gt;</span><br><span class="line">                dict.put(<span class="literal">null</span>, <span class="string">"value1"</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">require not key.empty</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span> <span class="keyword">void</span> <span class="title function_">it_will_not_accept_an_entry_with_an_empty_key</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Dictionary</span> <span class="variable">dict</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dictionary</span>(<span class="number">1</span>);</span><br><span class="line">        assertThrows(ContractViolationException.class, ()-&gt;</span><br><span class="line">                dict.put(<span class="string">""</span>, <span class="string">"value1"</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">require count &lt;= capacity</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span> <span class="keyword">void</span> <span class="title function_">it_will_not_accept_an_entry_when_it_is_full</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Dictionary</span> <span class="variable">dict</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dictionary</span>(<span class="number">1</span>);</span><br><span class="line">        dict.put(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">        assertThrows(ContractViolationException.class, ()-&gt;</span><br><span class="line">                dict.put(<span class="string">"key2"</span>, <span class="string">"value2"</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DictionaryTest</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span> <span class="keyword">void</span> <span class="title function_">it_creates_dictionary_with_capacity_5</span><span class="params">()</span> {</span><br><span class="line">        assertThat(<span class="keyword">new</span> <span class="title class_">Dictionary</span>(<span class="number">5</span>).capacity(), is(equalTo(<span class="number">5</span>)));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span> <span class="keyword">void</span> <span class="title function_">it_creates_dictionary_with_capacity_1000</span><span class="params">()</span> {</span><br><span class="line">        assertThat(<span class="keyword">new</span> <span class="title class_">Dictionary</span>(<span class="number">1000</span>).capacity(), is(equalTo(<span class="number">1000</span>)));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span> <span class="keyword">void</span> <span class="title function_">on_creation_the_count_is_zero</span><span class="params">()</span> {</span><br><span class="line">        assertThat(<span class="keyword">new</span> <span class="title class_">Dictionary</span>(<span class="number">5</span>).count(), is(equalTo(<span class="number">0</span>)));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span> <span class="keyword">void</span> <span class="title function_">it_rejects_a_negative_capacity</span><span class="params">()</span> {</span><br><span class="line">        assertThrows(ContractViolationException.class, ()-&gt;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Dictionary</span>(-<span class="number">1</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span> <span class="keyword">void</span> <span class="title function_">an_entry_can_be_added_and_looked_up_by_its_key</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Dictionary</span> <span class="variable">dict</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dictionary</span>(<span class="number">1</span>);</span><br><span class="line">        dict.put(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">        assertThat(dict.get(<span class="string">"key1"</span>), is(equalTo(<span class="string">"value1"</span>)));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span> <span class="keyword">void</span> <span class="title function_">after_adding_an_entry_the_count_is_increased_by_one</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Dictionary</span> <span class="variable">dict</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dictionary</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">expectedCount</span> <span class="operator">=</span> dict.count() + <span class="number">1</span>;</span><br><span class="line">        dict.put(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">        assertThat(dict.count(), is(equalTo(expectedCount)));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span> <span class="keyword">void</span> <span class="title function_">it_will_not_accept_an_entry_with_a_null_key</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Dictionary</span> <span class="variable">dict</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dictionary</span>(<span class="number">1</span>);</span><br><span class="line">        assertThrows(ContractViolationException.class, ()-&gt;</span><br><span class="line">                dict.put(<span class="literal">null</span>, <span class="string">"value1"</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span> <span class="keyword">void</span> <span class="title function_">it_will_not_accept_an_entry_with_an_empty_key</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Dictionary</span> <span class="variable">dict</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dictionary</span>(<span class="number">1</span>);</span><br><span class="line">        assertThrows(ContractViolationException.class, ()-&gt;</span><br><span class="line">                dict.put(<span class="string">""</span>, <span class="string">"value1"</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span> <span class="keyword">void</span> <span class="title function_">it_will_not_accept_an_entry_when_it_is_full</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Dictionary</span> <span class="variable">dict</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dictionary</span>(<span class="number">1</span>);</span><br><span class="line">        dict.put(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">        assertThrows(ContractViolationException.class, ()-&gt;</span><br><span class="line">                dict.put(<span class="string">"key2"</span>, <span class="string">"value2"</span>));</span><br><span class="line">    }</span><br><span class="line">} </span><br></pre></td></tr></table></figure>
</li>
<li><p>为什么我们不直接使用 if 方法？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Dictionary(<span class="type">int</span> capacity) {</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt; <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    contents = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(capacity);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Dictionary(<span class="type">int</span> capacity) {</span><br><span class="line">    Contract.require(capacity &gt; <span class="number">0</span>,</span><br><span class="line">                     <span class="string">"Capacity must be greater than zero"</span>);</span><br><span class="line">    <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    contents = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(capacity);</span><br><span class="line">} </span><br></pre></td></tr></table></figure>
<p>上下两种方法都可以实现前置条件和后置条件的检测。我们要选择哪个？上面那种方法固然可以实现检测前置条件，但是这里的 if 和程序正常逻辑中的if有什么分别？如果不给这个特殊的if一个特殊的含义，这是否会干扰我们后续检查代码？</p>
</li>
<li><p>最终</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dictionary</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;string,object&gt; contents;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dictionary</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        Contract.require(capacity &gt; <span class="number">0</span>,</span><br><span class="line">            <span class="string">"Capacity must be greater than zero"</span>);</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        contents = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(capacity);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, Object value)</span> {</span><br><span class="line">        Contract.require(StringUtils.isNotEmpty(key),</span><br><span class="line">            <span class="string">"Key cannot be empty"</span>);</span><br><span class="line">        Contract.require(contents.size() &lt; capacity,</span><br><span class="line">            <span class="string">"Dictionary is full"</span>);</span><br><span class="line">        contents.put(key, value);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span> { <span class="keyword">return</span> contents.get(key); }</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">capacity</span><span class="params">()</span> { <span class="keyword">return</span> capacity; }</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span> { <span class="keyword">return</span> contents.size(); }</span><br><span class="line">}    </span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Contract</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">require</span><span class="params">(<span class="type">boolean</span> expression, String message)</span> {</span><br><span class="line">        <span class="keyword">if</span> (!expression) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ContractViolationException</span>(message);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="附录B-契约式编程-design-by-contract"><a href="#附录B-契约式编程-design-by-contract" class="headerlink" title="附录B 契约式编程 design by contract"></a>附录B 契约式编程 design by contract</h2><h3 id="什么是契约式编程？"><a href="#什么是契约式编程？" class="headerlink" title="什么是契约式编程？"></a>什么是契约式编程？</h3><p>契约式编程于1980年代由 Bertrand Mayer 提出，这是一种软件设计方法，侧重于指定软件、方法之间交互的契约。软件的运行中，各个方法之间的交互可以看成是客户端-服务器模式（client-server model），服务器做出需要某些承诺或者叫做契约来向客户端提供服务，同时客户端必须遵守这些承诺，否则将无法保证可以得到服务器的服务。上述契约一般是使用服务器时的前置条件，通常也包含后置条件和不变式（invariant）。从中我们可以提炼出一个一般的思想：Hoare triples（霍尔三元组），它是由计算机科学家 Tony Hoare 在1969年提出的概念，我们可以通过考虑一段代码的执行如何改变计算状态来推理软件的正确性。基本的公式是：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.733ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 4302 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="7B" d="M434 -231Q434 -244 428 -250H410Q281 -250 230 -184Q225 -177 222 -172T217 -161T213 -148T211 -133T210 -111T209 -84T209 -47T209 0Q209 21 209 53Q208 142 204 153Q203 154 203 155Q189 191 153 211T82 231Q71 231 68 234T65 250T68 266T82 269Q116 269 152 289T203 345Q208 356 208 377T209 529V579Q209 634 215 656T244 698Q270 724 324 740Q361 748 377 749Q379 749 390 749T408 750H428Q434 744 434 732Q434 719 431 716Q429 713 415 713Q362 710 332 689T296 647Q291 634 291 499V417Q291 370 288 353T271 314Q240 271 184 255L170 250L184 245Q202 239 220 230T262 196T290 137Q291 131 291 1Q291 -134 296 -147Q306 -174 339 -192T415 -213Q429 -213 431 -216Q434 -219 434 -231Z"></path></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mo" transform="translate(1251,0)"><path data-c="7D" d="M65 731Q65 745 68 747T88 750Q171 750 216 725T279 670Q288 649 289 635T291 501Q292 362 293 357Q306 312 345 291T417 269Q428 269 431 266T434 250T431 234T417 231Q380 231 345 210T298 157Q293 143 292 121T291 -28V-79Q291 -134 285 -156T256 -198Q202 -250 89 -250Q71 -250 68 -247T65 -230Q65 -224 65 -223T66 -218T69 -214T77 -213Q91 -213 108 -210T146 -200T183 -177T207 -139Q208 -134 209 3L210 139Q223 196 280 230Q315 247 330 250Q305 257 280 270Q225 304 212 352L210 362L209 498Q208 635 207 640Q195 680 154 696T77 713Q68 713 67 716T65 731Z"></path></g><g data-mml-node="mi" transform="translate(1751,0)"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mo" transform="translate(2511,0)"><path data-c="7B" d="M434 -231Q434 -244 428 -250H410Q281 -250 230 -184Q225 -177 222 -172T217 -161T213 -148T211 -133T210 -111T209 -84T209 -47T209 0Q209 21 209 53Q208 142 204 153Q203 154 203 155Q189 191 153 211T82 231Q71 231 68 234T65 250T68 266T82 269Q116 269 152 289T203 345Q208 356 208 377T209 529V579Q209 634 215 656T244 698Q270 724 324 740Q361 748 377 749Q379 749 390 749T408 750H428Q434 744 434 732Q434 719 431 716Q429 713 415 713Q362 710 332 689T296 647Q291 634 291 499V417Q291 370 288 353T271 314Q240 271 184 255L170 250L184 245Q202 239 220 230T262 196T290 137Q291 131 291 1Q291 -134 296 -147Q306 -174 339 -192T415 -213Q429 -213 431 -216Q434 -219 434 -231Z"></path></g><g data-mml-node="mi" transform="translate(3011,0)"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"></path></g><g data-mml-node="mo" transform="translate(3802,0)"><path data-c="7D" d="M65 731Q65 745 68 747T88 750Q171 750 216 725T279 670Q288 649 289 635T291 501Q292 362 293 357Q306 312 345 291T417 269Q428 269 431 266T434 250T431 234T417 231Q380 231 345 210T298 157Q293 143 292 121T291 -28V-79Q291 -134 285 -156T256 -198Q202 -250 89 -250Q71 -250 68 -247T65 -230Q65 -224 65 -223T66 -218T69 -214T77 -213Q91 -213 108 -210T146 -200T183 -177T207 -139Q208 -134 209 3L210 139Q223 196 280 230Q315 247 330 250Q305 257 280 270Q225 304 212 352L210 362L209 498Q208 635 207 640Q195 680 154 696T77 713Q68 713 67 716T65 731Z"></path></g></g></g></svg></mjx-container></p>
<p>P 表示前置条件（Post Condition），C 代表计算（Calculation），Q代表后置条件（Post Condition）。前置条件和后置条件都使用谓词逻辑（predicate logic, also known as <em>first-order logic</em>）进行表述。在 DbC 中，不变式是某些数据结构或者系统状态不会在计算过程中被改变或者影响的方面。</p>
<h4 id="跳出-Java，来到更大的世界"><a href="#跳出-Java，来到更大的世界" class="headerlink" title="跳出 Java，来到更大的世界"></a>跳出 Java，来到更大的世界</h4><p>由于我们的课程叫做面向对象程序设计，不是java程序设计，所以我想介绍一些契约式编程在 java 之外的应用（为什么强调应用在 Java？因为我们可以从这两次的作业中看到，虽然 JML 语言应用了契约式编程思想，但是仍然需要在方法前面写一堆谓词逻辑来保证行为的正确性。而且这种逻辑很容易写错<del>助教修订了很多次对吧</del>）。契约式编程的创始人 Mayer 创造了这样的一种规范化的定义，但是Mayer 并没有止步于此，他还开发了一种编程语言，其中内置了契约式编程，并且借此提高编译速度——Eiffel 语言。</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">class DICTIONARY [ELEMENT]</span><br><span class="line">feature</span><br><span class="line">	put (x: ELEMENT;<span class="built_in"> key</span>: STRING) <span class="literal">is</span></span><br><span class="line">			-- Insert x so that it will be retrievable</span><br><span class="line">			-- through<span class="built_in"> key</span>.</span><br><span class="line">		require</span><br><span class="line">		<span class="built_in">	count</span> &lt;= capacity</span><br><span class="line">		<span class="built_in">	not</span><span class="built_in"> key</span><span class="built_in">.empty</span> </span><br><span class="line">		ensure</span><br><span class="line">			has (x)</span><br><span class="line">			<span class="type">item</span> <span class="built_in">(key</span>) = x</span><br><span class="line">		<span class="built_in">	count</span> = old<span class="built_in"> count</span> + <span class="number">1</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	... Interface specifications <span class="keyword">of</span> other features ...</span><br><span class="line"></span><br><span class="line">invariant</span><br><span class="line">	<span class="number">0</span> &lt;=<span class="built_in"> count</span></span><br><span class="line"><span class="built_in">	count</span> &lt;= capacity</span><br><span class="line"><span class="keyword">end</span>	</span><br></pre></td></tr></table></figure>
<p>require 关键字定义了前置条件，在这里比如数量小于总容量，不能添加没有key的元素等</p>
<p>ensure 关键字定义了后置条件，比如说这里保证了 put 方法之后一定含有这个元素，新的count为原count+1等</p>
<p>invariant 关键字定义了不随计算改变的整个系统的状态，所以他的范围比require和ensure更大，在这里比如count大于等于0，count小于总容量等限制条件。</p>
<h3 id="契约式编程不只是测试"><a href="#契约式编程不只是测试" class="headerlink" title="契约式编程不只是测试"></a>契约式编程不只是测试</h3>

<h4 id="一个可能的应用场景"><a href="#一个可能的应用场景" class="headerlink" title="一个可能的应用场景"></a>一个可能的应用场景</h4><p>在微服务器日益普及，某个给定的应用程序可能由许多素未谋面的人独立开发出来；用时客户从注册表中查找某个服务，也常常不清楚他们正在调用的服务接口到底是什么样子的。在互联网的环境中，程序的运行环境不再像我们本机一样可靠和安全，不确定的输入和攻击可能从四面八方涌来。当我们的软件或者方法被其他使用者调用时，DbC 提供了一种确保代码仍然能够可靠运行的方法。</p>
<h3 id="契约式编程的广泛应用"><a href="#契约式编程的广泛应用" class="headerlink" title="契约式编程的广泛应用"></a>契约式编程的广泛应用</h3><p><strong>Java</strong></p>
<p>在 java 中我们可以使用某些插件来使用契约式编程，比如 COFOJA 和 ANNOTATED-CONTRACTS。Cofoja 是谷歌开发团队在2011年左右开始的项目，大约在2015年左右火了一把，之后就一直萎靡不振。在这个插件中有三种关键的定义</p>
<ul>
<li>@Requires ——方法前置条件</li>
<li>@Ensures ——方法后置条件</li>
<li>@Invariant ——类或者接口不变量</li>
</ul>
<p><strong>缺点：</strong>有不少使用者反映这个插件不是很好用，不变量的使用不如自己手写。而且 IDEA 对这个插件不是完全兼容。</p>
<p>Sebastian Hoss 为 Java 创造了一个基于注释的库，可以支持一部分DbC 指令，</p>
<p>。。。</p>
<p>契约式编程还有许多其他广泛的应用场景，比如 <strong>.Net 语言、Ruby、JavaScript、Python、Golang</strong></p>
<h2 id="附录C-JML-表达式"><a href="#附录C-JML-表达式" class="headerlink" title="附录C JML 表达式"></a>附录C JML 表达式</h2><h3 id="原子表达式（略）"><a href="#原子表达式（略）" class="headerlink" title="原子表达式（略）"></a>原子表达式（略）</h3><ol>
<li><code>\result</code>：表示一个非 void 类型的方法执行所获得的结果，即方法执行后的返回值。</li>
<li><code>\old(expr)</code>：表示一个表达式<code>expr</code>在相应方法执行前的取值，该表达式涉及到评估<code>expr</code>中的对象是否发生变化。<br><em>如果是引用（如hashmap)，对象没改变，但进行了插入或删除操作。v和odd(v)也有相同的取值。</em></li>
<li><code>\not_assigned(x,y,...)</code>：用来表示括号中的变量是否在方法执行过程中被赋值。如果没有被赋值，返回为true ，否则返回 false 。用于后置条件的约束，限制一个方法的实现不能对列表中的变量进行赋值。</li>
<li><code>\not_modified(x,y,...)</code>：该表达式限制括号中的变量在方法执行期间的取值未发生变化。</li>
<li><code>\nonnullelements(container)</code>：表示container对象中存储的对象不会有null。</li>
<li><code>\type(type)</code>：返回类型type对应的类型(Class)，如type(boolean)为Boolean.TYPE。TYPE是JML采用的缩略表示，等同于Java中的 java.lang.Class。</li>
<li><code>\typeof(expr)</code>：该表达式返回expr对应的准确类型。如<code>\typeof(false)</code>为Boolean.TYPE。</li>
</ol>
<h3 id="量化表达式（略）"><a href="#量化表达式（略）" class="headerlink" title="量化表达式（略）"></a>量化表达式（略）</h3><ol>
<li><code>\forall</code>：全称量词修饰的表达式，表示对于给定范围内的元素，每个元素都满足相应的约束。</li>
<li><code>\exists</code>：存在量词修饰的表达式，表示对于给定范围内的元素，存在某个元素满足相应的约束。</li>
<li><code>\sum</code>：返回给定范围内的表达式的和。</li>
<li><code>\product</code>：返回给定范围内的表达式的连乘结果。</li>
<li><code>\max</code>：返回给定范围内的表达式的最大值。</li>
<li><code>\min</code>：返回给定范围内的表达式的最小值。</li>
<li><code>\num_of</code>：返回指定变量中满足相应条件的取值个数。可以写成<code>(\num_of T x; R(x);P(x))</code>，其中T为变量x的类型，R(x)为x的取值范围；P(x)定义了x需要满足的约束条件。从逻辑上来看，该表达式也等价于<code>(\sum T x;R(x)&amp;&amp;P(x);1)</code>。</li>
</ol>
<h3 id="集合表达式（略）"><a href="#集合表达式（略）" class="headerlink" title="集合表达式（略）"></a>集合表达式（略）</h3><p>可以在JML规格中构造一个局部的集合（容器），明确集合中可以包含的元素。集合构造表达式的一般形式为：<code>new ST {T x|R(x)&amp;&amp;P(x)}</code>，其中的R(x)对应集合中x的范围，通常是来自于某个既有集合中的元素，如s.has(x)，P(x)对应x取值的约束。</p>
<h3 id="操作符（略）"><a href="#操作符（略）" class="headerlink" title="操作符（略）"></a>操作符（略）</h3><ul>
<li><code>E1&lt;:E2</code>子类型操作符：如果类型E1是类型E2的子类型(sub type)或相同类型，则该表达式的结果为真，否则为假。任意一个类X，都必然满足<code>X.TYPE&lt;:Object.TYPE</code>。</li>
<li><code>b_expr1&lt;==&gt;b_expr2</code>或<code>b_expr1&lt;=!=&gt;b_expr2</code>等价关系操作符：其中b_expr1和b_expr2都是布尔表达式。</li>
<li><code>b_expr1==&gt;b_expr2</code>或<code>b_expr1&lt;==b_expr2</code>推理操作符：相当于离散的-&gt;，只有（1，0）是false。</li>
<li><code>\nothing</code>或<code>\everthing</code>变量引用操作符：表示当前作用域访问的所有变量。前者空集，后者全集。变量引用操作符经常在<code>assignable</code>句子中使用，如 <code>assignable \nothing</code>表示当前作用域下每个变量都不可以在方法执行过程中被赋值。</li>
</ul>
]]></content>
      <tags>
        <tag>BUAA_OO</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/05/22/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>title</title>
    <url>/2022/05/22/title/</url>
    <content><![CDATA[<h1 id="dkfadf"><a href="#dkfadf" class="headerlink" title="dkfadf"></a>dkfadf</h1><p>title</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="12.262ex" height="2.059ex" role="img" focusable="false" viewBox="0 -705 5420 910"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(361,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(827,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(1296,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(1657,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mi" transform="translate(2207,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(2692,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(3143,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(4021,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(4593,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(4891,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g></g></g></svg></mjx-container></p>
]]></content>
      <categories>
        <category>工具</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>BUAA_OS Lab5-2-Extra</title>
    <url>/2022/06/09/BUAA-OS-Lab5-2-Extra/</url>
    <content><![CDATA[<p>一开始没过，补题过了</p>
<span id="more"></span>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fsipc.c</span><br><span class="line"><span class="number">151</span> <span class="type">int</span> <span class="title function_">fsipc_dirlist</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * path, <span class="type">char</span> * bans)</span> &#123;</span><br><span class="line"><span class="number">152</span>     <span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_dirlist</span> * <span class="title">req</span>;</span></span><br><span class="line"><span class="number">153</span>     <span class="keyword">if</span> (<span class="built_in">strlen</span>(path) &gt; MAXPATHLEN) <span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line"><span class="number">154</span>     req = (<span class="keyword">struct</span> Fsreq_dirlist *)fsipcbuf;</span><br><span class="line"><span class="number">155</span>     <span class="built_in">strcpy</span>((<span class="type">char</span> *)req -&gt; req_path, path);</span><br><span class="line"><span class="number">156</span>     <span class="comment">//req -&gt; ans = 0x0ffff000 + MAXPATHLEN + 4;</span></span><br><span class="line"><span class="number">157</span>     <span class="type">int</span> dstva = <span class="number">0x0ffff000</span>;</span><br><span class="line"><span class="number">158</span>     <span class="type">int</span> perm = PTE_V | PTE_R | PTE_LIBRARY;</span><br><span class="line"><span class="number">159</span>     fsipc(FSREQ_DIRLIST, req, <span class="number">0</span>, &amp;perm);</span><br><span class="line"><span class="number">160</span>     <span class="comment">//writef(&quot;received\n&quot;);</span></span><br><span class="line"><span class="number">161</span>     req = (<span class="keyword">struct</span> Fsreq_dirlist *)fsipcbuf;</span><br><span class="line"><span class="number">162</span>     user_bcopy(&amp;(req -&gt; ans), bans, req -&gt; ans_len);</span><br><span class="line"><span class="number">163</span> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">include/fs.h</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_dirlist</span> &#123;</span></span><br><span class="line">	u_char req_path[MAXPATHLEN];</span><br><span class="line">	<span class="type">int</span> ans_len;</span><br><span class="line">	<span class="type">char</span> ans[<span class="number">1025</span>];</span><br><span class="line">&#125;;</span><br><span class="line">serv.c</span><br><span class="line"><span class="number">257</span> <span class="type">void</span> <span class="title function_">serve_dirlist</span><span class="params">(u_int envid, <span class="keyword">struct</span> Fsreq_dirlist * rq)</span> &#123;</span><br><span class="line"><span class="number">258</span>     <span class="comment">//writef(&quot;1\n&quot;);</span></span><br><span class="line"><span class="number">259</span>     <span class="class"><span class="keyword">struct</span> <span class="title">Open</span> * <span class="title">pOpen</span>;</span></span><br><span class="line"><span class="number">260</span>     <span class="type">int</span> r;</span><br><span class="line"><span class="number">261</span>     u_char path[MAXPATHLEN];</span><br><span class="line"><span class="number">262</span>     <span class="type">int</span> perm = PTE_R | PTE_V | PTE_LIBRARY;</span><br><span class="line"><span class="number">263</span>     user_bcopy(rq -&gt; req_path, path, MAXPATHLEN);</span><br><span class="line"><span class="number">264</span>     path[MAXPATHLEN - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="number">265</span>     <span class="comment">// if ((r = open_lookup(envid, rq -&gt; req_fileid, &amp;pOpen)) &lt; 0) &#123;</span></span><br><span class="line"><span class="number">266</span>     <span class="comment">//  ipc_send(envid, r, rq -&gt; ans_off, perm);</span></span><br><span class="line"><span class="number">267</span>     <span class="comment">//  return ;</span></span><br><span class="line"><span class="number">268</span>     <span class="comment">// &#125;</span></span><br><span class="line"><span class="number">269</span>     <span class="comment">//writef(&quot;1\n&quot;);</span></span><br><span class="line"><span class="number">270</span>     <span class="keyword">if</span> (r = dir_list_fs(rq -&gt; req_path,&amp;(rq -&gt; ans))) &#123;</span><br><span class="line"><span class="number">271</span>         ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="number">272</span>         <span class="keyword">return</span>;</span><br><span class="line"><span class="number">273</span>     &#125;</span><br><span class="line"><span class="number">274</span>     <span class="comment">//writef(&quot;1\n&quot;);</span></span><br><span class="line"><span class="number">275</span>     <span class="comment">//writef(&quot;%s\n&quot;, rq-&gt;ans);</span></span><br><span class="line"><span class="number">276</span>     rq -&gt; ans_len = <span class="built_in">strlen</span>(&amp;(rq -&gt; ans));</span><br><span class="line"><span class="number">277</span>     ipc_send(envid, <span class="number">0</span>, REQVA, perm);</span><br><span class="line"><span class="number">278</span> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fs.c</span><br><span class="line">fs.c</span><br><span class="line"><span class="number">570</span> <span class="type">int</span> <span class="title function_">dir_list_fs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * path, <span class="type">char</span> * ans)</span> &#123;</span><br><span class="line"><span class="number">571</span>     <span class="comment">//writef(&quot;2\n&quot;);</span></span><br><span class="line"><span class="number">572</span>     <span class="class"><span class="keyword">struct</span> <span class="title">File</span> * <span class="title">dir</span>;</span></span><br><span class="line"><span class="number">573</span>     <span class="class"><span class="keyword">struct</span> <span class="title">File</span> * <span class="title">file</span>;</span></span><br><span class="line"><span class="number">574</span>     walk_path(path, <span class="literal">NULL</span>, &amp;dir, <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">575</span>     <span class="comment">//writef(&quot;3\n&quot;);</span></span><br><span class="line"><span class="number">576</span>     <span class="type">int</span> r;</span><br><span class="line"><span class="number">577</span>     u_int i, j, nblock;</span><br><span class="line"><span class="number">578</span>     <span class="type">void</span> *blk;</span><br><span class="line"><span class="number">579</span>     <span class="class"><span class="keyword">struct</span> <span class="title">File</span> * <span class="title">f</span>;</span></span><br><span class="line"><span class="number">580</span>     <span class="type">char</span> * ptrc = ans;</span><br><span class="line"><span class="number">581</span>     nblock = ROUND(dir -&gt; f_size, BY2BLK) / BY2BLK;</span><br><span class="line"><span class="number">582</span>     <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nblock; i++) &#123;</span><br><span class="line"><span class="number">583</span>         <span class="keyword">if</span> ((r = file_get_block(dir, i, &amp;blk))) <span class="keyword">return</span> r;</span><br><span class="line"><span class="number">584</span>         <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; FILE2BLK; j++) &#123;</span><br><span class="line"><span class="number">585</span>             f = ((<span class="keyword">struct</span> File *)blk) + j;</span><br><span class="line"><span class="number">586</span>             <span class="keyword">if</span> (f -&gt; f_name[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line"><span class="number">587</span>                 <span class="comment">//writef(&quot;%s\n&quot;, f-&gt;f_name);</span></span><br><span class="line"><span class="number">588</span>                 <span class="comment">//strcpy(ptrc, f -&gt; f_name);</span></span><br><span class="line"><span class="number">589</span>                 <span class="comment">//writef(&quot;ans = %x\n&quot;, ans);</span></span><br><span class="line"><span class="number">590</span>                 user_bcopy(f -&gt; f_name, ptrc, <span class="built_in">strlen</span>(f -&gt; f_name));</span><br><span class="line"><span class="number">591</span>                 ptrc += <span class="built_in">strlen</span>(f -&gt; f_name);</span><br><span class="line"><span class="number">592</span>                 *ptrc = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="number">593</span>                 ptrc++;</span><br><span class="line"><span class="number">594</span>                 <span class="comment">//writef(&quot;234234\n&quot;);</span></span><br><span class="line"><span class="number">595</span>             &#125;</span><br><span class="line"><span class="number">596</span>         &#125;</span><br><span class="line"><span class="number">597</span>     &#125;</span><br><span class="line"><span class="number">598</span>     *ptrc = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="number">599</span>     <span class="comment">//writef(&quot;fini\n&quot;);</span></span><br><span class="line"><span class="number">600</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">601</span> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>BUAA_OS</tag>
      </tags>
  </entry>
  <entry>
    <title>Lab5 掰开揉碎</title>
    <url>/2022/06/08/BUAA-OS/</url>
    <content><![CDATA[<p>安得广厦千万间</p>
<span id="more"></span>
<h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><h3 id="include-fs-h"><a href="#include-fs-h" class="headerlink" title="include/fs.h"></a><code>include/fs.h</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BY2BLK		BY2PG	<span class="comment">// 一个块有多少个字节,这里定义为一个页,</span></span></span><br><span class="line">							<span class="comment">// 说明一个块大小为4096B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIT2BLK		(BY2BLK*8)	<span class="comment">// 一个块有多少个字(bit),是一个块字节*8</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXNAMELEN	128 <span class="comment">// 文件名长度最多128个字符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXPATHLEN	1024 <span class="comment">// 文件路径长度最多1024个字符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDIRECT		10 <span class="comment">// 直接文件的块指针有10个</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NINDIRECT	(BY2BLK/4) <span class="comment">// 间接文件快指针最多有1024个</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFILESIZE	(NINDIRECT*BY2BLK) <span class="comment">// 文件最大大小是1024*4KB=4MB</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BY2FILE     256 <span class="comment">// 一个File结构体的大小是256B</span></span></span><br></pre></td></tr></table></figure>
<h3 id="fs-fs-h"><a href="#fs-fs-h" class="headerlink" title="fs/fs.h"></a><code>fs/fs.h</code></h3><h3 id="user-fd-h"><a href="#user-fd-h" class="headerlink" title="user/fd.h"></a><code>user/fd.h</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFD 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILEBASE 0x60000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDTABLE (FILEBASE - PDMAP) <span class="comment">// PDMAP = 4 * 1024 * 1024</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INDEX2FD(i) (FDTABLE + (i) * BY2PG)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INDEX2DATA(i) (FILEBASE + (i) * PDMAP</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DEV 结构体</span></span><br><span class="line"><span class="comment">// Device struct:</span></span><br><span class="line"><span class="comment">// It is used to read and write data from corresponding device.</span></span><br><span class="line"><span class="comment">// We can use the five functions to handle data.</span></span><br><span class="line"><span class="comment">// There are three devices in this OS: file, console and pipe.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> {</span></span><br><span class="line">	<span class="type">int</span> dev_id;</span><br><span class="line">	<span class="type">char</span> *dev_name;</span><br><span class="line">	<span class="type">int</span> (*dev_read)(<span class="keyword">struct</span> Fd *, <span class="type">void</span> *, u_int, u_int);</span><br><span class="line">	<span class="type">int</span> (*dev_write)(<span class="keyword">struct</span> Fd *, <span class="type">const</span> <span class="type">void</span> *, u_int, u_int);</span><br><span class="line">	<span class="type">int</span> (*dev_close)(<span class="keyword">struct</span> Fd *);</span><br><span class="line">	<span class="type">int</span> (*dev_stat)(<span class="keyword">struct</span> Fd *, <span class="keyword">struct</span> Stat *);</span><br><span class="line">	<span class="type">int</span> (*dev_seek)(<span class="keyword">struct</span> Fd *, u_int);</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Devise 结构体用于针对特定的设备进行读写数据。其中包含了 5 个方法。在MOS中，有 3 个设备。分别是 file、console和 pipe</p>
<p>感觉这个结构体的定义非常像接口</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件描述符</span></span><br><span class="line"><span class="comment">// file descriptor</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> {</span></span><br><span class="line">	u_int fd_dev_id;</span><br><span class="line">	u_int fd_offset;</span><br><span class="line">	u_int fd_omode;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// State</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stat</span> {</span></span><br><span class="line">	<span class="type">char</span> st_name[MAXNAMELEN];</span><br><span class="line">	u_int st_size;</span><br><span class="line">	u_int st_isdir;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> *<span class="title">st_dev</span>;</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file descriptor + file</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> {</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> <span class="title">f_fd</span>;</span></span><br><span class="line">	u_int f_fileid;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">f_file</span>;</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="include-fs-h-1"><a href="#include-fs-h-1" class="headerlink" title="include/fs.h"></a><code>include/fs.h</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> {</span></span><br><span class="line">	u_char f_name[MAXNAMELEN];	<span class="comment">// filename</span></span><br><span class="line">	u_int f_size;			<span class="comment">// file size in bytes</span></span><br><span class="line">	u_int f_type;			<span class="comment">// file type</span></span><br><span class="line">	u_int f_direct[NDIRECT];</span><br><span class="line">	u_int f_indirect;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f_dir</span>;</span>		<span class="comment">// the pointer to the dir where this file is in, valid only in memory.</span></span><br><span class="line">	u_char f_pad[BY2FILE - MAXNAMELEN - <span class="number">4</span> - <span class="number">4</span> - NDIRECT * <span class="number">4</span> - <span class="number">4</span> - <span class="number">4</span>];</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<p>这是一个File结构体,包含文件名,文件大小(字节为单位),文件类型(只有普通文件和文件夹类型)</p>
<p>进一步定义一个块中可以有多少个文件呢？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FILE2BLK (BY2BLK/sizeof(struct File)) <span class="comment">// 因为一个磁盘块的大小是4096B，一个File结构体的大小是256B所以一个磁盘块中可以有16个File结构体</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FTYPE_REG 0<span class="comment">//常规文件类型File</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FTYPE_DIR 1<span class="comment">//文件夹类型FIle</span></span></span><br></pre></td></tr></table></figure>
<p>进一步在文件中定义OS魔数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FS_MAGIC 0x68286097</span></span><br></pre></td></tr></table></figure>
<p>和Super结构体，Super结构体占一个磁盘块 4096B</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Super</span> {</span></span><br><span class="line">	u_int s_magic;		<span class="comment">// Magic number: FS_MAGIC</span></span><br><span class="line">	u_int s_nblocks;	<span class="comment">// Total number of blocks on disk</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">s_root</span>;</span>	<span class="comment">// Root directory node</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h2 id="fs-fsformat-c"><a href="#fs-fsformat-c" class="headerlink" title="fs/fsformat.c"></a><code>fs/fsformat.c</code></h2><blockquote>
<p>指导书的描述：这个文件的功能是创建磁盘镜像</p>
</blockquote>
<h3 id="头文件引用"><a href="#头文件引用" class="headerlink" title="头文件引用"></a>头文件引用</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>从头文件可以看出来，这个文件不是我们系统内的文件，而是Linux本身的文件。</p>
<p>fsformat文件的功能是创建磁盘镜像。在这个文件里面，就初始化了1024个Block结构体（称为disk[]）。相当于磁盘有多少个块，每个磁盘块的大小是4096B。根据指导书的描述，磁盘块是一个虚拟概念。在磁盘中，扇区是一个真实的概念，磁盘中确实有扇区，但是没有磁盘块。一个扇区一般512B。所以在咱们的设计中一个磁盘块包含8个扇区。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block</span> {</span></span><br><span class="line">    <span class="type">uint8_t</span> data[BY2BLK];</span><br><span class="line">    <span class="type">uint32_t</span> type;</span><br><span class="line">} disk[NBLOCK];</span><br></pre></td></tr></table></figure>
<h4 id="disk-init函数"><a href="#disk-init函数" class="headerlink" title="disk_init函数"></a>disk_init函数</h4><p>这个函数是main函数中第一个调用的函数。用于磁盘的设置。</p>
<ul>
<li>设置第0块的磁盘块类型：<code>BLOCK_BOOT</code></li>
<li>接下来初始化磁盘块位图。磁盘是一个比较大的空间，管理这个空间有很多种方法。在虚拟内存物理内存管理的时候我们使用的是链表法，但是介绍过位图法，往年内存管理部分也考过位图法。今年的文件处理（磁盘中）使用位图法管理磁盘的每个块。在位图法中，一位代表一块。首先根据磁盘的总块数确定需要多少个位来管理这些块；进一步，位图也需要保存在磁盘中，所以需要计算出位图需要占用几个磁盘块（这里应该使用向上取整），位图开始于第二次磁盘块disk[2]。例如需要1.2个块或者3.5个块，就要分配给位图2个块或者4个块。位图不见得占用分配的磁盘块的所有空间，所以需要将没有占用的部分舍弃掉。在位图的使用中，用1代表磁盘块的空闲；0代表磁盘块使用。</li>
<li>初始化完位图之后，需要初始化super块，它设置在第1块磁盘块disk[1]的位置。在这个函数中，我们先将内容保存到super结构体中，包括磁盘魔数、总磁盘块个数、根目录文件类型和文件名”/“等。super块的内容最后会写到磁盘中，在这里可能是为了存取方便。</li>
</ul>
<h4 id="next-block"><a href="#next-block" class="headerlink" title="next_block"></a>next_block</h4><p>接受一个type，返回当前空闲的磁盘块号。它的作用是分配一个磁盘块，并且将这个磁盘块的类型设置为type。全局变量nextbno记录了当前分配到哪个磁盘块了</p>
<h4 id="save-block-link"><a href="#save-block-link" class="headerlink" title="save_block_link"></a>save_block_link</h4><p>这个函数传入一个文件结构体指针（<code>struct File * f</code>），一个文件中块指针号(<code>int nblk</code>)和磁盘块号（<code>int bno</code>）。这个函数的作用是将一个磁盘块号（bno）对应的磁盘块和文件的某个磁盘指针（<code>f_direct[nblk]</code> 或者 <code>(disk[f_indirect].data)[nblk]</code>）对应起来。一个磁盘块的大小很有可能超过一个磁盘块大小（4KB），文件结构体中保存了10个直接指针（保存磁盘块号），如果10个不够用，可以申请且仅能申请一个空白的块专门用来存储间接的磁盘块号（其中这里的每个磁盘块号对应的磁盘存储着文件的内容）。</p>
<h4 id="make-link-block"><a href="#make-link-block" class="headerlink" title="make_link_block"></a>make_link_block</h4><p>传入：一个文件结构体指针（<code>struct File * dirf</code>），一个块指针号（<code>int nblk</code>）。</p>
<p>传出：分配的磁盘块号（<code>int bno</code>）</p>
<p>在这个函数中首先进行磁盘块的分配（next_block），然后将新分配出来的磁盘块号对应到文件结构体中的块指针（nblk）使用sava_block_link。并且将这个文件的大小相应的增加BY2PG，最后返回分配的磁盘块号。这个函数和上面的函数的区别是，这个函数不确定当前需要给文件对应哪个磁盘块好，主要功能是给文件增加一页空间。但是上面的函数需要确定哪一页放到哪里，要求更高。（<strong>缺陷：</strong>这个函数没有判定nblk对应的位置是否已经有一个磁盘块；也没确定nblk是不是在文件大小之内，就是说有可能nblk前面的指针还没分配呢，后面的指针先分配的问题。<strong>需要看看调用的时候是否解决这个问题</strong>）</p>
<h4 id="create-file"><a href="#create-file" class="headerlink" title="create_file"></a>create_file</h4><p>传入：一个文件结构体指针（<code>struct File * dirf</code>）</p>
<p>传出：一个文件结构体指针</p>
<p>函数的含义是在当前的文件夹下创建一个文件。先来说说如果dirf为一个文件夹。则它的直接指针和间接指针总共1024个。每个指针指向一个磁盘块。每个磁盘块的大小是4KB。一个<code>struct File</code> 结构体256B。所以一个磁盘块可以保存16个文件结构体（File 结构体）。每个File结构体代表这个文件夹下的一个文件or一个子文件夹。所以如果要在dirf这个文件夹内创造文件，就是找到一个内部的文件结构体就完事了。所以首先得到dirf目前用了多少个直接指针和间接指针了（nblk）；进一步遍历每个指针所指的磁盘块；在磁盘块中，遍历所有的File结构体，如果某个File结构体对应的name为空（说明这个文件结构体没用），就把这个文件结构体作为承载新文件的地址。如果遍历了当前文件夹所有的指针，都没有空闲的File结构体，则需要分配一个新的文件指针，因为是新分配的，所以这个磁盘块的第一个File结构体肯定是没被用过的，所以返回<code>(struct File *)disk[bno].data</code>。</p>
<h4 id="write-file"><a href="#write-file" class="headerlink" title="write_file"></a>write_file</h4><p>传入：一个文件结构指针（<code>struct File * dirf</code>），一个文件路径（<code>const char * path</code>）</p>
<p>函数的功能是在特定的文件夹下把文件写入磁盘。首先，需要使用系统调用打开path对应的文件。然后使用create_file在dirf文件夹中创建一个文件（文件结构体指针为target），然后使用不断将文件中的内容写入到target中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>((r = read(fd, disk[nextbno].data, n)) &gt; <span class="number">0</span>) {</span><br><span class="line">    save_block_link(target, iblk++, next_block(BLOCK_DATA));</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这里iblk从0开始，next_block函数对nextbno进行更新，确保每次使用read的时候可以将文件中的数据正确的写入nextbno对应的磁盘块中，然后使用save_block_link将iblk于nextbno对应的块进行连接。</p>
<h4 id="flush-bitmap"><a href="#flush-bitmap" class="headerlink" title="flush_bitmap"></a>flush_bitmap</h4><p>无传入传出。这个函数的功能是将nextbno之前的磁盘块都标记成已经使用过（在位图块中标记）。由于之间的各种分配和使用磁盘块都没有设置位图，所以这里可以统一将之前的位图都标记为正在使用（对应的位为0）</p>
<p><strong>可以加入一些图片和代码帮助理解</strong></p>
<h4 id="finish-fs"><a href="#finish-fs" class="headerlink" title="finish_fs"></a>finish_fs</h4><p>传入：待写入文档的名字（<code>char * name</code>）</p>
<p>无传出。</p>
<p>首先将super存到第一个磁盘块中（disk[1]）。然后打开name对应的文件，将大小端调整好（因为fsformat文件不是在MOS系统上运行的，之前也说过，直接运行的系统采用的小端存取，而MIPS对应的MOS使用大端存取，所以要调整大小端），将每个磁盘的内容存到文件中，这个文件就相当于磁盘了。<strong>注意：</strong>这里存回去的时候，存入的是<code>disk[i].data</code>，这部分的大小是4KB，然而一个Block结构体的大小是4096+4B。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd = open(name, O_RDWR|O_CREAT, <span class="number">0666</span>);</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; ++i) {</span><br><span class="line">    reverse_block(disk+i);</span><br><span class="line">    write(fd, disk[i].data, BY2BLK);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="reverse-block-amp-amp-reverse"><a href="#reverse-block-amp-amp-reverse" class="headerlink" title="reverse_block && reverse"></a>reverse_block &amp;&amp; reverse</h4><p>自己来吧，一看就会</p>
<h4 id="main"><a href="#main" class="headerlink" title="main"></a>main</h4><p>传入：argc（指示传入参数个数），传入的参数数组（<code>char ** argv</code>）</p>
<p>这就是完整的创建磁盘镜像过程：首先初始化磁盘（init_disk）。这里需要先介绍一下，创建的磁盘文件只支持创建包含一堆文件的磁盘镜像或者一个文件夹的磁盘镜像。</p>
<p>如果需要创建带有文件夹的磁盘镜像，则创建出的磁盘在根目录下有<strong>一个</strong>文件夹（使用write_directory，<strong>注意：</strong>虽然从代码上看是使用了一个for循环，好像出创建一堆文件夹，但是实际上如果使用创建文件夹的模式，argc只能为4，说明只能创建一个文件夹）；如果不是创建文件夹的模式，则创建出来的磁盘镜像在根目录下有很多的文件（使用write_file）。</p>
<p>然后更新bitmap（flush_bitmap）；完成磁盘创建（<code>finish_fs(argv[1])</code>）<strong>注意：</strong>使用的时候<code>argv[1]</code>为<code>gxemul/fs.img</code>，即为磁盘的名字。</p>
<h2 id="fs-Makefile"><a href="#fs-Makefile" class="headerlink" title="fs/Makefile"></a><code>fs/Makefile</code></h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">FSIMGFILES := motd newmotd</span><br><span class="line"><span class="section">fs.img: <span class="variable">$(FSIMGFILES)</span></span></span><br><span class="line">	dd if=/dev/zero of=../gxemul/fs.img bs=4096 count=1024 2&gt;dev/null</span><br></pre></td></tr></table></figure>
<p><strong>见强哥的解析</strong>，我就不班门弄斧了</p>
<h2 id="块缓存"><a href="#块缓存" class="headerlink" title="块缓存"></a>块缓存</h2><p>文件服务进程是一个单独的进程（用户进程），每个进程有4GB的空间。在这4GB空间中，拿出来1GB（大小0x40000000）单独作为存储磁盘块的存储缓存。从磁盘读入内存时，就是先把数据保存到缓存区，然后其他用户进程如果需要，也是从缓存区读取数据，不会单独读取数据。这段空间从0x10000000到0x50000000，共1GB。当把一个磁盘块载入内存时，需要为之分配空间；结束使用这个磁盘块的时候需要将磁盘块写回磁盘，并且释放对应的物理内存。<code>fs/fs.c</code> 中的<code>map_block</code>函数和<code>unmap_block</code>函数实现了这一功能。</p>
<p>read_block 函数和 write_block 函数用于读写磁盘块。read_block 函数将指定编号的磁盘块读入到内存中，首先检查这块磁盘块是否已经在内存中，如果不在，先分配一页物理内存，<strong>然后调用 <code>ide_read</code>函数来读取磁盘上的数据到对应的虚存地址处</strong>。</p>
<p><strong><code>file_get_block</code>函数用于将某个指定的文件指向的磁盘块读入内存</strong>。其主要分为 2 个步骤：首先为即将读入内存的磁盘块分配物理内存，然后使用<code>read_block</code>函数将磁盘内容以块为单位读入内存中的相应位置。这两个步骤对应的函数都借助了系统调用来完成。</p>
<h2 id="fs-fs-c"><a href="#fs-fs-c" class="headerlink" title="fs/fs.c"></a><code>fs/fs.c</code></h2><h4 id="头文件和宏定义"><a href="#头文件和宏定义" class="headerlink" title="头文件和宏定义"></a>头文件和宏定义</h4><p>先来看看<code>fs/fs.h</code>中的宏定义。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DISKNO 1		<span class="comment">// ide磁盘号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BY2SECT 512		<span class="comment">// 扇区大小512B</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECT2BLK (BY2BLK/BY2SECT) <span class="comment">// 一个块有几个扇区 4096/512 = 8个扇区</span></span></span><br></pre></td></tr></table></figure>
<h4 id="diskaddr"><a href="#diskaddr" class="headerlink" title="diskaddr"></a>diskaddr</h4><p>传入：磁盘块的编号（<code>int blockno</code>）</p>
<p>传出：编号对应的，在块缓存区的磁盘块基地址va。</p>
<p>这里需要介绍一下块缓存机制。缓存区可以缓存1GB的大小，相当于262144个磁盘块。远远大于正常磁盘中的磁盘块个数。所以在缓存区内，磁盘块和缓存的地方是一一映射的。所以通过blockno到va是线性映射的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> addr = blockno * BY2BLK + DISKMAP;</span><br></pre></td></tr></table></figure>
<h4 id="va-is-mapped"><a href="#va-is-mapped" class="headerlink" title="va_is_mapped"></a>va_is_mapped</h4><p>传入：虚拟地址va</p>
<p>传出：是否映射（0/1）</p>
<p>函数的功能是判断va地址是否被映射到某个物理页面。由于文件系统服务进程也是用户进程，所以需要逐级查找页表确定。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> (((*vpd)[PDX(va)] &amp; (PTE_V)) &amp;&amp; ((*vpt)[VPN(va)] &amp; (PTE_V)));</span><br></pre></td></tr></table></figure>
<h4 id="block-is-mapped"><a href="#block-is-mapped" class="headerlink" title="block_is_mapped"></a>block_is_mapped</h4><p>传入：磁盘块的编号（<code>int blockno</code>）</p>
<p>传出：是否映射（0/1）</p>
<p>函数的功能是判断某个磁盘块对应的、在缓存中的虚拟地址是否映射到某个物理地址，方法就是获得va、在调用va_is_mapped</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u_int va = diskaddr(blockno);</span><br><span class="line"><span class="keyword">if</span> (va_is_mapped(va)) {</span><br><span class="line">    <span class="keyword">return</span> va;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="va-is-dirty"><a href="#va-is-dirty" class="headerlink" title="va_is_dirty"></a>va_is_dirty</h4><p>传入：虚拟地址va</p>
<p>传出：是否脏（0/1）</p>
<p>检查va对应的虚拟地址是否是写过的（dirty）的。同样是查页表的PTE_DIRTY位。<strong>注意：</strong>这里没有检查PTE_V，不确定是否有错</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> (* vpt)[VPN(va)] &amp; PTE_D;</span><br></pre></td></tr></table></figure>
<h4 id="block-is-dirty"><a href="#block-is-dirty" class="headerlink" title="block_is_dirty"></a>block_is_dirty</h4><p>传入：磁盘块的编号（<code>int blockno</code>）</p>
<p>传出：是否脏（0/1）</p>
<p>检查磁盘块对应的虚拟地址是不是脏的。<strong>注意：</strong>在这里检查了是否已经map</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u_int va = diskaddr(blockno);</span><br><span class="line"><span class="keyword">return</span> va_is_mapped(va) &amp;&amp; va_is_dirty(va);</span><br></pre></td></tr></table></figure>
<h4 id="map-block"><a href="#map-block" class="headerlink" title="map_block"></a>map_block</h4><p>传入：磁盘块的编号（<code>int blockno</code>）</p>
<p>传出：返回分配物理空间的返回值</p>
<p>当磁盘中的磁盘块载入文件服务进程的时候，需要在缓存区中给磁盘块分配物理空间，存储磁盘块。当磁盘块不需要使用的时候，将对应的缓存器的磁盘块内容写回磁盘块，并且取消掉磁盘块对应空间的物理页面。map_block就是给磁盘块的缓存地址分配空间。因此需要知道编号为blockno的磁盘块将会缓存到文件服务进程的哪个位置；然后分配好空间。<strong>注意：</strong>分配空间需要使用系统调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> va = diskaddr(blockno);</span><br><span class="line"><span class="type">int</span> perm = PTE_R | PTE_V;<span class="comment">//这里不需要使用LIBRARY因为共享的权限是文件服务进程给的，这里也不需要fork所以不用</span></span><br><span class="line"><span class="type">int</span> r = syscall_mem_alloc(<span class="number">0</span>, va, perm);</span><br></pre></td></tr></table></figure>
<h4 id="unmap-block"><a href="#unmap-block" class="headerlink" title="unmap_block"></a>unmap_block</h4><p>传入：磁盘块的编号（<code>int blockno</code>）</p>
<p>接触某个磁盘块在缓存区的物理空间，并且如果这个block不是free而且dirty了，就将磁盘块中的新值写回磁盘（write_block）。最后使用系统调用取消掉物理页的映射。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> isfree = block_is_free(blockno);</span><br><span class="line"><span class="type">int</span> isdirty = block_is_dirty(blockno);</span><br><span class="line"><span class="keyword">if</span> (!isfree &amp;&amp; isdirty) {</span><br><span class="line">    write_block(blockno);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// Step 3: use 'syscall_mem_unmap' to unmap corresponding virtual memory.</span></span><br><span class="line"><span class="type">int</span> va = diskaddr(blockno);</span><br><span class="line"><span class="keyword">if</span> ((r = syscall_mem_unmap(<span class="number">0</span>, va)))</span><br><span class="line">    user_panic(<span class="string">"unmap_block: syscall_mem_unmap err\n"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="read-block"><a href="#read-block" class="headerlink" title="read_block"></a>read_block</h4><p>传入：磁盘块的编号（<code>int blockno</code>）</p>
<p>传出：是否成功（return）、磁盘块在缓存空间的虚拟地址（<code>void ** blk</code>）、是否是刚刚载入到缓存区（<code>u_int * isnew</code>）</p>
<p>如果调用这个函数的时候已经将磁盘块保存在缓存空间中了，则isnew为0；否则isnew为1，而且需要先为这个地址映射一个物理页面，再读取磁盘中的数据到这个位置（ide_read）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (block_is_mapped(blockno)) {	<span class="comment">// the block is in memory</span></span><br><span class="line">    <span class="keyword">if</span> (isnew) {</span><br><span class="line">        *isnew = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">} <span class="keyword">else</span> {			<span class="comment">// the block is not in memory</span></span><br><span class="line">    <span class="keyword">if</span> (isnew) {</span><br><span class="line">        *isnew = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    syscall_mem_alloc(<span class="number">0</span>, va, PTE_V | PTE_R);</span><br><span class="line">    ide_read(<span class="number">0</span>, blockno * SECT2BLK, (<span class="type">void</span> *)va, SECT2BLK);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (blk) *blk = (<span class="type">void</span> *)va;</span><br></pre></td></tr></table></figure>
<h4 id="write-block"><a href="#write-block" class="headerlink" title="write_block"></a>write_block</h4><p>传入：磁盘块的编号（<code>int blockno</code>）</p>
<p>使用ide_write把磁盘块写回到磁盘中，最后使用系统调用（syscall_mem_map）更新页面的权限位</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">va = diskaddr(blockno);</span><br><span class="line">ide_write(<span class="number">0</span>, blockno * SECT2BLK, (<span class="type">void</span> *)va, SECT2BLK);</span><br><span class="line">syscall_mem_map(<span class="number">0</span>, va, <span class="number">0</span>, va, (PTE_V | PTE_R | PTE_LIBRARY));</span><br></pre></td></tr></table></figure>
<p><strong>这里为啥map了</strong></p>
<h4 id="block-is-free"><a href="#block-is-free" class="headerlink" title="block_is_free"></a>block_is_free</h4><p>传入：磁盘块的编号（<code>int blockno</code>）</p>
<p>通过查阅bitmap确定这个块是否是free的</p>
<h4 id="free-block"><a href="#free-block" class="headerlink" title="free_block"></a>free_block</h4><p>传入：磁盘块的编号（<code>int blockno</code>）</p>
<p>把磁盘块编号的磁盘在bitmap中设置为free</p>
<h4 id="alloc-block-num"><a href="#alloc-block-num" class="headerlink" title="alloc_block_num"></a>alloc_block_num</h4><p>传出：一个free的磁盘块的编号</p>
<p>从磁盘号为3开始查找如果找到一个磁盘块为free，将其设置为不free，并且返回它的磁盘号；</p>
<h4 id="alloc-block——封装函数"><a href="#alloc-block——封装函数" class="headerlink" title="alloc_block——封装函数"></a>alloc_block——封装函数</h4><p>传出：分配好的磁盘块的编号</p>
<p>使用alloc_block_num找到一个free的磁盘块，然后使用map_block给这个磁盘块分派一下物理空间，最后返回这个磁盘块的编号。</p>
<p><strong>相当于包装了一下map_block，现在直接调用这个函数就能获得一个准备好的磁盘块</strong></p>
<h4 id="read-super"><a href="#read-super" class="headerlink" title="read_super"></a>read_super</h4><p>从磁盘中读取super块</p>
<h4 id="read-bitmap"><a href="#read-bitmap" class="headerlink" title="read_bitmap"></a>read_bitmap</h4><p>从磁盘中读取bitmap块</p>
<h4 id="check-write-block"><a href="#check-write-block" class="headerlink" title="check_write_block"></a>check_write_block</h4><p>存取一下super块看看能不能用</p>
<h4 id="fs-init"><a href="#fs-init" class="headerlink" title="fs_init"></a>fs_init</h4><p>初始化文件系统进程。先读super块，检查一下能不能用，在读bitmap</p>
<h4 id="file-block-walk"><a href="#file-block-walk" class="headerlink" title="file_block_walk"></a>file_block_walk</h4><p>传入：文件结构体指针（<code>struct File * f</code>），文件直接or间接指针号（<code>int filebno</code>），如果需要间接指针是否分配物理页(<code>int alloc</code>)</p>
<p>传出：返回值（return），文件直接or间接磁盘号的指针（<code>u_int ** ppdiskbno</code>）</p>
<p>获得f文件中直接or间接指针中的对应的磁盘号的地址保存到ppdiskbno中，使得<code>**ppdiskbno = bno</code></p>
<h4 id="file-map-block"><a href="#file-map-block" class="headerlink" title="file_map_block"></a>file_map_block</h4><p>传入：文件结构体指针（<code>struct File * f</code>），文件直接or间接指针号（<code>int filebno</code>），是否创建（<code>u_int alloc</code>）</p>
<p>传出：返回值成功与否（return），文件直接or间接磁盘号的指针（<code>int * diskbno</code>）</p>
<p><strong>file_block_walk只有一个查询的功能，查询文件中对应的位置是否有一个直接or间接指针</strong>，但是这个函数需要实打实的分配一个空间，如果alloc为1，那么f文件的filebno这个位置一定会指向一个磁盘块。如果本身这个位置指向一个磁盘块的话，就不用再指向了。</p>
<h4 id="file-clear-block"><a href="#file-clear-block" class="headerlink" title="file_clear_block"></a>file_clear_block</h4><p>传入：文件结构体指针（<code>struct File * f</code>），文件直接or间接指针号（<code>int filebno</code>）</p>
<p>传出：返回值成功与否（return）</p>
<p>file_block_walk看看这个文件f中的filebno这个号的指针里面存的值。如果不是0，就将其设置为0，并且将这指向的块free掉。<strong>这里没有用syscall_unmap去掉物理页映射</strong></p>
<h4 id="file-get-block"><a href="#file-get-block" class="headerlink" title="file_get_block"></a>file_get_block</h4><p>传入：文件结构体指针（<code>struct File * f</code>），文件直接or间接指针号（<code>int filebno</code>）</p>
<p>传出：返回值成功与否（return），块的虚拟地址（<code>void ** blk</code>）</p>
<p>先用file_block_walk获得文件f中的filebno号指针存的磁盘块号，然后再用read_block把这个磁盘号对应的虚拟地址保存到blk中（<code>*blk  = (void *)va</code>）<strong>注意：</strong>文件file对应的磁盘块可能已经在缓存区中了，但是f指向的各个磁盘块可能还不在缓存区中。</p>
<h4 id="file-dirty"><a href="#file-dirty" class="headerlink" title="file_dirty"></a>file_dirty</h4><p>传入：文件结构体指针（<code>struct File * f</code>），文件中偏移量（offset）</p>
<p>把文件中偏移量为offset的磁盘块标记为dirty</p>
<h4 id="dir-lookup—没时间了，不细致写了"><a href="#dir-lookup—没时间了，不细致写了" class="headerlink" title="dir_lookup—没时间了，不细致写了"></a>dir_lookup—没时间了，不细致写了</h4><p>传入：<code>(struct File *dir, char *name, struct File **file)</code></p>
<p>在dir文件夹中查找名为name的文件or文件夹，如果找到了则令<code>*file</code>指向这个文件（这个文件的虚拟地址）</p>
<h4 id="dir-alloc-file"><a href="#dir-alloc-file" class="headerlink" title="dir_alloc_file"></a>dir_alloc_file</h4><p>传入：</p>
<p>在dir文件夹中找到一个空的文件控制块（遍历dir的每个直接or间接指针找到“外接”磁盘块，再在磁盘块中遍历File，找空的File结构体），如果找到了则<code>*file</code>指向这个虚拟地址；如果遍历完都没找到，则分配一个新的</p>
<h4 id="skip-slash"><a href="#skip-slash" class="headerlink" title="skip_slash"></a>skip_slash</h4><p>跳过当前位置开始的<code>/</code></p>
<h4 id="walk-path"><a href="#walk-path" class="headerlink" title="walk_path"></a>walk_path</h4><p>传入：<code>(char *path, struct File **pdir, struct File **pfile, char *lastelem)</code></p>
<p>从根目录开始找，沿着path中的路径一路找下去，直到最后的文件，如果找到了则</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (pdir) {</span><br><span class="line">    *pdir = dir;</span><br><span class="line">}</span><br><span class="line">*pfile = file;</span><br></pre></td></tr></table></figure>
<p>如果中间有一个文件夹没找到，直接返回</p>
<p>如果中间找到个File但是不是问价夹，则报错。</p>
<h4 id="file-open——封装函数"><a href="#file-open——封装函数" class="headerlink" title="file_open——封装函数"></a>file_open——封装函数</h4><p>传入：<code>(char *path, struct File **file)</code></p>
<p>封装好walk_path，找到path对应的文件。</p>
<h4 id="file-create"><a href="#file-create" class="headerlink" title="file_create"></a>file_create</h4><p>传入参数和上一个函数一样</p>
<p>先去找path上的文件。如果差最后一步（那个文件没有创建好），则创建一下。如果中间某个文件夹没创建好，则直接报错（因为返回的r是E_NOT_FOUND</p>
<h4 id="file-truncate"><a href="#file-truncate" class="headerlink" title="file_truncate"></a>file_truncate</h4><p>传入：<code>(struct File *f, u_int newsize)</code></p>
<p>把文件截断，并且将大于newsize的空间设为空闲</p>
<h4 id="file-set-size"><a href="#file-set-size" class="headerlink" title="file_set_size"></a>file_set_size</h4><p>传入：<code>(struct File *f, u_int newsize)</code></p>
<p>可以扩大文件大小，也可以缩小文件大小，反正设置好文件的新大小</p>
<p>把这个文件所在的目录中的所有文件整个写入磁盘中（更新）</p>
<h4 id="file-flush"><a href="#file-flush" class="headerlink" title="file_flush"></a>file_flush</h4><p>传入：<code>(struct File *f)</code></p>
<p>把这个文件中所有直接or间接引用的磁盘块写回磁盘（如果dirty，就是更新过的块）</p>
<h4 id="fs-sync"><a href="#fs-sync" class="headerlink" title="fs_sync"></a>fs_sync</h4><p>在缓存区中把整个磁盘所有更新过的块写回磁盘（dirty）</p>
<h4 id="file-close"><a href="#file-close" class="headerlink" title="file_close"></a>file_close</h4><p>传入：<code>(struct File *f)</code></p>
<p>关闭一个文件，把本文件中在缓存中的所有块写回磁盘</p>
<p>并且把整个文件所在的文件夹整个写回磁盘</p>
<h4 id="file-remove"><a href="#file-remove" class="headerlink" title="file_remove"></a>file_remove</h4><p>传入：<code>(char *path)</code></p>
<p>walk_path找到这个文件。然后截断这个文件大小为0，然后设置文件的name为0，然后把文件写入磁盘，然后把这个文件所在的文件夹写入磁盘</p>
<h2 id="fs-ide-c"><a href="#fs-ide-c" class="headerlink" title="fs/ide.c"></a><code>fs/ide.c</code></h2><blockquote>
<p>指导书中的描述：文件系统通过这个文件来和磁盘镜像进行交互</p>
</blockquote>
<h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"fs.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"lib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mmu.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ide_read</span><span class="params">(u_int diskno, u_int secno, <span class="type">void</span> *dst, u_int nsecs)</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">// 0x200: the size of a sector: 512 bytes.</span></span><br><span class="line">	<span class="type">int</span> offset_begin = secno * <span class="number">0x200</span>;</span><br><span class="line">	<span class="type">int</span> offset_end = offset_begin + nsecs * <span class="number">0x200</span>;</span><br><span class="line">	<span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line">	u_int dev_addr = <span class="number">0x13000000</span>;</span><br><span class="line">	u_char status = <span class="number">0</span>;</span><br><span class="line">	u_char read_value = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (offset_begin + offset &lt; offset_end) {</span><br><span class="line">		<span class="comment">// Your code here</span></span><br><span class="line">		<span class="comment">// error occurred, then panic.</span></span><br><span class="line">		u_int now_offset = offset_begin + offset;</span><br><span class="line">		<span class="keyword">if</span> (syscall_write_dev((u_int)&amp;diskno, dev_addr + <span class="number">0x10</span>, <span class="number">4</span>) &lt; <span class="number">0</span>) {</span><br><span class="line">			user_panic(<span class="string">"ide read: diskno write err\n"</span>);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (syscall_write_dev(&amp;now_offset, dev_addr, <span class="number">4</span>) &lt; <span class="number">0</span>) {</span><br><span class="line">			user_panic(<span class="string">"ide read: offset write err\n"</span>);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (syscall_write_dev(&amp;read_value, dev_addr + <span class="number">0x20</span>, <span class="number">1</span>) &lt; <span class="number">0</span>) {</span><br><span class="line">			user_panic(<span class="string">"ide read: write value write err\n"</span>);</span><br><span class="line">		}</span><br><span class="line">		status = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (syscall_read_dev((u_int)&amp;status, dev_addr + <span class="number">0x30</span>, <span class="number">1</span>) &lt; <span class="number">0</span>) {</span><br><span class="line">			user_panic(<span class="string">"ide read: read status err\n"</span>);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (status == <span class="number">0</span>) {</span><br><span class="line">			user_panic(<span class="string">"ide read: read status err\n"</span>);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (syscall_read_dev((u_int)(dst + offset), dev_addr + <span class="number">0x4000</span>, <span class="number">0x200</span>) &lt; <span class="number">0</span>) {</span><br><span class="line">			user_panic(<span class="string">"ide read: get data err\n"</span>);</span><br><span class="line">		}</span><br><span class="line">		offset += <span class="number">0x200</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>在这个文件中有两个函数，一个是 <code>ide_read</code> 另一个是 <code>ide_write</code>。这里展示一下 read 函数。</p>
<p>函数的参数：</p>
<ul>
<li>diskno：磁盘号，不同的磁盘可以根据不同的磁盘号进行访问</li>
<li>secno：扇区号，表示这个磁盘起始开始读的扇区</li>
<li>dst：目标位置，把内容读到这里</li>
<li>nsecs：需要读的扇区个数</li>
</ul>
<p>这个函数的功能是：在磁盘号为diskno的磁盘中，把扇区号从secno到secno+nsecs总共nsecs个扇区的内容，读到dst开始的位置</p>
<h2 id="fs-serv-c"><a href="#fs-serv-c" class="headerlink" title="fs/serv.c"></a><code>fs/serv.c</code></h2><blockquote>
<p>指导书描述：文件系统进程通过 ide.c 和磁盘镜像进行交互，进程主要运行在这个文件上</p>
</blockquote>
<p>整个文件用于界定文件服务进程的结构、功能和任务。</p>
<h3 id="文件宏定义-amp-amp-必要结构体"><a href="#文件宏定义-amp-amp-必要结构体" class="headerlink" title="文件宏定义&&必要结构体"></a>文件宏定义&amp;&amp;必要结构体</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXOPEN 1024		<span class="comment">// 在文件系统中最大打开的文件个数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILEVA 	0x60000000	<span class="comment">// 文件Filefd开始位置</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REQVA 	0x0ffff000	<span class="comment">// REQ开始位置</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Open</span> {</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">o_file</span>;</span>	<span class="comment">// mapped descriptor for open file</span></span><br><span class="line">	u_int o_fileid;		<span class="comment">// file id</span></span><br><span class="line">	<span class="type">int</span> o_mode;		<span class="comment">// open mode</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">o_ff</span>;</span>	<span class="comment">// va of filefd page</span></span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Open</span> <span class="title">opentab</span>[<span class="title">MAXOPEN</span>] =</span> {{<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>}}; <span class="comment">// 会在opentab中记录所有进程打开文件的信息</span></span><br></pre></td></tr></table></figure>
<h3 id="通关必备函数"><a href="#通关必备函数" class="headerlink" title="通关必备函数"></a>通关必备函数</h3><p><strong>user/pageref.c</strong>中的<code>pageref</code>函数用于返回物理页面映射的次数ref</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pageref</span><span class="params">(<span class="type">void</span> *v)</span></span><br><span class="line">{</span><br><span class="line">	u_int pte;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!((* vpd)[PDX(v)]&amp;PTE_V)) {</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	pte = (* vpt)[VPN(v)];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(pte &amp; PTE_V)) {</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pages[PPN(pte)].pp_ref;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这里的pages同vpd和vpt一样都是由于pmap中将用户地址空间和内核地址空间映射到相同的物理页导致的，其具体定义也在entry.S中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># user/entry.S</span><br><span class="line">	.globl pages</span><br><span class="line">pages:</span><br><span class="line">	.word UPAGES</span><br></pre></td></tr></table></figure>
<p>UPAGES就是在pmap中映射pages的位置，具体可以看<code>mips_vm_init()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mips_vm_init()</span></span><br><span class="line">pages = (<span class="keyword">struct</span> Page *)alloc(npage * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Page), BY2PG, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"to memory %x for struct Pages.\n"</span>, freemem);</span><br><span class="line">n = ROUND(npage * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Page), BY2PG);</span><br><span class="line">boot_map_segment(pgdir, UPAGES, n, PADDR(pages), PTE_R);</span><br></pre></td></tr></table></figure>
<p><strong>本文件中的<code>open_alloc</code></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//	Allocate an open file.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">open_alloc</span><span class="params">(<span class="keyword">struct</span> Open **o)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> i, r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find an available open-file table entry</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXOPEN; i++) {</span><br><span class="line">		<span class="keyword">switch</span> (pageref(opentab[i].o_ff)) {</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">				<span class="keyword">if</span> ((r = syscall_mem_alloc(<span class="number">0</span>, (u_int)opentab[i].o_ff,</span><br><span class="line">										   PTE_V | PTE_R | PTE_LIBRARY)) &lt; <span class="number">0</span>) {</span><br><span class="line">					<span class="keyword">return</span> r;</span><br><span class="line">				}</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">				opentab[i].o_fileid += MAXOPEN;</span><br><span class="line">				*o = &amp;opentab[i];</span><br><span class="line">				user_bzero((<span class="type">void</span> *)opentab[i].o_ff, BY2PG);</span><br><span class="line">				<span class="keyword">return</span> (*o)-&gt;o_fileid;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> -E_MAX_OPEN;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>函数的行为是从0开始遍历。如果找到了一个从来没有分配过页面的位置，则首先使用系统调用给这个位置分配一个页面。这里设置页面权限为<strong>存在、可写、共享</strong>。这个页面是在文件服务进程的对应位置上进行设置的。</p>
<p>如果第一次找到的不是未分配的或者从未分配到分配，则进入case 1. 在这里，首先将文件id设置为本地id+1024。我认为这样很容易寻找，取模1024之后都在同一个位置。设置好文件id之后，把返回的o设置好，说明找到了。然后把这个页面清空，表示分配好位置了，最后把id传递回去。</p>
<p><strong>本文件中open_lookup</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//	Look up an open file for envid.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">open_lookup</span><span class="params">(u_int envid, u_int fileid, <span class="keyword">struct</span> Open **po)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Open</span> *<span class="title">o</span>;</span></span><br><span class="line">	o = &amp;opentab[fileid % MAXOPEN];	<span class="comment">// 这里就充分利用了id+1024 * n的好处了，便于通过取余确定fileid在opentab中的位置</span></span><br><span class="line">	<span class="keyword">if</span> (pageref(o-&gt;o_ff) == <span class="number">1</span> || o-&gt;o_fileid != fileid) {<span class="comment">//意思应该是说这里找到不是那个文件</span></span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	}</span><br><span class="line">	*po = o;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="serve-init服务进程初始化"><a href="#serve-init服务进程初始化" class="headerlink" title="serve_init服务进程初始化"></a><code>serve_init</code>服务进程初始化</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//	Initialize file system server process.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">serve_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	u_int va;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set virtual address to map.</span></span><br><span class="line">	va = FILEVA;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initial array opentab.</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXOPEN; i++) {</span><br><span class="line">		opentab[i].o_fileid = i;</span><br><span class="line">		opentab[i].o_ff = (<span class="keyword">struct</span> Filefd *)va;</span><br><span class="line">		va += BY2PG;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>初始化1024个文件的offset和id。</p>
<h3 id="serve-服务主体"><a href="#serve-服务主体" class="headerlink" title="serve 服务主体"></a><code>serve</code> 服务主体</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">serve</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">	u_int req, whom, perm;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) {</span><br><span class="line">		perm = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		req = ipc_recv(&amp;whom, REQVA, &amp;perm);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">// All requests must contain an argument page</span></span><br><span class="line">		<span class="keyword">if</span> (!(perm &amp; PTE_V)) {</span><br><span class="line">			writef(<span class="string">"Invalid request from %08x: no argument page\n"</span>, whom);</span><br><span class="line">			<span class="keyword">continue</span>; <span class="comment">// just leave it hanging, waiting for the next request.</span></span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (req) {</span><br><span class="line">			<span class="keyword">case</span> FSREQ_OPEN:</span><br><span class="line">				serve_open(whom, (<span class="keyword">struct</span> Fsreq_open *)REQVA);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> FSREQ_MAP:</span><br><span class="line">				serve_map(whom, (<span class="keyword">struct</span> Fsreq_map *)REQVA);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> FSREQ_SET_SIZE:</span><br><span class="line">				serve_set_size(whom, (<span class="keyword">struct</span> Fsreq_set_size *)REQVA);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> FSREQ_CLOSE:</span><br><span class="line">				serve_close(whom, (<span class="keyword">struct</span> Fsreq_close *)REQVA);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> FSREQ_DIRTY:</span><br><span class="line">				serve_dirty(whom, (<span class="keyword">struct</span> Fsreq_dirty *)REQVA);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> FSREQ_REMOVE:</span><br><span class="line">				serve_remove(whom, (<span class="keyword">struct</span> Fsreq_remove *)REQVA);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> FSREQ_SYNC:</span><br><span class="line">				serve_sync(whom);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				writef(<span class="string">"Invalid request code %d from %08x\n"</span>, whom, req);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		syscall_mem_unmap(<span class="number">0</span>, REQVA);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>整个函数是一个死循环，不断使用<code>ipc_recv(&amp;whom, REQVA, &amp;perm)</code>接受其他用户进程发来的消息，用于进行文件服务。对于服务的要求，所有的请求都必须有一个存在的页面来保存请求的具体信息。因此，函数中先检查PTE_V。进而根据不同的请求选择不同的函数。在这个进程中，其他用户进程会将信息保存到0x0ffff000开始的页面上（REQVA），然后在后续的处理过程中，调用不同的处理函数，使用不同的结构体来解释页面内部的数据。</p>
<h4 id="FSREQ-OPEN"><a href="#FSREQ-OPEN" class="headerlink" title="FSREQ_OPEN"></a>FSREQ_OPEN</h4><p>调用<code>serve_open(whom,(struct Fsreq_open *)REQVA)</code>，使用<code>Fsreq_open</code>解释页面内的数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_open</span> {</span></span><br><span class="line">	<span class="type">char</span> req_path[MAXPATHLEN];</span><br><span class="line">	u_int req_omode;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<p>结构体内部包含一个文件路径和打开的权限</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Serve requests, sending responses back to envid.</span></span><br><span class="line"><span class="comment">// To send a result back, ipc_send(envid, r, 0, 0).</span></span><br><span class="line"><span class="comment">// To include a page, ipc_send(envid, r, srcva, perm).</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">serve_open</span><span class="params">(u_int envid, <span class="keyword">struct</span> Fsreq_open *rq)</span></span><br><span class="line">{</span><br><span class="line">	writef(<span class="string">"serve_open %08x %x 0x%x\n"</span>, envid, (<span class="type">int</span>)rq-&gt;req_path, rq-&gt;req_omode);</span><br><span class="line"></span><br><span class="line">	u_char path[MAXPATHLEN];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">ff</span>;</span></span><br><span class="line">	<span class="type">int</span> fileid;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Open</span> *<span class="title">o</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Copy in the path, making sure it's null-terminated</span></span><br><span class="line">	user_bcopy(rq-&gt;req_path, path, MAXPATHLEN);</span><br><span class="line">	path[MAXPATHLEN - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find a file id.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = open_alloc(&amp;o)) &lt; <span class="number">0</span>) {</span><br><span class="line">		user_panic(<span class="string">"open_alloc failed: %d, invalid path: %s"</span>, r, path);</span><br><span class="line">		ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	fileid = r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Open the file.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = file_open((<span class="type">char</span> *)path, &amp;f)) &lt; <span class="number">0</span>) {</span><br><span class="line">	<span class="comment">//	user_panic("file_open failed: %d, invalid path: %s", r, path);</span></span><br><span class="line">		ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Save the file pointer.</span></span><br><span class="line">	o-&gt;o_file = f;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fill out the Filefd structure</span></span><br><span class="line">	ff = (<span class="keyword">struct</span> Filefd *)o-&gt;o_ff;</span><br><span class="line">	ff-&gt;f_file = *f;</span><br><span class="line">	ff-&gt;f_fileid = o-&gt;o_fileid;</span><br><span class="line">	o-&gt;o_mode = rq-&gt;req_omode;</span><br><span class="line">	ff-&gt;f_fd.fd_omode = o-&gt;o_mode;</span><br><span class="line">	ff-&gt;f_fd.fd_dev_id = devfile.dev_id;</span><br><span class="line"></span><br><span class="line">	ipc_send(envid, <span class="number">0</span>, (u_int)o-&gt;o_ff, PTE_V | PTE_R | PTE_LIBRARY);</span><br><span class="line">    <span class="comment">//这个返回值的意思是给原来那个用户进程插入一个off所在的页面，并且设置为共享。</span></span><br><span class="line">    <span class="comment">//这个off对应的都是Filefd</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>注释提示这个函数需要对于请求进行服务，然后将返回信息发送回envid对应的用户进程。</p>
<p>将待打开的文件路径复制到path；找到一个空闲的位置。然后打开path对应的文件。第一步将opentab中的文件指针设置为f，然后定位opentab中的Filefd指针。Filefd结构体中包含文件描述符、fileid、和File结构体f_file。在这里需要将f_file正确赋值、fileid赋值正确、文件描述符中的打开方式、对应的devid</p>
<h4 id="FSREQ-MAP"><a href="#FSREQ-MAP" class="headerlink" title="FSREQ_MAP"></a>FSREQ_MAP</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_map</span> {</span></span><br><span class="line">	<span class="type">int</span> req_fileid;</span><br><span class="line">	u_int req_offset;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">serve_map</span><span class="params">(u_int envid, <span class="keyword">struct</span> Fsreq_map *rq)</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Open</span> *<span class="title">pOpen</span>;</span></span><br><span class="line">	u_int filebno;</span><br><span class="line">	<span class="type">void</span> *blk;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="keyword">if</span> ((r = open_lookup(envid, rq-&gt;req_fileid, &amp;pOpen)) &lt; <span class="number">0</span>) {<span class="comment">//第一步找到这个文件。通过fileid，找到的文件保存在pOpen中</span></span><br><span class="line">		ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	filebno = rq-&gt;req_offset / BY2BLK;<span class="comment">//通过请求的offset获得这是第几个块</span></span><br><span class="line">	<span class="keyword">if</span> ((r = file_get_block(pOpen-&gt;o_file, filebno, &amp;blk)) &lt; <span class="number">0</span>) {<span class="comment">//把这个块的内容从磁盘中调到内存中</span></span><br><span class="line">		ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	ipc_send(envid, <span class="number">0</span>, (u_int)blk, PTE_V | PTE_R | PTE_LIBRARY);</span><br><span class="line">    <span class="comment">// 给原来调用这个服务的进程的地址中插入一下相同的页面，并且设置为共享。可以一块查看和修改。</span></span><br><span class="line">    <span class="comment">//这里传过去的页面是一个个磁盘块的地址</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="FSREQ-SET-SIZE"><a href="#FSREQ-SET-SIZE" class="headerlink" title="FSREQ_SET_SIZE"></a>FSREQ_SET_SIZE</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_set_size</span> {</span></span><br><span class="line">	<span class="type">int</span> req_fileid;</span><br><span class="line">	u_int req_size;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">serve_set_size</span><span class="params">(u_int envid, <span class="keyword">struct</span> Fsreq_set_size *rq)</span>{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Open</span> *<span class="title">pOpen</span>;</span></span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="keyword">if</span> ((r = open_lookup(envid, rq-&gt;req_fileid, &amp;pOpen)) &lt; <span class="number">0</span>) {<span class="comment">//找一下这个文件</span></span><br><span class="line">		ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> ((r = file_set_size(pOpen-&gt;o_file, rq-&gt;req_size)) &lt; <span class="number">0</span>) {<span class="comment">//使用fs.c中的函数，将文件的大小设置为需求中的大小</span></span><br><span class="line">		ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	ipc_send(envid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="FSREQ-CLOSE"><a href="#FSREQ-CLOSE" class="headerlink" title="FSREQ_CLOSE"></a>FSREQ_CLOSE</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_close</span> {</span></span><br><span class="line">	<span class="type">int</span> req_fileid;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">erve_close</span><span class="params">(u_int envid, <span class="keyword">struct</span> Fsreq_close *rq)</span>{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Open</span> *<span class="title">pOpen</span>;</span></span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="keyword">if</span> ((r = open_lookup(envid, rq-&gt;req_fileid, &amp;pOpen)) &lt; <span class="number">0</span>) {<span class="comment">//找到文件</span></span><br><span class="line">		ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	file_close(pOpen-&gt;o_file);<span class="comment">//使用fs.c中的函数，把这个文件关闭</span></span><br><span class="line">	ipc_send(envid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="FSREQ-DIRTY"><a href="#FSREQ-DIRTY" class="headerlink" title="FSREQ_DIRTY"></a>FSREQ_DIRTY</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_dirty</span> {</span></span><br><span class="line">	<span class="type">int</span> req_fileid;</span><br><span class="line">	u_int req_offset;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">serve_dirty</span><span class="params">(u_int envid, <span class="keyword">struct</span> Fsreq_dirty *rq)</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">// Your code here</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Open</span> *<span class="title">pOpen</span>;</span></span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="keyword">if</span> ((r = open_lookup(envid, rq-&gt;req_fileid, &amp;pOpen)) &lt; <span class="number">0</span>) { <span class="comment">// 先找到文件</span></span><br><span class="line">		ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> ((r = file_dirty(pOpen-&gt;o_file, rq-&gt;req_offset)) &lt; <span class="number">0</span>) { <span class="comment">// 然后调用fs中的函数，将这个文件设置为dirty</span></span><br><span class="line">		ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	ipc_send(envid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="FSREQ-REMOVE"><a href="#FSREQ-REMOVE" class="headerlink" title="FSREQ_REMOVE"></a>FSREQ_REMOVE</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_remove</span> {</span></span><br><span class="line">	u_char req_path[MAXPATHLEN];</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">serve_remove</span><span class="params">(u_int envid, <span class="keyword">struct</span> Fsreq_remove *rq)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	u_char path[MAXPATHLEN];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 1: Copy in the path, making sure it's terminated.</span></span><br><span class="line">	<span class="comment">// Notice: add \0 to the tail of the path</span></span><br><span class="line">	user_bcopy(rq -&gt; req_path, path, MAXPATHLEN);</span><br><span class="line">	path[MAXPATHLEN - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">	<span class="comment">// Step 2: Remove file from file system and response to user-level process.</span></span><br><span class="line">	<span class="comment">// Call file_remove and ipc_send an approprite value to corresponding env.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = file_remove(path)) &lt; <span class="number">0</span>) {</span><br><span class="line">		ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	ipc_send(envid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>和其他的函数套路一样，先设置文件路径，然后再直接remove</p>
<h4 id="FSREQ-SYNC"><a href="#FSREQ-SYNC" class="headerlink" title="FSREQ_SYNC"></a>FSREQ_SYNC</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">serve_sync</span><span class="params">(u_int envid)</span></span><br><span class="line">{	</span><br><span class="line">	fs_sync();		<span class="comment">// 将所有的dirty块写回磁盘</span></span><br><span class="line">	ipc_send(envid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="user-fsipc-c"><a href="#user-fsipc-c" class="headerlink" title="user/fsipc.c"></a><code>user/fsipc.c</code></h2><p>这个文件中函数都是用来和serv进行交互的。每个函数都对应着serv中的一个函数，同时serv中的一个函数中可能调用fs中的函数。fs中的函数是真正的底层函数。就像前几个lab中的系统调用函数一样，系统函数被包装的非常好，对外提供的就是一个函数皮。一层一层的调用，再一层一层的返回。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> u_char fsipcbuf[BY2PG]; <span class="comment">// 这里先来一页，不知道什么东西</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">fsipc</span><span class="params">(u_int type, <span class="type">void</span> *fsreq, u_int dstva, u_int *perm)</span></span><br><span class="line">{</span><br><span class="line">	u_int whom;</span><br><span class="line">	<span class="comment">// NOTEICE: Our file system no.1 process!</span></span><br><span class="line">   	<span class="comment">// 这个函数的作用就是给文件服务进程传递一个消息并且等待返回值。</span></span><br><span class="line">    <span class="comment">// 这个估计又是底层函数了，就是说，其他啊fsipc_xxx函数最终会调用这个函数和文件服务进程通信</span></span><br><span class="line">    <span class="comment">// 这里需要特别注意，文件服务进程的id号是1，这个要格外注意和小心。</span></span><br><span class="line">	ipc_send(envs[<span class="number">1</span>].env_id, type, (u_int)fsreq, PTE_V | PTE_R);</span><br><span class="line">	<span class="keyword">return</span> ipc_recv(&amp;whom, dstva, perm);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="fsipc-open"><a href="#fsipc-open" class="headerlink" title="fsipc_open"></a>fsipc_open</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fsipc_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, u_int omode, <span class="keyword">struct</span> Fd *fd)</span></span><br><span class="line">{</span><br><span class="line">	u_int perm;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_open</span> *<span class="title">req</span>;</span></span><br><span class="line">	req = (<span class="keyword">struct</span> Fsreq_open *)fsipcbuf;</span><br><span class="line">	<span class="comment">// The path is too long.</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strlen</span>(path) &gt;= MAXPATHLEN) {</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">strcpy</span>((<span class="type">char</span> *)req-&gt;req_path, path);</span><br><span class="line">	req-&gt;req_omode = omode;</span><br><span class="line">	<span class="keyword">return</span> fsipc(FSREQ_OPEN, req, (u_int)fd, &amp;perm);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="fsipc-map"><a href="#fsipc-map" class="headerlink" title="fsipc_map"></a>fsipc_map</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fsipc_map</span><span class="params">(u_int fileid, u_int offset, u_int dstva)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	u_int perm;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_map</span> *<span class="title">req</span>;</span></span><br><span class="line">	req = (<span class="keyword">struct</span> Fsreq_map *)fsipcbuf;</span><br><span class="line">	req-&gt;req_fileid = fileid;</span><br><span class="line">	req-&gt;req_offset = offset;</span><br><span class="line">	<span class="keyword">if</span> ((r = fsipc(FSREQ_MAP, req, dstva, &amp;perm)) &lt; <span class="number">0</span>) {</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> ((perm &amp; ~(PTE_R | PTE_LIBRARY)) != (PTE_V)) {<span class="comment">//检查一下权限，必须有PTE_V，可以有PTE_R和PTE_LIBRARY</span></span><br><span class="line">		user_panic(<span class="string">"fsipc_map: unexpected permissions %08x for dstva %08x"</span>, perm,</span><br><span class="line">				   dstva);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="fsipc-set-size"><a href="#fsipc-set-size" class="headerlink" title="fsipc_set_size"></a>fsipc_set_size</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fsipc_set_size</span><span class="params">(u_int fileid, u_int size)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_set_size</span> *<span class="title">req</span>;</span></span><br><span class="line"></span><br><span class="line">	req = (<span class="keyword">struct</span> Fsreq_set_size *)fsipcbuf;</span><br><span class="line">	req-&gt;req_fileid = fileid;</span><br><span class="line">	req-&gt;req_size = size;</span><br><span class="line">	<span class="keyword">return</span> fsipc(FSREQ_SET_SIZE, req, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="fsipc-close"><a href="#fsipc-close" class="headerlink" title="fsipc_close"></a>fsipc_close</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fsipc_close</span><span class="params">(u_int fileid)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_close</span> *<span class="title">req</span>;</span></span><br><span class="line"></span><br><span class="line">	req = (<span class="keyword">struct</span> Fsreq_close *)fsipcbuf;</span><br><span class="line">	req-&gt;req_fileid = fileid;</span><br><span class="line">	<span class="keyword">return</span> fsipc(FSREQ_CLOSE, req, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="fsipc-dirty"><a href="#fsipc-dirty" class="headerlink" title="fsipc_dirty"></a>fsipc_dirty</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fsipc_dirty</span><span class="params">(u_int fileid, u_int offset)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_dirty</span> *<span class="title">req</span>;</span></span><br><span class="line"></span><br><span class="line">	req = (<span class="keyword">struct</span> Fsreq_dirty *)fsipcbuf;</span><br><span class="line">	req-&gt;req_fileid = fileid;</span><br><span class="line">	req-&gt;req_offset = offset;</span><br><span class="line">	<span class="keyword">return</span> fsipc(FSREQ_DIRTY, req, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="fsipc-remove"><a href="#fsipc-remove" class="headerlink" title="fsipc_remove"></a>fsipc_remove</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fsipc_remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_remove</span> * <span class="title">req</span>;</span></span><br><span class="line">	<span class="comment">// Step 1: Check the length of path, decide if the path is valid.</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strlen</span>(path) &gt; MAXPATHLEN) <span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">	<span class="comment">// Step 2: Transform fsipcbuf to struct Fsreq_remove*</span></span><br><span class="line">	req = (<span class="keyword">struct</span> Fsreq_remove *)fsipcbuf;</span><br><span class="line">	<span class="comment">// Step 3: Copy path to path in req.</span></span><br><span class="line">	<span class="built_in">strcpy</span>((<span class="type">char</span> *)req -&gt; req_path, path);</span><br><span class="line">	<span class="comment">// Step 4: Send request to fs server with IPC.</span></span><br><span class="line">	<span class="keyword">return</span> fsipc(FSREQ_REMOVE, req, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="fsipc-sync"><a href="#fsipc-sync" class="headerlink" title="fsipc_sync"></a>fsipc_sync</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fsipc_sync</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> fsipc(FSREQ_SYNC, fsipcbuf, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="user-fd-c"><a href="#user-fd-c" class="headerlink" title="user/fd.c"></a><code>user/fd.c</code></h2><blockquote>
<p>指导书描述：在这个文件中引入文件描述符</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> *<span class="title">devtab</span>[] =</span> {	<span class="comment">// 这是所有dev的数组，记录了所有的dev，在MOS中包括三个dev，分别是devfile、devcons和devpipe</span></span><br><span class="line">	&amp;devfile,</span><br><span class="line">	&amp;devcons,</span><br><span class="line">	&amp;devpipe,</span><br><span class="line">	<span class="number">0</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h4 id="dev-lookup"><a href="#dev-lookup" class="headerlink" title="dev_lookup"></a>dev_lookup</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dev_lookup</span><span class="params">(<span class="type">int</span> dev_id, <span class="keyword">struct</span> Dev **dev)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; devtab[i]; i++)</span><br><span class="line">		<span class="keyword">if</span> (devtab[i]-&gt;dev_id == dev_id) {<span class="comment">//遍历devtab，寻找devid等于传进来参数的设备</span></span><br><span class="line">			*dev = devtab[i];</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">	writef(<span class="string">"[%08x] unknown device type %d\n"</span>, env-&gt;env_id, dev_id);</span><br><span class="line">	<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="fd-alloc"><a href="#fd-alloc" class="headerlink" title="fd_alloc"></a>fd_alloc</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fd_alloc</span><span class="params">(<span class="keyword">struct</span> Fd **fd)</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">// Find the smallest i from 0 to MAXFD-1 that doesn't have</span></span><br><span class="line">	<span class="comment">// its fd page mapped.  Set *fd to the fd page virtual address.</span></span><br><span class="line">	<span class="comment">// (Do not allocate a page.  It is up to the caller to allocate</span></span><br><span class="line">	<span class="comment">// the page.  This means that if someone calls fd_alloc twice</span></span><br><span class="line">	<span class="comment">// in a row without allocating the first page we return, we'll</span></span><br><span class="line">	<span class="comment">// return the same page the second time.)</span></span><br><span class="line">	<span class="comment">// Return 0 on success, or an error code on error.</span></span><br><span class="line">	u_int va;</span><br><span class="line">	u_int fdno;</span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="keyword">for</span> (fdno = <span class="number">0</span>; fdno &lt; MAXFD - <span class="number">1</span>; fdno++) {	<span class="comment">//最多有32个文件描述符（一个文件描述符占一页）</span></span><br><span class="line">		va = INDEX2FD(fdno);<span class="comment">//根据文件描述符的号查找这里的地址</span></span><br><span class="line">		<span class="comment">// 之后找到第一个没有用过的文件描述符，但是此时暂时不给他分配页，交给调用的进程分配页。</span></span><br><span class="line">        <span class="comment">// 因为如果调用的进程不分配页，则下次调用还是返回这个地址</span></span><br><span class="line">		<span class="keyword">if</span> (((* vpd)[va / PDMAP] &amp; PTE_V) == <span class="number">0</span>) {</span><br><span class="line">			*fd = (<span class="keyword">struct</span> Fd *)va;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (((* vpt)[va / BY2PG] &amp; PTE_V) == <span class="number">0</span>) {	<span class="comment">//the fd is not used</span></span><br><span class="line">			*fd = (<span class="keyword">struct</span> Fd *)va;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> -E_MAX_OPEN;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="fd-close"><a href="#fd-close" class="headerlink" title="fd_close"></a>fd_close</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fd_close</span><span class="params">(<span class="keyword">struct</span> Fd *fd)</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">// 直接系统调用将块的物理页剥夺</span></span><br><span class="line">	syscall_mem_unmap(<span class="number">0</span>, (u_int)fd);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="fd-lookup"><a href="#fd-lookup" class="headerlink" title="fd_lookup"></a>fd_lookup</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fd_lookup</span><span class="params">(<span class="type">int</span> fdnum, <span class="keyword">struct</span> Fd **fd)</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">// Check that fdnum is in range and mapped.  If not, return -E_INVAL.</span></span><br><span class="line">	<span class="comment">// Set *fd to the fd page virtual address.  Return 0.</span></span><br><span class="line">	u_int va;</span><br><span class="line">	<span class="keyword">if</span> (fdnum &gt;= MAXFD) {</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	}</span><br><span class="line">	va = INDEX2FD(fdnum);</span><br><span class="line">    <span class="comment">// 去找这个fdnum对应的虚拟地址</span></span><br><span class="line">	<span class="keyword">if</span> (((* vpt)[va / BY2PG] &amp; PTE_V) != <span class="number">0</span>) {	<span class="comment">//the fd is used</span></span><br><span class="line">		*fd = (<span class="keyword">struct</span> Fd *)va;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="fd2data"><a href="#fd2data" class="headerlink" title="fd2data"></a>fd2data</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INDEX2DATA(i)	(FILEBASE+(i)*PDMAP)</span></span><br><span class="line">u_int <span class="title function_">fd2data</span><span class="params">(<span class="keyword">struct</span> Fd *fd)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> INDEX2DATA(fd2num(fd));<span class="comment">//从fd的编号得到这块对应的data</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="fd2num"><a href="#fd2num" class="headerlink" title="fd2num"></a>fd2num</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fd2num</span><span class="params">(<span class="keyword">struct</span> Fd *fd)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> ((u_int)fd - FDTABLE) / BY2PG;<span class="comment">//通过地址获得这是第几个fd</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="num2fd"><a href="#num2fd" class="headerlink" title="num2fd"></a>num2fd</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INDEX2FD(i)	(FDTABLE+(i)*BY2PG)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">num2fd</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> fd * BY2PG + FDTABLE;<span class="comment">//这个函数和某一个宏函数重复了</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="close"><a href="#close" class="headerlink" title="close"></a>close</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fdnum)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span></span><br><span class="line">		||  (r = dev_lookup(fd-&gt;fd_dev_id, &amp;dev)) &lt; <span class="number">0</span>) { <span class="comment">// 找到这个fd，再找到这个fd对应的设备</span></span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	r = (*dev-&gt;dev_close)(fd); <span class="comment">// 调用这个设备的close方法</span></span><br><span class="line">	fd_close(fd);	<span class="comment">// 这个函数内部直接调用函数调用，取消这个虚拟地址的物理地址映射</span></span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="close-all"><a href="#close-all" class="headerlink" title="close_all"></a>close_all</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">close_all</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXFD; i++) {</span><br><span class="line">		close(i);<span class="comment">//把所有文件描述符都关闭</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h4><p>下标为oldfnum文件控制块的内容拷贝到newfdnum的文件控制块中，并将文件控制块控制的文件内容从地址fd2data(oldfd)的位置拷贝到fd2data(newfd)的位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfdnum, <span class="type">int</span> newfdnum)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> i, r;</span><br><span class="line">	u_int ova, nva, pte;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">oldfd</span>, *<span class="title">newfd</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(oldfdnum, &amp;oldfd)) &lt; <span class="number">0</span>) {<span class="comment">//先找到原来的文件描述符</span></span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	close(newfdnum);	<span class="comment">//准备好新的文件描述符</span></span><br><span class="line">	newfd = (<span class="keyword">struct</span> Fd *)INDEX2FD(newfdnum);</span><br><span class="line">	ova = fd2data(oldfd);<span class="comment">//获得新旧文件描述符的地址，准备将旧文件描述符拷贝到新的文件描述符的地址</span></span><br><span class="line">	nva = fd2data(newfd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = syscall_mem_map(<span class="number">0</span>, (u_int)oldfd, <span class="number">0</span>, (u_int)newfd,</span><br><span class="line">							 ((*vpt)[VPN(oldfd)]) &amp; (PTE_V | PTE_R | PTE_LIBRARY))) &lt; <span class="number">0</span>) {<span class="comment">//把文件控制符的拷贝过去</span></span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((* vpd)[PDX(ova)]) {<span class="comment">//从这个地址开始，将所有的页复制到新的文件描述符对应的地址</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PDMAP; i += BY2PG) {</span><br><span class="line">			pte = (* vpt)[VPN(ova + i)];</span><br><span class="line">			<span class="keyword">if</span> (pte &amp; PTE_V) {</span><br><span class="line">				<span class="comment">// should be no error here -- pd is already allocated</span></span><br><span class="line">				<span class="keyword">if</span> ((r = syscall_mem_map(<span class="number">0</span>, ova + i, <span class="number">0</span>, nva + i,</span><br><span class="line">										 pte &amp; (PTE_V | PTE_R | PTE_LIBRARY))) &lt; <span class="number">0</span>) {</span><br><span class="line">					<span class="keyword">goto</span> err;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> newfdnum;</span><br><span class="line">err:</span><br><span class="line">	syscall_mem_unmap(<span class="number">0</span>, (u_int)newfd);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PDMAP; i += BY2PG) {</span><br><span class="line">		syscall_mem_unmap(<span class="number">0</span>, nva + i);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="read"><a href="#read" class="headerlink" title="read"></a>read</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//	Read 'n' bytes from 'fd' at the current seek position into 'buf'.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Post-Condition:</span></span><br><span class="line"><span class="comment">//	Update seek position.</span></span><br><span class="line"><span class="comment">//	Return the number of bytes read successfully.</span></span><br><span class="line"><span class="comment">//		&lt; 0 on error</span></span><br><span class="line"><span class="comment">/*** exercise 5.9 ***/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fdnum, <span class="type">void</span> *buf, u_int n)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Similar to 'write' function.</span></span><br><span class="line">	<span class="comment">// Step 1: Get fd and dev.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span></span><br><span class="line">		||  (r = dev_lookup(fd-&gt;fd_dev_id, &amp;dev)) &lt; <span class="number">0</span>) {<span class="comment">//找到对应的文件描述符和设备</span></span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// Step 2: Check open mode.</span></span><br><span class="line">	<span class="keyword">if</span> ((fd-&gt;fd_omode &amp; O_ACCMODE) == O_WRONLY) {	<span class="comment">// 如果文件打开权限只能写，不能读，则报错</span></span><br><span class="line">		writef(<span class="string">"[%08x] read %d -- bad mode\n"</span>, env-&gt;env_id, fdnum);</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// Step 3: Read starting from seek position.</span></span><br><span class="line">	<span class="keyword">if</span> (debug) writef(<span class="string">"read %d %p %d via dev %s\n"</span>,</span><br><span class="line">						  fdnum, buf, n, dev-&gt;dev_name);</span><br><span class="line">	r = (*dev-&gt;dev_read)(fd, buf, n, fd-&gt;fd_offset);		<span class="comment">// 调用设备中包含的dev_read</span></span><br><span class="line">	<span class="comment">// Step 4: Update seek position and set '\0' at the end of buf.</span></span><br><span class="line">	<span class="keyword">if</span> (r &gt; <span class="number">0</span>) {</span><br><span class="line">		fd-&gt;fd_offset += r;<span class="comment">//file_read函数中每次读取都是从offset开始，这里设置下一次读取开始的位置。</span></span><br><span class="line">	}</span><br><span class="line">	((<span class="type">char</span>*)buf)[r] = <span class="string">'\0'</span>;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="readn"><a href="#readn" class="headerlink" title="readn"></a>readn</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">readn</span><span class="params">(<span class="type">int</span> fdnum, <span class="type">void</span> *buf, u_int n)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> m, tot;</span><br><span class="line">	<span class="keyword">for</span> (tot = <span class="number">0</span>; tot &lt; n; tot += m) {<span class="comment">//当需要读取大量的字符或者多次读取的时候使用这个函数</span></span><br><span class="line">        <span class="comment">//这个函数中多次调用read。每次读取之后检查是否读对了，</span></span><br><span class="line">        <span class="comment">//这个函数可以支持读取长度大于n，</span></span><br><span class="line">        <span class="comment">//而且这个函数是不断读取这里的位置</span></span><br><span class="line">        <span class="comment">//直到读取的长度为n。只许成功不许失败</span></span><br><span class="line">		m = read(fdnum, (<span class="type">char</span> *)buf + tot, n - tot);</span><br><span class="line">		<span class="keyword">if</span> (m &lt; <span class="number">0</span>) {</span><br><span class="line">			<span class="keyword">return</span> m;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (m == <span class="number">0</span>) {</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> tot;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="write"><a href="#write" class="headerlink" title="write"></a>write</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fdnum, <span class="type">const</span> <span class="type">void</span> *buf, u_int n)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span></span><br><span class="line">		||  (r = dev_lookup(fd-&gt;fd_dev_id, &amp;dev)) &lt; <span class="number">0</span>) {</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((fd-&gt;fd_omode &amp; O_ACCMODE) == O_RDONLY) {</span><br><span class="line">		writef(<span class="string">"[%08x] write %d -- bad mode\n"</span>, env-&gt;env_id, fdnum);</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (debug) writef(<span class="string">"write %d %p %d via dev %s\n"</span>,</span><br><span class="line">						  fdnum, buf, n, dev-&gt;dev_name);</span><br><span class="line"></span><br><span class="line">	r = (*dev-&gt;dev_write)(fd, buf, n, fd-&gt;fd_offset);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (r &gt; <span class="number">0</span>) {</span><br><span class="line">		fd-&gt;fd_offset += r;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="seek"><a href="#seek" class="headerlink" title="seek"></a>seek</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">seek</span><span class="params">(<span class="type">int</span> fdnum, u_int offset)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span>) {<span class="comment">//找到这个文件控制符</span></span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	fd-&gt;fd_offset = offset;<span class="comment">//将offset设置为传进来的offset</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="fstat"><a href="#fstat" class="headerlink" title="fstat"></a>fstat</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fdnum, <span class="keyword">struct</span> Stat *stat)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span></span><br><span class="line">		||  (r = dev_lookup(fd-&gt;fd_dev_id, &amp;dev)) &lt; <span class="number">0</span>) {<span class="comment">//找到这个文件和对应的设备</span></span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	}</span><br><span class="line">	stat-&gt;st_name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	stat-&gt;st_size = <span class="number">0</span>;</span><br><span class="line">	stat-&gt;st_isdir = <span class="number">0</span>;</span><br><span class="line">	stat-&gt;st_dev = dev;</span><br><span class="line">	<span class="keyword">return</span> (*dev-&gt;dev_stat)(fd, stat);<span class="comment">//调用file_stat将文件的状态保存到stat中</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="keyword">struct</span> Stat *stat)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> fd, r;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((fd = open(path, O_RDONLY)) &lt; <span class="number">0</span>) {<span class="comment">//打开文件</span></span><br><span class="line">		<span class="keyword">return</span> fd;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	r = fstat(fd, stat);<span class="comment">//获取文件的状态</span></span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="user-file-c"><a href="#user-file-c" class="headerlink" title="user/file.c"></a><code>user/file.c</code></h2><blockquote>
<p>指导书描述：用户进程在filec中实现用户接口</p>
</blockquote>
<p>操作系统中有三种设备，这是其中一个叫做devfile</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> <span class="title">devfile</span> =</span> {</span><br><span class="line">	.dev_id =	<span class="string">'f'</span>,<span class="comment">//注释说，点代表在结构体定义中选择同名的变量并且不用在意定义的顺序，用于给结构体赋值。</span></span><br><span class="line">	.dev_name =	<span class="string">"file"</span>,</span><br><span class="line">	.dev_read =	file_read,</span><br><span class="line">	.dev_write =	file_write,</span><br><span class="line">	.dev_close =	file_close,</span><br><span class="line">	.dev_stat =	file_stat,</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h4 id="open"><a href="#open" class="headerlink" title="open"></a>open</h4><p>函数的特点：这个函数的功能是打开一个文件。首先需要分配一个文件描述符。然后通过ipc命令文件服务进程打开文件。</p>
<p>因为都是通过ipc进行进程间的通信，所以都是使用ipc_send进行页面的传输。侧面印证了为什么一个fd结构体预留了1页的空间</p>
<p>获得fd结构体之后，根据其中信息，将文件的内容全部展开放到va开始的位置里面。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//	Open a file (or directory).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns:</span></span><br><span class="line"><span class="comment">//	the file descriptor onsuccess,</span></span><br><span class="line"><span class="comment">//	&lt; 0 on failure.</span></span><br><span class="line"><span class="comment">/*** exercise 5.8 ***/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> mode)</span> {</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">ffd</span>;</span></span><br><span class="line">	u_int size, fileid;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	u_int va;</span><br><span class="line">	u_int i;</span><br><span class="line">	<span class="comment">// Step 1: Alloc a new Fd, return error code when fail to alloc.</span></span><br><span class="line">	<span class="comment">// Hint: Please use fd_alloc.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_alloc(&amp;fd)) &lt; <span class="number">0</span>) <span class="keyword">return</span> r;</span><br><span class="line">	<span class="comment">// Step 2: Get the file descriptor of the file to open.</span></span><br><span class="line">	<span class="comment">// Hint: Read fsipc.c, and choose a function.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = fsipc_open(path, mode, fd)) &lt; <span class="number">0</span>) <span class="keyword">return</span> r;</span><br><span class="line">	<span class="comment">// Step 3: Set the start address storing the file's content. Set size and fileid correctly.</span></span><br><span class="line">	<span class="comment">// Hint: Use fd2data to get the start address.</span></span><br><span class="line">	ffd = (<span class="keyword">struct</span> Filefd*)fd;</span><br><span class="line">	va = fd2data(fd);</span><br><span class="line">	fileid = ffd -&gt; f_fileid;</span><br><span class="line">	size = ffd -&gt; f_file.f_size;</span><br><span class="line">	<span class="comment">// Step 4: Alloc memory, map the file content into memory.</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i += BY2PG) {</span><br><span class="line">		<span class="keyword">if</span> ((r = fsipc_map(fileid, i, va + i)) &lt; <span class="number">0</span>) {</span><br><span class="line">			writef(<span class="string">"cannot map the file.\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// Step 5: Return the number of file descriptor.</span></span><br><span class="line">	<span class="keyword">return</span> fd2num(fd);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="file-close-1"><a href="#file-close-1" class="headerlink" title="file_close"></a>file_close</h4><p>功能：关闭一个文件描述符。首先将dirty页面都保存回磁盘。然后告诉文件服务进程把这个文件关闭。最后把本进程中va开始的文件大小的空间全部取消映射。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//	Close a file descriptor</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">file_close</span><span class="params">(<span class="keyword">struct</span> Fd *fd)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">ffd</span>;</span></span><br><span class="line">	u_int va, size, fileid;</span><br><span class="line">	u_int i;</span><br><span class="line">	ffd = (<span class="keyword">struct</span> Filefd *)fd;</span><br><span class="line">	fileid = ffd-&gt;f_fileid;</span><br><span class="line">	size = ffd-&gt;f_file.f_size;</span><br><span class="line">	<span class="comment">// Set the start address storing the file's content.</span></span><br><span class="line">	va = fd2data(fd);</span><br><span class="line">	<span class="comment">// Tell the file server the dirty page.</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i += BY2PG) {</span><br><span class="line">		fsipc_dirty(fileid, i);</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// Request the file server to close the file with fsipc.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = fsipc_close(fileid)) &lt; <span class="number">0</span>) {</span><br><span class="line">		writef(<span class="string">"cannot close the file\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// Unmap the content of file, release memory.</span></span><br><span class="line">	<span class="keyword">if</span> (size == <span class="number">0</span>) {</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i += BY2PG) {</span><br><span class="line">		<span class="keyword">if</span> ((r = syscall_mem_unmap(<span class="number">0</span>, va + i)) &lt; <span class="number">0</span>) {</span><br><span class="line">			writef(<span class="string">"cannont unmap the file.\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="file-read"><a href="#file-read" class="headerlink" title="file_read"></a>file_read</h4><p>将文件中offset开始的n个字节读入到buf中，然后返回读进来的字符数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//	Read 'n' bytes from 'fd' at the current seek position into 'buf'. Since files</span></span><br><span class="line"><span class="comment">//	are memory-mapped, this amounts to a user_bcopy() surrounded by a little red</span></span><br><span class="line"><span class="comment">//	tape to handle the file size and seek pointer.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">file_read</span><span class="params">(<span class="keyword">struct</span> Fd *fd, <span class="type">void</span> *buf, u_int n, u_int offset)</span></span><br><span class="line">{</span><br><span class="line">	u_int size;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">f</span>;</span></span><br><span class="line">	f = (<span class="keyword">struct</span> Filefd *)fd;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Avoid reading past the end of file.</span></span><br><span class="line">	size = f-&gt;f_file.f_size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (offset &gt; size) {</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (offset + n &gt; size) {</span><br><span class="line">		n = size - offset;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	user_bcopy((<span class="type">char</span> *)fd2data(fd) + offset, buf, n);</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="read-map"><a href="#read-map" class="headerlink" title="read_map"></a>read_map</h4><p>函数功能：找到fdnum对应的文件数据从offset开始，将这个地址交给blk</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//	Find the virtual address of the page that maps the file block</span></span><br><span class="line"><span class="comment">//	starting at 'offset'.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">read_map</span><span class="params">(<span class="type">int</span> fdnum, u_int offset, <span class="type">void</span> **blk)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	u_int va;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span>) {</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fd-&gt;fd_dev_id != devfile.dev_id) {</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	va = fd2data(fd) + offset;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (offset &gt;= MAXFILESIZE) {</span><br><span class="line">		<span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!((* vpd)[PDX(va)]&amp;PTE_V) || !((* vpt)[VPN(va)]&amp;PTE_V)) {</span><br><span class="line">		<span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	*blk = (<span class="type">void</span> *)va;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="file-write"><a href="#file-write" class="headerlink" title="file_write"></a>file_write</h4><p>在文件offset开始的位置写n个字节</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//	Write 'n' bytes from 'buf' to 'fd' at the current seek position.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">file_write</span><span class="params">(<span class="keyword">struct</span> Fd *fd, <span class="type">const</span> <span class="type">void</span> *buf, u_int n, u_int offset)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	u_int tot;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">	f = (<span class="keyword">struct</span> Filefd *)fd;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Don't write more than the maximum file size.</span></span><br><span class="line">	tot = offset + n;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tot &gt; MAXFILESIZE) {</span><br><span class="line">		<span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Increase the file's size if necessary</span></span><br><span class="line">	<span class="keyword">if</span> (tot &gt; f-&gt;f_file.f_size) {</span><br><span class="line">		<span class="keyword">if</span> ((r = ftruncate(fd2num(fd), tot)) &lt; <span class="number">0</span>) {<span class="comment">//这里可以对文件大小进行扩充</span></span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Write the data</span></span><br><span class="line">	user_bcopy(buf, (<span class="type">char</span> *)fd2data(fd) + offset, n);</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="file-stat"><a href="#file-stat" class="headerlink" title="file_stat"></a>file_stat</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">file_stat</span><span class="params">(<span class="keyword">struct</span> Fd *fd, <span class="keyword">struct</span> Stat *st)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">	f = (<span class="keyword">struct</span> Filefd *)fd;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strcpy</span>(st-&gt;st_name, (<span class="type">char</span> *)f-&gt;f_file.f_name);</span><br><span class="line">	st-&gt;st_size = f-&gt;f_file.f_size;</span><br><span class="line">	st-&gt;st_isdir = f-&gt;f_file.f_type == FTYPE_DIR;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="ftruncate"><a href="#ftruncate" class="headerlink" title="ftruncate"></a>ftruncate</h4><p>函数功能：这个里面有两个步骤，如果需要对于文件大小进行扩展的话，需要对新的内容分配新的页面；如果需要对文件大小进行缩减的话，需要取消映射释放资源</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//	Truncate or extend an open file to 'size' bytes</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">ftruncate</span><span class="params">(<span class="type">int</span> fdnum, u_int size)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> i, r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">f</span>;</span></span><br><span class="line">	u_int oldsize, va, fileid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (size &gt; MAXFILESIZE) {</span><br><span class="line">		<span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span>) {<span class="comment">//找到文件</span></span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fd-&gt;fd_dev_id != devfile.dev_id) {</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	f = (<span class="keyword">struct</span> Filefd *)fd;</span><br><span class="line">	fileid = f-&gt;f_fileid;</span><br><span class="line">	oldsize = f-&gt;f_file.f_size;</span><br><span class="line">	f-&gt;f_file.f_size = size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = fsipc_set_size(fileid, size)) &lt; <span class="number">0</span>) {</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	va = fd2data(fd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Map any new pages needed if extending the file</span></span><br><span class="line">	<span class="keyword">for</span> (i = ROUND(oldsize, BY2PG); i &lt; ROUND(size, BY2PG); i += BY2PG) {</span><br><span class="line">		<span class="keyword">if</span> ((r = fsipc_map(fileid, i, va + i)) &lt; <span class="number">0</span>) {<span class="comment">//如果文件大小扩充失败</span></span><br><span class="line">			fsipc_set_size(fileid, oldsize);</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Unmap pages if truncating the file</span></span><br><span class="line">	<span class="keyword">for</span> (i = ROUND(size, BY2PG); i &lt; ROUND(oldsize, BY2PG); i += BY2PG)</span><br><span class="line">		<span class="keyword">if</span> ((r = syscall_mem_unmap(<span class="number">0</span>, va + i)) &lt; <span class="number">0</span>) {</span><br><span class="line">			user_panic(<span class="string">"ftruncate: syscall_mem_unmap %08x: %e"</span>, va + i, r);</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//	Delete a file or directory.</span></span><br><span class="line"><span class="comment">/*** exercise 5.10 ***/</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">// Your code here.</span></span><br><span class="line">	<span class="comment">// Call fsipc_remove.</span></span><br><span class="line">	<span class="keyword">return</span> fsipc_remove(path);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//	Synchronize disk with buffer cache</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sync</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> fsipc_sync();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="user-pipe-c"><a href="#user-pipe-c" class="headerlink" title="user/pipe.c"></a><code>user/pipe.c</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> <span class="title">devpipe</span> =</span> {</span><br><span class="line">	.dev_id =	<span class="string">'p'</span>,</span><br><span class="line">	.dev_name =	<span class="string">"pipe"</span>,</span><br><span class="line">	.dev_read =	<span class="literal">NULL</span>,</span><br><span class="line">	.dev_write = <span class="literal">NULL</span>,</span><br><span class="line">	.dev_close = <span class="literal">NULL</span>,</span><br><span class="line">	.dev_stat =	<span class="literal">NULL</span>,</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BY2PIPE 32		<span class="comment">// small to provoke races</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pipe</span> {</span></span><br><span class="line">	u_int p_rpos;		    <span class="comment">// read position</span></span><br><span class="line">	u_int p_wpos;		    <span class="comment">// write position</span></span><br><span class="line">	u_char p_buf[BY2PIPE];	<span class="comment">// data buffer</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h2 id="user-console-c"><a href="#user-console-c" class="headerlink" title="user/console.c"></a><code>user/console.c</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> <span class="title">devcons</span> =</span> {</span><br><span class="line">	.dev_id =	<span class="string">'c'</span>,</span><br><span class="line">	.dev_name =	<span class="string">"cons"</span>,</span><br><span class="line">	.dev_read =	<span class="literal">NULL</span>,</span><br><span class="line">	.dev_write =	<span class="literal">NULL</span>,</span><br><span class="line">	.dev_close =	<span class="literal">NULL</span>,</span><br><span class="line">	.dev_stat =	<span class="literal">NULL</span>,</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li><p>diskno是如何对应一块块磁盘的呢？比如实验中我们只有一块磁盘，但是考试中新增了几块磁盘。使用不同的diskno可以对应不同的磁盘，这是如何做到的呢？</p>
</li>
<li><p>fsformat.c 中，create_file</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nblk = dirf -&gt; f_size / BY2BLK;</span><br></pre></td></tr></table></figure>
<p>含义是nblk=当前目录的大小除以一个块字节大小（算出已经使用了多少个块）。这里直接使用的是/号，没有做向上取整，说明nblk所在文件指针可能有东西。</p>
</li>
<li><p>拼错单词了fsformat</p>
<p><img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20220605140130015.png" alt="image-20220605140130015"></p>
</li>
<li><p>fsformat write file 中，fname不是const char 吗为什么还能++</p>
</li>
<li><p>user/fd.h中定义FILEBASE和fs/serv.c中定义FILEVA都是0x60000000，这两者有什么区别和联系吗？serv中的FILEVA是在文件服务进程中，FILEBASE定义的是啥呀</p>
</li>
<li><p>使用fd的时候这是哪个进程呀</p>
</li>
<li><p>从什么过程开始文件内容是按照顺序排开的？（至少在用户进程中是排开的）</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>BUAA_OS</tag>
      </tags>
  </entry>
</search>
