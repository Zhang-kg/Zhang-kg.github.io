<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>超算学习讲座经验分享</title>
      <link href="/2023/04/02/2023-4-2-%E8%B6%85%E7%AE%97%E5%AD%A6%E4%B9%A0%E8%AE%B2%E5%BA%A7%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
      <url>/2023/04/02/2023-4-2-%E8%B6%85%E7%AE%97%E5%AD%A6%E4%B9%A0%E8%AE%B2%E5%BA%A7%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="讲座分享"><a href="#讲座分享" class="headerlink" title="讲座分享"></a>讲座分享</h1><h2 id="ChatGPT"><a href="#ChatGPT" class="headerlink" title="ChatGPT"></a>ChatGPT</h2><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p><a href="https://zhuanlan.zhihu.com/p/420311740">怒肝 Linux 学习路线，这回不难 - 知乎 (zhihu.com)</a></p><p><strong>你的 Linux</strong></p><ul><li>WSL</li><li>虚拟机（Vmware）</li></ul><p><strong>命令</strong></p><p><code>cd</code>、<code>ls</code>、<code>grep</code>、<code>sed</code>、<code>awk</code>、<code>find</code>、<code>cp</code>、<code>mv</code>、<code>rm</code>、<code>kill</code>、<code>cat</code>、<code>chmod</code>、<code>time</code></p><p><strong>包管理器</strong></p><p><a href="https://zhuanlan.zhihu.com/p/28562152">Linux 包管理基础：apt、yum、dnf 和 pkg - 知乎 (zhihu.com)</a></p><p><a href="https://www.zhihu.com/question/516279342">(1 封私信 / 8 条消息) Linux 发行版中哪个包管理器更强？ - 知乎 (zhihu.com)</a></p><p><a href="https://linux.cn/article-12713-1.html">技术|Linux 黑话解释：什么是包管理器？它是如何工作的？</a></p><p><a href="https://linux.cn/article-7758-1.html">技术|5 个给 Linux 新手的最佳包管理器</a></p><p><strong>编译器</strong></p><p><a href="https://zhuanlan.zhihu.com/p/76930507">Linux编译工具：gcc入门 - 知乎 (zhihu.com)</a></p><p><strong>编辑器</strong></p><p>vim：<a href="http://c.biancheng.net/view/805.html">Linux Vim基本操作（文件的打开和编辑）完全攻略（有图有真相） (biancheng.net)</a></p><p><strong>shell 编程</strong></p><p><a href="https://www.runoob.com/linux/linux-shell.html">Shell 教程 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/35465182">Linux shell编程基础，一看就能入门 - 知乎 (zhihu.com)</a></p><p><strong>其他资源</strong></p><p>书：《鸟哥的 Linux 私房菜》《CSAPP》</p><p>课程：<a href="https://missing-semester-cn.github.io/">计算机教育中缺失的一课 · the missing semester of your cs education (missing-semester-cn.github.io)</a></p><h2 id="MPI"><a href="#MPI" class="headerlink" title="MPI"></a>MPI</h2><ul><li><p>MPI 官网：<a href="https://www.mpi-forum.org/">https://www.mpi-forum.org/</a></p></li><li><p>非常好的 MPI 教程：<a href="https://mpitutorial.com/tutorials/">https://mpitutorial.com/tutorials/</a></p></li><li><p>知乎文章：<a href="https://zhuanlan.zhihu.com/p/355652501">https://zhuanlan.zhihu.com/p/355652501</a></p></li><li><a href="https://zhuanlan.zhihu.com/p/158584571">https://zhuanlan.zhihu.com/p/158584571</a></li></ul><h2 id="OpenMP"><a href="#OpenMP" class="headerlink" title="OpenMP"></a>OpenMP</h2><p><a href="https://www.zhihu.com/column/c_1405840398661521408">https://www.zhihu.com/column/c_1405840398661521408</a></p><p><a href="https://blog.csdn.net/qq_30024069/article/details/93355022">https://blog.csdn.net/qq_30024069/article/details/93355022</a></p><h2 id="SIMD"><a href="#SIMD" class="headerlink" title="SIMD"></a>SIMD</h2><ul><li><p>有一个综述：<a href="https://blog.csdn.net/tywwwww/article/details/126944286">https://blog.csdn.net/tywwwww/article/details/126944286</a></p></li><li><p>基本的讲解+小例子：<a href="https://zhuanlan.zhihu.com/p/514966360">https://zhuanlan.zhihu.com/p/514966360</a></p></li><li><a href="https://zhuanlan.zhihu.com/p/591900754">https://zhuanlan.zhihu.com/p/591900754</a></li></ul><h2 id="Pthread"><a href="#Pthread" class="headerlink" title="Pthread"></a>Pthread</h2><ul><li><p>B 站视频</p></li><li><p>菜鸟教程：<a href="https://www.runoob.com/cplusplus/cpp-multithreading.html">https://www.runoob.com/cplusplus/cpp-multithreading.html</a></p></li><li><p>一个小例子：<a href="https://zhuanlan.zhihu.com/p/112297714">https://zhuanlan.zhihu.com/p/112297714</a></p></li></ul><h2 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h2><ul><li>Intel CPU 架构演进：<a href="https://zhuanlan.zhihu.com/p/515658946">https://zhuanlan.zhihu.com/p/515658946</a></li><li>NVIDIA GPU 架构：</li><li>书籍：《CSAPP》</li><li>课程：UC Berkeley CS267</li></ul><h2 id="CUDA"><a href="#CUDA" class="headerlink" title="CUDA"></a>CUDA</h2><ul><li><p>博客：（非常多，看两个熟悉一下路线就行）</p><ul><li><a href="https://zhuanlan.zhihu.com/p/346910129">https://zhuanlan.zhihu.com/p/346910129</a></li><li><a href="https://zhuanlan.zhihu.com/p/273607744">https://zhuanlan.zhihu.com/p/273607744</a></li></ul></li><li><p>课程：NVIDIA&amp;UDACITY CS344；uiuc ece 408</p></li><li>书籍：上面两篇博客中说了很多</li></ul><h2 id="HPC-AI"><a href="#HPC-AI" class="headerlink" title="HPC+AI"></a>HPC+AI</h2><ul><li>bing 搜索 HPC+AI会出来很多综述类型的文章，建议看一看</li><li>“ai for system” and “system for ai”</li><li>大模型、多机（人工智能研究院的老师同学可以问一问</li></ul><h2 id="多学科交叉"><a href="#多学科交叉" class="headerlink" title="多学科交叉"></a>多学科交叉</h2><ul><li>HPC 应用</li><li>物理专业</li><li>化学专业</li><li>飞行器设计等</li></ul><h2 id="查找资料过程中发现的-blogger"><a href="#查找资料过程中发现的-blogger" class="headerlink" title="查找资料过程中发现的 blogger"></a>查找资料过程中发现的 blogger</h2><ul><li><a href="https://www.zhihu.com/people/xusworld/posts">https://www.zhihu.com/people/xusworld/posts</a></li></ul><h2 id="实习or导师"><a href="#实习or导师" class="headerlink" title="实习or导师"></a>实习or导师</h2><ul><li><p>北航</p></li><li><p>中科院、清华</p></li><li>大厂</li></ul>]]></content>
      
      
      <categories>
          
          <category> HPC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超算学习路线&amp;资源</title>
      <link href="/2023/04/01/2023-4-1-%E8%B6%85%E7%AE%97%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
      <url>/2023/04/01/2023-4-1-%E8%B6%85%E7%AE%97%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="超算-HPC"><a href="#超算-HPC" class="headerlink" title="超算 HPC"></a>超算 HPC</h1><blockquote><p>整理自：Zhang-kg</p></blockquote><h2 id="学习路线资源"><a href="#学习路线资源" class="headerlink" title="学习路线资源"></a>学习路线资源</h2><h3 id="时刻温故"><a href="#时刻温故" class="headerlink" title="时刻温故"></a>时刻温故</h3><p>（重要）<a href="https://www.zhihu.com/question/33576416">请问高性能计算的学习路线应该是怎样的？</a></p><ul><li><strong>（推荐）</strong>请问高性能计算的学习路线应该是怎样的？ - 陈清扬的回答 - 知乎 <a href="https://www.zhihu.com/question/33576416/answer/1243835966">https://www.zhihu.com/question/33576416/answer/1243835966</a></li><li>请问高性能计算的学习路线应该是怎样的？ - Xiao Song的回答 - 知乎 <a href="https://www.zhihu.com/question/33576416/answer/2205280528">https://www.zhihu.com/question/33576416/answer/2205280528</a></li><li>请问高性能计算的学习路线应该是怎样的？ - Max Lv的回答 - 知乎 <a href="https://www.zhihu.com/question/33576416/answer/56922690">https://www.zhihu.com/question/33576416/answer/56922690</a></li><li><strong>（推荐）</strong>请问高性能计算的学习路线应该是怎样的？ - 溪亭日暮的回答 - 知乎 <a href="https://www.zhihu.com/question/33576416/answer/2187630184">https://www.zhihu.com/question/33576416/answer/2187630184</a></li><li></li></ul><p>（重要）<a href="https://www.zhihu.com/question/525995150">想进大厂的高性能计算岗位需要做哪些准备？</a></p><p>（重要）<a href="https://www.zhihu.com/question/481648758/answer/2206937333">高性能计算工程师需要什么技术堆栈？ opencl dsp neon perf profile tvm？</a></p><p>（入门）<a href="https://zhuanlan.zhihu.com/p/146506682">高性能编程系列(一) - 知乎 (zhihu.com)</a></p><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/503037055">从零开始的C/C++高性能编程指南 - 知乎 (zhihu.com)</a></li><li><a href="https://www.zhihu.com/column/c_1477236044101353472">C++高性能编程笔记 - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/533708198">C++ 高性能编程实战（一）：整体视角 - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/445001969">现代C++中的高性能并行编程与优化 - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/493913130">高性能并行编程与优化(一):学C++从CMake学起 - 知乎 (zhihu.com)</a></li></ul><h3 id="深度学习框架底层"><a href="#深度学习框架底层" class="headerlink" title="深度学习框架底层"></a>深度学习框架底层</h3><ul><li><p>知乎系列文章合集1：<a href="https://www.zhihu.com/column/c_1386460843089981440">https://www.zhihu.com/column/c_1386460843089981440</a></p><ul><li><a href="https://zhuanlan.zhihu.com/p/435024770">深度学习框架（三）：底层运行机制</a></li></ul></li><li><p>知乎系列文章合集2：如何最简单、通俗地理解Transformer？ - 鱼先生的回答 - 知乎 <a href="https://www.zhihu.com/question/445556653/answer/2882383919">https://www.zhihu.com/question/445556653/answer/2882383919</a></p></li></ul><h3 id="GPU-架构"><a href="#GPU-架构" class="headerlink" title="GPU 架构"></a>GPU 架构</h3><p><a href="https://zhuanlan.zhihu.com/p/403345668">【GPU】目录与前言 - 知乎 (zhihu.com)</a></p><h3 id="GPU-编程"><a href="#GPU-编程" class="headerlink" title="GPU 编程"></a>GPU 编程</h3><ul><li><p><a href="https://zhuanlan.zhihu.com/p/129308719">GPU编程入门 - 知乎 (zhihu.com)</a></p></li><li><p><a href="https://lulaoshi.info/gpu/python-cuda/cuda-intro.html#gpu程序与cpu程序的区别">初识GPU编程 | 鲁老师 (lulaoshi.info)</a></p></li><li><p>B站资源：</p><ul><li><p><a href="https://www.bilibili.com/video/BV1vJ411D73S/?p=8&amp;spm_id_from=pageDriver&amp;vd_source=004adbd5ffedd22db638131ba0059a6d">8. CUDA 编程入门 04-1 - 内存管理 代码示例_哔哩哔哩_bilibili</a></p></li><li><p><a href="https://www.bilibili.com/video/BV147411c7Fq/?spm_id_from=333.788.recommend_more_video.2&amp;vd_source=004adbd5ffedd22db638131ba0059a6d">cuda 大师班_哔哩哔哩_bilibili</a></p><ul><li>对应的 Github 网站：<a href="https://github.com/zhangasia/cuda_masterclass">https://github.com/zhangasia/cuda_masterclass</a></li></ul></li></ul></li><li><p><a href="https://blog.csdn.net/zengNLP/article/details/127722076">【AI实战】CUDA 编程入门及开源项目代码分享</a></p></li></ul><h3 id="Intel-Data-Parallel-C-and-SYCL-2020-Tutorial"><a href="#Intel-Data-Parallel-C-and-SYCL-2020-Tutorial" class="headerlink" title="Intel Data Parallel C++ (and SYCL 2020) Tutorial"></a>Intel Data Parallel C++ (and SYCL 2020) Tutorial</h3><p><a href="https://github.com/jeffhammond/dpcpp-tutorial">GitHub - jeffhammond/dpcpp-tutorial: Intel Data Parallel C++ (and SYCL 2020) Tutorial.</a></p><p><a href="https://www.intel.cn/content/www/cn/zh/developer/articles/training/programming-data-parallel-c.html#gs.p4n1j4">Tutorial: Program Data Parallel C++ (SYCL) (intel.cn)</a></p><p><a href="https://zhuanlan.zhihu.com/p/27383571">机器学习的新捷径：通过 SYCL 在 GPU 上加速 C++ - 知乎 (zhihu.com)</a></p><h3 id="CMAKE"><a href="#CMAKE" class="headerlink" title="CMAKE"></a>CMAKE</h3><p>CMAKE 官网：<a href="https://cmake.org/">CMake</a></p><p>网页文档资源：</p><p><a href="https://zhuanlan.zhihu.com/p/500002865">CMake 良心教程，教你从入门到入魂 - 知乎 (zhihu.com)</a></p><p><a href="https://www.zhihu.com/question/58949190">(17 条消息) CMake 如何入门？ - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/119426899">CMake教程（一） - 知乎 (zhihu.com)</a></p><p><a href="https://cmake.org/cmake/help/v3.17/guide/tutorial/index.html">官网文档</a></p><p><a href="https://www.cnblogs.com/ybqjymy/p/13409050.html">超详细的CMake教程 - 一杯清酒邀明月 - 博客园 (cnblogs.com)</a></p><p>书籍资源：</p><p>CMake 实践：<a href="http://file.ncnynl.com/ros/CMake Practice.pdf">CMake Practice.pdf (ncnynl.com)</a></p><p>代码示例：</p><p><a href="https://github.com/ttroy50/cmake-examples">GitHub - ttroy50/cmake-examples: Useful CMake Examples</a></p><p>其他相关资源：</p><p><a href="https://zhuanlan.zhihu.com/p/492470515">轻松打造 Qt Creator 开发环境（Qt5.14+CMake3.22+OpenCV4.5） - 知乎 (zhihu.com)</a></p><h2 id="书籍资源"><a href="#书籍资源" class="headerlink" title="书籍资源"></a>书籍资源</h2><h3 id="CSAPP"><a href="#CSAPP" class="headerlink" title="CSAPP"></a>CSAPP</h3><blockquote><p>链接：<a href="https://fengmuzi2003.gitbook.io/csapp3e/">https://fengmuzi2003.gitbook.io/csapp3e/</a></p></blockquote><h3 id="计算机体系结构-量化研究方法"><a href="#计算机体系结构-量化研究方法" class="headerlink" title="计算机体系结构-量化研究方法"></a>计算机体系结构-量化研究方法</h3><h3 id="CUDA-编程书籍"><a href="#CUDA-编程书籍" class="headerlink" title="CUDA 编程书籍"></a>CUDA 编程书籍</h3><ul><li>CUDA 编程入门书籍推荐 - jie.hang的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/564805080">https://zhuanlan.zhihu.com/p/564805080</a></li></ul><h4 id="CUDA-C-Programming-Guide"><a href="#CUDA-C-Programming-Guide" class="headerlink" title="CUDA C Programming Guide"></a>CUDA C Programming Guide</h4><ul><li><p><strong>CUDA_C_Programming_Guide：</strong><a href="https://docs.nvidia.com/cuda/pdf/CUDA_C_Programming_Guide.pdf">CUDA C++ Programming Guide (nvidia.com)</a></p></li><li><p><strong>博客文章1：</strong><a href="https://www.jianshu.com/p/03e463cf272b">CUDA C Programming Guide - 简书 (jianshu.com)</a></p></li></ul><h4 id="CUDA-Toolkit-Documentation"><a href="#CUDA-Toolkit-Documentation" class="headerlink" title="CUDA Toolkit Documentation"></a>CUDA Toolkit Documentation</h4><ul><li><p>链接：<a href="https://docs.nvidia.com/cuda/">CUDA Toolkit Documentation 12.0 Update 1 (nvidia.com)</a></p></li><li><p><strong>NVCC：</strong><a href="https://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html">NVCC (nvidia.com)</a></p></li></ul><h3 id="大规模并行处理器编程实战第二版"><a href="#大规模并行处理器编程实战第二版" class="headerlink" title="大规模并行处理器编程实战第二版"></a>大规模并行处理器编程实战第二版</h3><blockquote><p>链接：<a href="https://www.cnblogs.com/yuxiaolan/p/15249883.html">https://www.cnblogs.com/yuxiaolan/p/15249883.html</a></p></blockquote><h2 id="课程资源"><a href="#课程资源" class="headerlink" title="课程资源"></a>课程资源</h2><blockquote><p>简介：在知乎上有总结好的课程链接</p><p><a href="https://zhuanlan.zhihu.com/p/86414564">https://zhuanlan.zhihu.com/p/86414564</a></p><p>包含斯坦福大学、MIT、卡耐基梅隆大学、伊利诺伊大学香槟分校 UIUC、康奈尔大学 Cornell、普林斯顿大学 Princeton、华盛顿大学 UW、德州大学奥斯汀分校 UT Austin</p></blockquote><h3 id="NVIDIA-amp-UDACITY-CS344"><a href="#NVIDIA-amp-UDACITY-CS344" class="headerlink" title="NVIDIA &amp; UDACITY CS344"></a>NVIDIA &amp; UDACITY CS344</h3><p><strong>Intro to Parallel Programming：</strong>这个是 Nvidia 和 Udacity 联合退出的课程，年代比较久远</p><p><strong>Nvidia 课程官网：</strong><a href="https://developer.nvidia.com/udacity-cs344-intro-parallel-programming">https://developer.nvidia.com/udacity-cs344-intro-parallel-programming</a></p><p><strong>Udacity 课程官网：</strong><a href="https://www.udacity.com/blog/2014/01/update-on-udacity-cs344-intro-to.html">https://www.udacity.com/blog/2014/01/update-on-udacity-cs344-intro-to.html</a></p><p><strong>课程视频下载网站：</strong><a href="https://www.udacity.com/wiki/cs344/downloads">https://www.udacity.com/wiki/cs344/downloads</a></p><p><strong>Udacity github 页面（课程代码、课件、问题）：</strong><a href="https://github.com/udacity/cs344">https://github.com/udacity/cs344</a></p><p><strong>博客链接1：</strong><a href="https://testerhome.com/articles/29151">Udacity CS344 并行计算入门（一）</a></p><p><strong>博客链接2：</strong><a href="https://zhuanlan.zhihu.com/p/56374118">白嫖Google GPU完成Udacity CUDA CS344 并行计算入门</a></p><h3 id="ECS-CS-508-Manycore-Parallel-Algorithms"><a href="#ECS-CS-508-Manycore-Parallel-Algorithms" class="headerlink" title="ECS/CS 508 Manycore Parallel Algorithms"></a>ECS/CS 508 Manycore Parallel Algorithms</h3><p>课程网站链接：<a href="http://lumetta.web.engr.illinois.edu/508/">ECE/CS 508: Manycore Parallel Algorithms (illinois.edu)</a></p><p>github仓库：<a href="https://github.com/illinois-impact/gpu-algorithms-labs">GitHub - illinois-impact/gpu-algorithms-labs: IMPACT GPU Algorithms Teaching Labs</a></p><h3 id="UC-Berkeley-知乎课程总结"><a href="#UC-Berkeley-知乎课程总结" class="headerlink" title="UC Berkeley 知乎课程总结"></a>UC Berkeley 知乎课程总结</h3><p>知乎链接：<a href="https://zhuanlan.zhihu.com/p/102083014">https://zhuanlan.zhihu.com/p/102083014</a></p><h4 id="CS-9E-Productive-Use-of-the-UNIX-Environment"><a href="#CS-9E-Productive-Use-of-the-UNIX-Environment" class="headerlink" title="CS 9E: Productive Use of the UNIX Environment"></a>CS 9E: Productive Use of the UNIX Environment</h4><p>课程链接：<a href="https://www-inst.eecs.berkeley.edu//~selfpace/unix/">https://www-inst.eecs.berkeley.edu//~selfpace/unix/</a></p><h3 id="UC-Berkeley-CS267"><a href="#UC-Berkeley-CS267" class="headerlink" title="UC Berkeley CS267"></a>UC Berkeley CS267</h3><blockquote><p>Applications of Parallel Computers</p></blockquote><p>课程链接：<a href="https://sites.google.com/lbl.gov/cs267-spr2023/">https://sites.google.com/lbl.gov/cs267-spr2023/</a></p><p><strong>博客链接1：</strong><a href="https://testerhome.com/articles/29784">UCB CS267（并行计算）L2 内存结构和矩阵乘法</a></p><h3 id="US-Berkeley-CS273"><a href="#US-Berkeley-CS273" class="headerlink" title="US Berkeley CS273"></a>US Berkeley CS273</h3><p>课程链接：<a href="https://people.eecs.berkeley.edu/~satishr/cs273/">https://people.eecs.berkeley.edu/~satishr/cs273/</a></p><h3 id="CMU-15-418-15-618"><a href="#CMU-15-418-15-618" class="headerlink" title="CMU 15-418/15-618"></a>CMU 15-418/15-618</h3><blockquote><p>简介：<a href="https://blog.csdn.net/wwxy1995/article/details/113918392">https://blog.csdn.net/wwxy1995/article/details/113918392</a></p><p>这门课有三次作业和四次project，作业都是独自完成，project都是组队完成（2-3人）。基本上作业就是帮你熟悉project的开发环境，跑一个sample program再把输出结果提交上去。而project相对有意思一点，前三次project各自对应课程的三大块内容，要求你用OpenMP, CUDA 以及 MapReduce来优化一个基础算法(矩阵乘法、K-means、N-gram)，project的评分参照两点：你的优化程序相对于原始算法的运算速度，以及你的程序相对于别的小组的程序的运算速度。做得最好的team还可以去做presentaion，给大家讲你们的优化思路XD. 第四个project要求你自行选题，用课程学到的parallel computing的方法去优化一个实际算法，并且写一篇小论文。 我们组当时选的是中值滤波，把三个方法都用了一遍，发现还是mapreduce 大法好:)。 总的来说这门课的缺点在于课程内容太浅，project也没有什么锻炼量，如果ECE的同学想找一门不是太水的水课来抵学分，那还是可以一上的。</p></blockquote><p>课程链接：<a href="http://www.cs.cmu.edu/~418/schedule.html">http://www.cs.cmu.edu/~418/schedule.html</a></p><h3 id="CSE-6220：Intro-to-High-Performance-Computing"><a href="#CSE-6220：Intro-to-High-Performance-Computing" class="headerlink" title="CSE 6220：Intro to High-Performance Computing"></a>CSE 6220：Intro to High-Performance Computing</h3><p>佐治亚理工学院</p><ul><li>课程链接：<a href="https://omscs.gatech.edu/cse-6220-intro-hpc">https://omscs.gatech.edu/cse-6220-intro-hpc</a></li><li>23年课程：<a href="https://cse6220.gatech.edu/sp23-oms/#">https://cse6220.gatech.edu/sp23-oms/#</a></li></ul><h2 id="其他技术资源"><a href="#其他技术资源" class="headerlink" title="其他技术资源"></a>其他技术资源</h2><h3 id="知乎优秀博主"><a href="#知乎优秀博主" class="headerlink" title="知乎优秀博主"></a>知乎优秀博主</h3><p><a href="https://www.zhihu.com/people/jackhay">https://www.zhihu.com/people/jackhay</a></p><h3 id="Github-优秀仓库"><a href="#Github-优秀仓库" class="headerlink" title="Github 优秀仓库"></a>Github 优秀仓库</h3><p><a href="https://github.com/PrathameshTugaonkar/SPMV">GitHub - PrathameshTugaonkar/SPMV: BFS SPMV Parallel implementation</a></p><p><a href="https://github.com/NVIDIA/cutlass">GitHub - NVIDIA/cutlass: CUDA Templates for Linear Algebra Subroutines</a></p><p><a href="https://github.com/alibaba/EasyNLP">GitHub - alibaba/EasyNLP: EasyNLP: A Comprehensive and Easy-to-use NLP Toolkit</a></p><h3 id="OpenCV"><a href="#OpenCV" class="headerlink" title="OpenCV"></a>OpenCV</h3><p><strong>OpenCV官网：</strong><a href="https://opencv.org/">https://opencv.org/</a></p><p><strong>安装：</strong></p><ul><li><a href="https://www.sohu.com/a/423084898_823210">OpenCV4.4 CUDA编译与加速全解析</a></li><li><a href="https://zhuanlan.zhihu.com/p/31784840">OpenCV学习笔记（一） OpenCV简介及安装</a></li><li><a href="https://blog.csdn.net/catpico/article/details/123168094">安装支持cuda的OpenCV过程记录</a></li><li><a href="https://blog.csdn.net/qq_39567427/article/details/126230952">Win10 OpenCV编译安装CUDA版本</a></li><li></li></ul><p><strong>使用：</strong></p><ul><li><a href="https://www.zhihu.com/column/c_147125547">OpenCV 学习笔记-知乎</a></li><li><a href="https://blog.csdn.net/weixin_35756624/article/details/128872146">opencv怎么使用GPU加速</a></li></ul><h3 id="Visual-Studio-搭载-CMake"><a href="#Visual-Studio-搭载-CMake" class="headerlink" title="Visual Studio 搭载 CMake"></a>Visual Studio 搭载 CMake</h3><p><strong>使用：</strong></p><ul><li><a href="https://learn.microsoft.com/zh-cn/cpp/build/cmake-projects-in-visual-studio?view=msvc-160">Visual Studio 中的 CMake 项目</a></li></ul><h2 id="前沿领域"><a href="#前沿领域" class="headerlink" title="前沿领域"></a>前沿领域</h2><p>目前计划是看期刊文章，初步了解。</p><h2 id="未来发展"><a href="#未来发展" class="headerlink" title="未来发展"></a>未来发展</h2><p>计算机研究生的方向和学校以及导师的选择(AI和高性能计算)？ - Spicy Wang的回答 - 知乎 <a href="https://www.zhihu.com/question/287071232/answer/1546802966">https://www.zhihu.com/question/287071232/answer/1546802966</a></p><h3 id="清华"><a href="#清华" class="headerlink" title="清华"></a>清华</h3><h3 id="北大"><a href="#北大" class="headerlink" title="北大"></a>北大</h3><h3 id="中科院计算所导师"><a href="#中科院计算所导师" class="headerlink" title="中科院计算所导师"></a>中科院计算所导师</h3><ul><li>陈莉老师-处理器芯片重点实验室（并行编程语言；并行编译技术和工具）：<a href="http://www.ict.cas.cn/sourcedb_2018_ict_cas/cn/jssrck/200909/t20090917_2496592.html">陈莉—中国科学院计算技术研究所 (cas.cn)</a></li><li>何鑫老师-高性能计算机研究中心、处理器芯片重点实验室（科学计算；高性能计算；数值分析；软件开发；计算流体力学）：<a href="http://www.ict.cas.cn/sourcedb_2018_ict_cas/cn/jssrck/201706/t20170620_4815687.html">何鑫—中国科学院计算技术研究所 (cas.cn)</a></li><li>霍志刚老师（高性能计算机体系结构；操作系统；容错计算）：<a href="http://www.ict.cas.cn/sourcedb_2018_ict_cas/cn/jssrck/200911/t20091102_2645338.html">霍志刚—中国科学院计算技术研究所 (cas.cn)</a></li><li>贾海鹏老师-高性能计算机研究中心（高性能计算；面向多核/众核计算平台的编程与优化方法）：<a href="http://www.ict.cas.cn/sourcedb_2018_ict_cas/cn/jssrck/201912/t20191209_5451110.html">贾海鹏—中国科学院计算技术研究所 (cas.cn)</a></li><li>刘宇航老师-先进计算机系统研究中心、处理器芯片重点实验室（计算机体系结构；存储系统；高性能计算；数据科学；智能并发系统；（研究组主页：liuyuhang.cc））：<a href="http://www.ict.cas.cn/sourcedb_2018_ict_cas/cn/jssrck/201711/t20171114_4894348.html">刘宇航—中国科学院计算技术研究所 (cas.cn)</a></li><li>马捷老师-科研支撑中心（高性能计算机系统）：<a href="http://www.ict.cas.cn/sourcedb_2018_ict_cas/cn/jssrck/200909/t20090917_2496689.html">马捷—中国科学院计算技术研究所 (cas.cn)</a></li><li>商红慧老师-高性能计算机研究中心（高性能并行算法设计与优化；智能超算（HPC+AI）；科学计算方法）：<a href="http://www.ict.cas.cn/sourcedb_2018_ict_cas/cn/jssrck/202003/t20200310_5509321.html">商红慧—中国科学院计算技术研究所 (cas.cn)</a></li><li>邵恩老师-高性能计算机研究中心、处理器芯片重点实验室（计算机系统结构；系统软件）：<a href="http://www.ict.cas.cn/sourcedb_2018_ict_cas/cn/jssrck/202010/t20201023_5721592.html">邵恩—中国科学院计算技术研究所 (cas.cn)</a></li><li>王展老师-高性能计算机研究中心（高性能计算机；智能计算机；互连网络）：<a href="http://www.ict.cas.cn/sourcedb_2018_ict_cas/cn/jssrck/201711/t20171114_4894259.html">王展—中国科学院计算技术研究所 (cas.cn)</a></li><li>肖俊敏老师-高性能计算机研究中心（高性能并行算法设计与优化；智能超算（HPC+AI））：<a href="http://www.ict.cas.cn/sourcedb_2018_ict_cas/cn/jssrck/201810/t20181030_5151421.html">肖俊敏—中国科学院计算技术研究所 (cas.cn)</a></li><li>姚二林老师-高性能计算机研究中心、处理器芯片重点实验室（大数据分析；机器学习；高性能计算）：<a href="http://www.ict.cas.cn/sourcedb_2018_ict_cas/cn/jssrck/201211/t20121120_3686132.html">姚二林—中国科学院计算技术研究所 (cas.cn)</a></li><li>元国军老师-高性能计算机研究中心（计算机系统结构;分布式AI训练网络;高性能网络芯片;光互连网络）：<a href="http://www.ict.cas.cn/sourcedb_2018_ict_cas/cn/jssrck/201708/t20170814_4847025.html">元国军—中国科学院计算技术研究所 (cas.cn)</a></li></ul><h3 id="还有其他的高校？"><a href="#还有其他的高校？" class="headerlink" title="还有其他的高校？"></a>还有其他的高校？</h3><h3 id="商汤"><a href="#商汤" class="headerlink" title="商汤"></a>商汤</h3><p><a href="https://zhuanlan.zhihu.com/p/429466308">商汤HPC又来招人啦~</a></p><h3 id="浪潮"><a href="#浪潮" class="headerlink" title="浪潮"></a>浪潮</h3><h3 id="华为-腾讯-阿里-字节…"><a href="#华为-腾讯-阿里-字节…" class="headerlink" title="华为/腾讯/阿里/字节…"></a>华为/腾讯/阿里/字节…</h3>]]></content>
      
      
      <categories>
          
          <category> HPC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tesla架构</title>
      <link href="/2023/01/24/Tesla%E6%9E%B6%E6%9E%84/"/>
      <url>/2023/01/24/Tesla%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="GPU架构——Tesla架构"><a href="#GPU架构——Tesla架构" class="headerlink" title="GPU架构——Tesla架构"></a>GPU架构——Tesla架构</h1><blockquote><p>笔者学习自：<a href="https://zhuanlan.zhihu.com/p/403345668">GPU 架构探秘之旅</a>中的文章，因此文章内容可能与其相似。</p><p>本文仅用于记录笔者日常学习、总结学习笔记，不作商业用途</p></blockquote><p>这系列文章中，我认为需要学习的是 GPU 结构和并行思想，具体涉及到计算机图形学的部分可以略看。</p><h2 id="初始-GPU-架构"><a href="#初始-GPU-架构" class="headerlink" title="初始 GPU 架构"></a>初始 GPU 架构</h2><blockquote><p>参考博客：<a href="https://zhuanlan.zhihu.com/p/403354366">【GPU】Tesla架构（一）：初识GPU架构 - 知乎 (zhihu.com)</a></p></blockquote><p>1999 年，图形加速器才有和 CPU 平分秋色的 GPU 的名字。当时是 GeForce 256 享此殊荣。可以把坐标变换、灯光照明、三角形设置裁剪和每秒处理一千万个多边形的渲染引擎集成到一个芯片上，在现在看来由 GPU 负责是天经地义的，但在当时，却是相当大的突破。</p><p>对<strong>大量数据执行相同操作（SIMD)</strong>，是并行计算的最爱，也是GPU得以分家立业并不断从CPU挖墙脚的万恶之源。而GeForce 256只是这万里长征梦最开始的地方，但其大量数据具体执行什么操作是内置的（固定管线），这不还是特定算法的加速器而已么，怎配得上处理器三个字？</p><p>所以两年后，GeForce 3拥有了顶点着色器和可配置的片元管线，进入了DirectX8的时代；而第二年也就是2002年，ATI（后被AMD收购，此时应该是ATI YES?）发布了Radeon9700，其支持24位可编程的片元着色器，直接拥抱DirectX9；英伟达在2003年也发布了支持32位可编程片元的GeForce FX，虽然初始型号有点拉跨<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/GeForce_FX_series">2</a>。</p><p>在这个“上古混沌”时期，GPU走在一条<strong>不断提高可编程性</strong>的康庄大道上，而终于在2006年随着基于Tesla架构构建的第八代GeForce推出，迎来了一股小高潮。我们也迎来了本文的主角——Tesla架构。</p><h3 id="破开麻雀的身体"><a href="#破开麻雀的身体" class="headerlink" title="破开麻雀的身体"></a>破开麻雀的身体</h3><p>与现在动辄上万个核的3090相比，Tesla架构寒酸得让人心疼。但麻雀虽小五脏俱全，非常适合刚接触GPU架构的我们学习（直接看最新显卡的架构图，在看清楚前眼睛已经瞎了）。</p><p>而随着我们在之后的文章中一步步沿着显卡的演化路径前进到当下，我们会惊奇地发现，<strong>Tesla架构所奠定的基础设施框架，以及其所蕴含的设计思想历久弥新，从未过时</strong>。</p><p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/v2-3b955d24d33d0159669e2ae5e8d25d32_1440w.webp" alt="img"></p><p>简单划分一下：</p><ul><li>最上面是甲方 CPU；整个 GPU 可以看成一个外包公司，负责各种又脏又累的活</li><li>外包公司内，最上层的是各种大小包工头；中间是负责干活的工人；最下方是对方原料的码头和仓库</li><li>可以发现一个特点：除了负责指挥的包工头，下面干活的工人和数据码头和仓库似乎有好几个，并且长得一模一样，这是<strong>GPU 并行性在具体硬件结构上的体现。</strong></li></ul><h3 id="劳动人民"><a href="#劳动人民" class="headerlink" title="劳动人民"></a>劳动人民</h3><p><strong>Host Interface：</strong>外包公司大包工头，负责收发来自 CPU 的各种订单，并处理 GPU 在各种订单间的上下文切换；负责获取来自内存等待加工的原材料（顶点数据、纹理数据、buffer等）并放到显存中。</p><p><strong>Input Assembler：</strong>将顶点索引和图元类型搭配，并搭配它们的顶点属性，才能传给 Vetex Work Distribution</p><p><strong>Vertex、Pixel、Compute Work Distribution：</strong>三个小包工头，分别分发顶点、片元和计算着色器的任务，给底下的一堆流水线工人去做。</p><p><strong>TPC（Texture Processing Clusters）：</strong>内部有一个纹理单元和两个负责计算的 <strong>SM（Streaming Multiprocessor）</strong>。上面三个小包工头的任务由它们完成，是个啥都能做的“全栈工程师”。</p><p><strong>Viewport/clip/setup/raster/z-cull block：</strong>（笔者没有搞明白这是干啥的，将原文摘录如下）顶点着色器处理完，只是输出一堆裁剪坐标（还未透视除法）和一堆与其一起等待光栅化插值的属性，这个模块就是负责这些，流水线中到目前为止都未开放编程的固定功能部分。</p><p><strong>ROP（Raster Operations Processor）：</strong>码头工人，负责对片元着色器处理后的像素进行测试和装箱：同一个像素位置的<strong>深度/模板测试和写入、颜色混合、抗锯齿</strong>有他完成。</p><p><strong>L2 Cache、Memory Controller 和 DRAM：</strong>每个 DRAM 搭配一个 Memory Controller、L2 Cache 和一个 ROP，共有 6 组这样的搭配，每个搭配对应显存六分之一的物理地址。</p><h2 id="血汗工厂"><a href="#血汗工厂" class="headerlink" title="血汗工厂"></a>血汗工厂</h2><blockquote><p>参考博客：<a href="https://zhuanlan.zhihu.com/p/416334635">【GPU】Tesla架构（二）：血汗工厂 - 知乎 (zhihu.com)</a></p></blockquote><p>上一个部分中我们简单浏览了一下 Tesla 架构的整体框架和主要部件，真正干活的是 TPC（Texture Processing Clusters）及其内部的 SM（Streaming Multiprocessor）。促使它们 007 工作的机制，是 GPU 拥有巨大并行能力的核心秘密。</p><h3 id="走进黑心企业"><a href="#走进黑心企业" class="headerlink" title="走进黑心企业"></a>走进黑心企业</h3><p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/v2-92ec0098ff0107284729aa27e9069d8f_1440w.webp" alt="img"></p><p>我们可以将 TPC 内部看成一个个子公司，黑心企业一共由 8 个。</p><p><strong>Geometry Controller（几何控制器）：</strong>光栅化前几何阶段，负责顶点属性在芯片内输出相关事宜（我觉得可以不用管具体在图形学中的工作内容）。</p><p><strong>SMC（SM Controller）：</strong>Tesla 是统一的图形和并行计算架构，顶点、几何、片元着色器，甚至与图形无关的并行计算任务（CUDA）都由同样的硬件 SM 来运算。SMC 负责将来自总部的各种任务，拆分打包成 <strong>Warp</strong> 交给 SM 处理。同时，SMC 还负责协调 SM 与公用部门 Texture Unit 之间的工作，实现对外纹理资源的获取；现存中其他非纹理资源的读写甚至原子操作通过 ROP 与外界打交道。总之，SMC 由负责对接外界资源，又负责内部任务分配，实现复杂但至关重要的<strong>负载平衡</strong>，是名副其实的子公司高管。</p><p><strong>Texture Unit：</strong>包括 4 个纹理地址生成器和 8 个滤波单元。纹理单元的指令源是纹理坐标，输出是经过插值的纹理值，都是向量。</p><p><strong>SM（Streaming Multiprocessor）：</strong>负责最底层运算的部门</p><ul><li><strong>I Cache（指令 Cache）：</strong>一个 SM 要做的来自 SMC 的工作并非立刻完成，大量指令被缓存到这里分批执行</li><li><strong>C Cache（常量 Cache）和 Shared Memory（共享内存）：</strong>讲通用计算和各种内存类型时再展开</li><li><strong>MT（Multi-threaded） Issue：</strong>SM部门主管，负责将 Warp 任务拆碎成一条条指令分给社畜们执行。对 Warp 的调度是 GPU 并行能力的关键。</li><li><strong>SP（Streaming Processor）：</strong>干活的主力军，执行最基本的<strong>浮点型标量运算</strong>，包括 add、multiply、multiply-add，以及各种整数运算。</li><li><strong>SFU（Special Function Unit）：</strong>负责更为复杂的运算，比如超越函数（指数、对数、三角函数等）、<strong>属性插值</strong>、<strong>透视矫正</strong></li></ul><h3 id="一条绳上的蚂蚱"><a href="#一条绳上的蚂蚱" class="headerlink" title="一条绳上的蚂蚱"></a>一条绳上的蚂蚱</h3><p>干活流程：高级语言——编译成中间指令——被优化器转化为二进制 GPU 指令。</p><ul><li>高级语言包括：着色器代码、CUDA Kernel 程序等</li><li>中间指令如果是 SIMD，则会被转化为多条 Tesla SM 标量指令</li></ul><p><strong>ISA（Instruction Set Architecture）：</strong>那么都会生成哪些指令呢？主要有三类：</p><ol><li><strong>运算</strong>：浮点整数等加法乘法、最小最大、比较、类型转换等基础运算以及超越函数等复杂运算。</li><li><strong>流控制</strong>：分支、调用、返回、中断、同步</li><li><strong>内存访问</strong>：包括对各类内存的读写、原子操作</li></ol><p>这些指令 CPU 也可以做，但是为什么交给 GPU 呢？因为这些指令<strong>不仅需要做一遍</strong>。比如一个顶点着色器，没有一个顶点数据，就要开一个线程把这个指令做一遍。</p><p>SMC 拿到一个着色器所有指令之后，会把这些指令以 <strong>32 个线程为单位</strong>分发给 SM，<strong>负责执行完这个着色器所有指令的 32 个线程，成为一个 Warp</strong>。</p><p>指令存放于指令 Cache 中，MT Issue 每次拿出一个指令分发给手下 SP 或者 SFU 执行。</p><p>一个 SM 中 SP 只有 8 个，但是需要运行 32 个线程（Warp），所以让每个 SP 连续干 4 次。</p><p>一个 MT Issue 发号施令一次，手下的 SP 和 SFU 就将一条指令执行 32 次，这就是 SIMT（Single-instruction, multiple-thread），GPU 基于 SIMT 设计的。</p><h4 id="分支情况"><a href="#分支情况" class="headerlink" title="分支情况"></a>分支情况</h4><p>每个线程其实不一定执行相同的指令，程序并非简简单单的一条条向下走，而是还有分支、循环等改变指令流的情况，由于每个线程输入的数据不同，很可能进入不同的分支。</p><p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/v2-2a1cdb8a217012b1b06ef7c49c0408a5_1440w.webp" alt="img"></p><p><strong>解决方法：</strong></p><ul><li>编译器可以进行特殊情况下的分支预测</li><li>无法预测的情况下，需要付出指令代价进行 <strong>Warp Voting</strong>，投票出 Warp 中所有线程只走一个分支还是串行走多个分支（即使只有一个线程进入了某个分支，其他线程也需要等待它执行完毕，这就是<strong>锁步运行</strong>）</li></ul><h3 id="活儿可以等，打工人不能等"><a href="#活儿可以等，打工人不能等" class="headerlink" title="活儿可以等，打工人不能等"></a>活儿可以等，打工人不能等</h3><p>当前硬件的计算速度比访存速度快几个数量级，<strong>瓶颈往往在访存上</strong>。当 SP 遇到内存访问指令，会由 SMC 向外请求数据（要么通过纹理单元要么通过 ROP）</p><blockquote><p>社畜SP：“没办法呀，我也不是真的想摸鱼，但是没数据我干不了接下来的活呀 :）”<br>主管MT Issue：“是的，这个Warp只能等了，毕竟不同指令间有数据依赖，着色器里的代码总不能跳着执行。”<br>社畜SP：“是呀是呀，这活总得按部就班，才不会忙中出错嘛”<br>子公司高管SMC：“总部摊派给我们的活多着呢，我特意拆分成了好多个Warp让你们执行，就是想避免你们带薪拉屎。一个Warp要拿数据，我去帮你们联系就行，你们赶紧先去做其他Warp！”<br>于是，整个部门007的日常开始了。</p></blockquote><p>这就是<strong>延迟隐藏</strong>的真相。公司特地搞了一个指令 Cache，就是<strong>让 SM 能够存储下足够多的 Warp</strong>（Tesla 架构最多 24 个，这些 Warp 可以是不同类型的，比如顶点着色器、片元着色器甚至是 CUDA 程序），以便在内存阻塞时快速切换到其他可以执行的 Warp 上，等拿到数据之后再切换回原来的 Warp 就行了。毕竟，读写数据不需要 SP 费心。有足够多的 Warp 让 SP 们 007。</p><p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/v2-29d8a02a890d4174d8d30f9241b46d88_1440w.webp" alt="img"></p><p>并行的真相：不是简单的计算单元并行，而是<strong>所有元器件尽可能都不要停下来</strong>。当然 MT Issue 也停不下来，大家都是打工人，谁也不必谁高贵。</p><p>MT Issue 从原来的分发一个 Warp 的一条指令变成了从多个 Warp 中挑选一个 Warp 执行其之前执行到的接下来的指令。将会根据 <strong>Warp 类型、指令类型和公平性原则来量化选择 Warp</strong>。每两个周期，MT Issue 从中挑选一个得分最高的 Warp 分配给对应的元器件执行。</p><p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/v2-07c156f620b46a6287e759dcf00f93cf_1440w.webp" alt="img"></p><p>每个 SP 有 8 个，做完一个 Warp 需要 4 周期，那么 MT Issue 为什么每两个周期就分发一次指令呢？因为还有 SFU！SP 运行时，SFU 不能闲着，2 个周期分发一次指令的频率，可以保证 MT Issue 有充分的时间给 SFU 挑选一个需要运行的 Warp，这样<strong>所有员工都能满负荷运行，只要手中的 Warp 还没执行完，谁都别想停</strong>。</p><p>最后一个小问题：一个 Warp 线程的多少对性能有什么影响？如果粒度太粗，则可供调度的 Warp 就太少，不利于延迟隐藏；如果粒度太小，则每次切换所执行的线程太少，切换 Warp 的相对成本就很高。</p><h2 id="通用计算及其“物流网”"><a href="#通用计算及其“物流网”" class="headerlink" title="通用计算及其“物流网”"></a>通用计算及其“物流网”</h2><blockquote><p>参考博客：<a href="https://zhuanlan.zhihu.com/p/425082340">【GPU】Tesla架构（三）：通用计算及其“物流网” - 知乎 (zhihu.com)</a></p></blockquote><h3 id="从图形到通用计算"><a href="#从图形到通用计算" class="headerlink" title="从图形到通用计算"></a>从图形到通用计算</h3><p>观察可以发现，全称为图形处理单元的 GPU，<strong>其最基本的计算部门——SM，已经和图像处理没有关系了</strong>。将图形相关操作剥离成独立的硬件，从而将计算单元 SM 解耦出来，以开启和拥抱更加广阔的并行计算市场。</p><p>在通用计算管线（原文中和通用计算管线相对应的概念是图形管线）中，所有线程都由程序员分配和调用，<strong>每个线程对应的任务不是固定的顶点或者片元，而可能是任何我们想做的事情</strong>。分配多少线程、每个线程处理什么工作（如何计算、获取什么数据、输出什么）都由程序员说了算。</p><p>另外，我们分配这些线程是<strong>协作式的</strong>，我们可以根据它们的线程 id 分配它们干不同的任务，它们之间还需要数据传递。</p><p>我们可以<strong>根据具体任务，分配线程，并设计它们的协作模式和数据依赖关系</strong>。</p><h3 id="CUDA-和计算着色器"><a href="#CUDA-和计算着色器" class="headerlink" title="CUDA 和计算着色器"></a>CUDA 和计算着色器</h3><p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/v2-d9689b21d2fcac3045886bdfcee3f565_1440w.webp" alt="img"></p><p>CUDA 线程的三级结构：<strong>Grid-Block-Thread</strong>，每个 Block 包含多少个线程在和函数中写死，<strong>Block 是协作发生的组织单位（也被成为 CTA，cooperative thread array），</strong>里面的线程可以<strong>通过共享内存传递数据。</strong>每个 Grid 包含多少个 Block，由应用程序在每次调用时指定，同一个 Grid 的所有 Block 之间是完全独立的，没有数据依赖。</p><p>线程相关信息的计算方法：</p><p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/v2-36f03e7fa80a9530c71ad87faca8034a_1440w.webp" alt="img"></p><h3 id="真正的并行单元是-Warp"><a href="#真正的并行单元是-Warp" class="headerlink" title="真正的并行单元是 Warp"></a>真正的并行单元是 Warp</h3><p>无论上层的概念如何复杂，<strong>底层的硬件执行单元都是 SM，真正的并行单位始终是 Warp。</strong>因此优化以 Warp 为基础。</p><ul><li><strong>最好为每个 Block 分配 Warp 线程数（32）的倍数的线程数。</strong>因为不管多少线程都要拆分成Warp单位去执行，33个线程与64个线程同样需要执行两个Warp。</li><li><strong>同一个分支尽量挤到同一个 Warp 中</strong>。如果可以让 Warp 1 仅执行分支 A，让 Warp 2 仅执行分支 B，则可以并行执行。否则将会串行执行。</li><li><strong>如果内存读写仅有一个 Warp 执行，则不需要同步。</strong>因为一个 Warp 内部的线程本身是锁步运行的，不需要同步。但是如果不同的 Warp 之间存在数据依赖，就不得不同步。</li></ul><h3 id="分级“物流”系统"><a href="#分级“物流”系统" class="headerlink" title="分级“物流”系统"></a>分级“物流”系统</h3><p>目前我们对于 GPU 架构的理解还差最后一块拼图：<strong>内存——支撑 GPU 这整座血汗工厂的高速运转的物流系统。</strong></p><p>GPU 中分级物流系统，是非常自然的设计：</p><p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/v2-b3501fecde229b3f4223f609d67bda03_1440w.webp" alt="img"></p><h4 id="Global-Memory-和-L2-Cache"><a href="#Global-Memory-和-L2-Cache" class="headerlink" title="Global Memory 和 L2 Cache"></a>Global Memory 和 L2 Cache</h4><p>Global Memory 就是 DRAM，位于 GPU 上的显存，每一块显存都与一个 L2  Cache 相连。L2 Cache 是在 SM 之外的，因此可以供所有 SM 共同使用。</p><p>不同 Grid 的执行是串行的，如果它们存在对同一块显存数据的数据依赖则由硬件负责同步。一个 Warp 中连续线程访问连续的内存，则可以被合并为一条内存读取指令。</p><h4 id="Shared-Memory-与-L1-Cache"><a href="#Shared-Memory-与-L1-Cache" class="headerlink" title="Shared Memory 与 L1 Cache"></a>Shared Memory 与 L1 Cache</h4><p>共享内存和 L1 Cache 位于 SM 中，Tesla 架构的 L1 Cache 只用于缓存纹理数据，之后的架构中和共享内存占据相同的硬件单元，可以由用户配置两者的大小。</p><p>由于位于 SM 中，共享内存的读写速度远高于主存和 L2 Cache。</p><p>共享内存对一个 Block 中所有线程是可见的，<strong>一个 Block 中的所有线程必定位于同一个 SM 中</strong>。而同一个 Grid 的不同 Block 不一定，因此不同的 Block 之间无法通信（如果想实现通信，可以使用通信组）。这也是为啥一个 Block 中的线程数是有限的，因为一个 SM 可以容纳的 Warp 是有限的。</p><p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/v2-448e786124b33e683ba2c24ce27267b1_1440w.webp" alt="img"></p><p>一个 Warp 32 线程可能需要同时对内存进行读写，需要考虑 <strong>Bank 冲突</strong>的问题。</p><p>共享内存的带宽有限，同时支持 32 个 bank 的读写，但是每个 Bank 只能读写 32 位的数据。多个地址会被映射到同一个 Bank（如上图）。如果由多个线程想读取同一个 Bank 的数据，则会变成<strong>串行执行</strong>。</p><h4 id="Local-Memory-和-Register-Files"><a href="#Local-Memory-和-Register-Files" class="headerlink" title="Local Memory 和 Register Files"></a>Local Memory 和 Register Files</h4><p>每个线程都有自己所需的局部变量，存放在寄存器中。</p><p>最初的局部变量其他线程是无法访问的，但是较新的硬件支持 <strong>Shuffle 操作</strong>，可以在一个 Warp 的线程之间直接传递数据，比共享内存更快。</p>]]></content>
      
      
      <categories>
          
          <category> GPU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GPU </tag>
            
            <tag> CUDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win8.1 + Manjaro 双系统配置踩坑（一）</title>
      <link href="/2023/01/10/2023-1-10-Win8-Manjaro%E5%8F%8C%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE1/"/>
      <url>/2023/01/10/2023-1-10-Win8-Manjaro%E5%8F%8C%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE1/</url>
      
        <content type="html"><![CDATA[<h1 id="Win8-1-Manjaro-双系统配置踩坑"><a href="#Win8-1-Manjaro-双系统配置踩坑" class="headerlink" title="Win8.1 + Manjaro 双系统配置踩坑"></a>Win8.1 + Manjaro 双系统配置踩坑</h1><h2 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h2><p>电脑：</p><p>系统：</p><p>硬盘：1TB 固态硬盘</p><p>显卡：核显</p><h2 id="第一部分-系统安装"><a href="#第一部分-系统安装" class="headerlink" title="第一部分 系统安装"></a>第一部分 系统安装</h2><blockquote><p>参考博客：<a href="https://zhuanlan.zhihu.com/p/376787855">https://zhuanlan.zhihu.com/p/376787855</a></p></blockquote><h3 id="制作-U-盘启动盘"><a href="#制作-U-盘启动盘" class="headerlink" title="制作 U 盘启动盘"></a>制作 U 盘启动盘</h3><ul><li>需要一块 U盘，我选择的是一个 64GB 的 U 盘（博客说 8G 即可），U盘数据提前备份</li><li>Redus 用来烧录系统镜像到 U 盘中</li></ul><p><strong>下载系统镜像：</strong><a href="https://manjaro.org/download/">官方网址</a></p><ul><li>常用的系统镜像是上面的官方网址中 OFFICIAL IMAGES 中的 <code>PLASMA DESKTOP</code>，<code>XFCE DESKTOP</code> 和 <code>GNOME DESKTOP</code>（这三个系统镜像经常出现在各个博客的介绍中，他们之间的具体区别我不是特别了解，<strong>注意：其他博客中常说的 KDE 就是这里的 PLASMA DESKTOP</strong>）</li><li>我选择的是 <code>PLASMA DESKTOP</code></li></ul><p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/image-20230109231045076.png" alt="image-20230109231045076"></p><ul><li>当点击 Download 之后，出现上图右边所示的界面，其中 image 选项下载的是 iso 文件，选择这个下载即可<strong>（虽然不太清楚什么是 iso 文件，也不太清楚其他选项下载的是什么）</strong></li></ul><p><strong>将系统镜像刻录到 U 盘中：</strong>使用软件 Redus，下载的<a href="https://rufus.ie/zh/">官网网址</a></p><ul><li><strong>这里由于我自己没有截图，所以使用他人的图片，这里只要按照步骤来做，应该没有问题</strong></li></ul><p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/image-20230109231805623.png" alt="image-20230109231805623"></p><ul><li>插入 U 盘之后，首先选择设备（如上图左半部分）。</li><li>点击“选择”，并选择下载好的系统镜像（iso文件）（如上图的右半部分）</li><li>点击“开始”，再次确认 U 盘中的数据已经备份</li></ul><p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/image-20230109231958694.png" alt="image-20230109231958694"></p><ul><li>确定好后，点击“确定”，即开始烧录</li></ul><p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/image-20230109232058440.png" alt="image-20230109232058440"></p><ul><li>开始烧录（上图左半部分）。烧录完成（上图右半部分）</li></ul><h3 id="准备-Manjaro-的空间"><a href="#准备-Manjaro-的空间" class="headerlink" title="准备 Manjaro 的空间"></a>准备 Manjaro 的空间</h3><p>这部分操作的主要目的是给 Manjaro 系统分配足够的空间。Windows 和 Linux 系统使用的空间是相互独立的。在你现在的电脑上，所有的磁盘空间都是 Windows 管理的，但是现在由于要安装双系统，你需要从 Windows 控制的磁盘空间中划分出一部分给 Linux 系统。</p><p>强哥做出了如下比喻：</p><blockquote><p>你可以将 Windows 看成住自己房子的房东，它租了一片房子给 Manjaro，Manjaro 拥有这一片房子的改建权。Manjaro 要做的分区就是对这片房子的改建。</p></blockquote><p>为了给 Manjaro 留出空间，需要提前在 Windows 中分配出房子（磁盘空间）。</p><p><strong>磁盘管理分配空间前置说明：</strong></p><blockquote><p>依然参考知乎博客，但是有部分做出了改动：在这篇知乎文章中，作者分配出三块空间，分别挂载 Manjaro 的启动引导分区、根分区和 home 分区（即在 Manjaro 的安装过程中手动进行磁盘管理）。根据强哥的说法，Manjaro 在磁盘空间管理这里做得不错，所以可以不进行手动分区，只需要将分配出来的空闲磁盘交给 Manjaro 自动管理即可，我采用的方法是交给 Manjaro 自动管理</p></blockquote><p>对当前磁盘划分空间只需要熟悉基本操作即可。（<strong>尽量将分出来的空间合并为一个大一点的空间，不清楚 Manjaro 能不能将多个碎片空间合并成一个</strong>）</p><p><strong>从已有标号的盘划分出空间：</strong></p><p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/image-20230109233558890.png" alt="image-20230109233558890"></p><p>如图中所示，假如想将整个原来的 C 卷清空，并做随后的处理，则右键该卷，并选择“删除卷”（如下图左半部分），则这块空间将变成如下状态（下图右半部分，“状态良好 恢复分区”，忽略空间的不同，我没有真的删除卷）：</p><p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/image-20230109234136914.png" alt="image-20230109234136914"></p><p><strong>将两个相邻的卷合并成一个更大的卷</strong></p><p>例如如下初始状态的磁盘卷</p><p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/image-20230109234037733.png" alt="image-20230109234037733"></p><ul><li>只需要选择其中一个卷，右键选择“删除卷”，则最终两个分区将会合并成一个分区。</li></ul><p><strong>从已有的卷中，取出一部分空间</strong></p><blockquote><p>操作参考：<a href="https://zhuanlan.zhihu.com/p/376787855">2021【保姆级教程】Win+Manjaro双系统双硬盘安装-知乎</a></p><p>部分图片来自：<a href="https://iknow.lenovo.com.cn/robot/knowledge/id/133316">Windows 10 如何进行压缩卷</a>和上述知乎文章</p></blockquote><ul><li>例如：D 盘目前剩余 750GB，想从中分出 200GB</li><li>则在 “新加卷(D:)”中点击右键，选择“压缩卷”，此时磁盘将会计算可用来压缩的磁盘空间（如下图）</li></ul><p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/image-20230109235546390.png" alt="image-20230109235546390"></p><ul><li>默认值为最大，可以修改为自己想要压缩的空间，单位为 MB（如下图左边）；如果要压缩 10GB 空间，则输入 10240 MB（如下图右边），如果要压缩 200GB，则输入 204800MB 即可（1GB = 1024MB）</li></ul><p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/image-20230109235801495.png" alt="image-20230109235801495"></p><ul><li>压缩之后将会产生一个同样大小的未分配空间（图来自知乎文章）</li></ul><p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/v2-939a51b3460ace68ac552facc7cd9246_1440w.webp" alt="img"></p><ul><li>右键点击未分配的空间，选择“新建卷”。随后，“简单卷大小”选择最大的大小（如图1）（这里的大小和最开始分配的空间可能不一样大，例如如果“压缩卷”时选择了10240MB，则这里可能只有 10239MB，问题不大）；选择不分配驱动器号或驱动器路径（如图2）；随后，选择不要格式化这个卷（如图3）；最后点击完成即可</li></ul><p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/image-20230110000332971.png" alt="image-20230110000332971"></p><p><strong>一些问题：</strong></p><ul><li><p>Q：手动分区有什么问题？</p><ul><li>A：咨询了一下强哥，好像说也可以，但是从省心的角度来说还是自动分区比较好。B站上有一个讲解的比较清晰的<a href="https://www.bilibili.com/video/BV1xb411b7qa/?spm_id_from=333.337.search-card.all.click&amp;vd_source=004adbd5ffedd22db638131ba0059a6d">手动分区教程</a></li></ul></li><li><p>Q：磁盘大小分出来多少合适？</p><ul><li>A：强哥分出了 1TB（将整个一个磁盘分给 Manjaro），目前他已经使用了 400GB 左右；我总共只有 1T 的磁盘，根据我目前使用的情况，大概分出了 400GB 给 Manjaro；知乎文章中分给根目录 70GB，home 分区 80 GB，总共 150G 左右；最低要求似乎是 20 GB 给系统，根据官网的文档。以上情况供读者参考。</li></ul></li><li><p>Q：为什么压缩卷时选择“不分配驱动器号或驱动器路径”、“不要格式化这个卷”？</p><ul><li>A：Chenrt：“关于格式化那个问题，格式化了就是windows那几个文件系统了a，ntfs或者fat32啥的，manjaro用的不是这些，当然你格式化了也不是不行，manjaro装的时候把这个分区删了就行了”</li></ul></li><li>Q：分出来的空间总体很多，但是又很多碎片，最终不知道如何合并成一块大的空间怎么办？<ul><li>A：Chenrt：“然后关于碎片那个，感觉不好办？只能把windows干掉重新装吧，装windows的时候c盘不给那么多，提前算好要留出多少空间，这样恢复分区就不会跑到后面，就可以留出整块空间给manjaro了，或者也可以先手动分区装manjaro然后装windows”</li></ul></li></ul><h3 id="关闭-Secure-Boot"><a href="#关闭-Secure-Boot" class="headerlink" title="关闭 Secure Boot"></a>关闭 Secure Boot</h3><blockquote><p>操作参考：<a href="https://developer.aliyun.com/article/70688#:~:text=%E7%AE%80%E4%BB%8B%EF%BC%9A%20%E8%A7%A3%E5%86%B3%EF%BC%9Aefi%20usb%20device%20has%20been%20blocked%20by,the%20current%20security%20policy%20%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0%EF%BC%9AU%E7%9B%98%E8%A3%85%E7%B3%BB%E7%BB%9F%E6%88%96%E8%80%85%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C%E6%97%B6%EF%BC%8C%E6%98%AF%E5%9B%A0%E4%B8%BABIOS%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5%EF%BC%8C%E5%87%BA%E7%8E%B0%E4%B8%8A%E8%BF%B0%E9%94%99%E8%AF%AF%E6%97%A0%E6%B3%95%E8%BF%9B%E5%85%A5%E5%90%8E%E7%BB%AD%E6%AD%A5%E9%AA%A4%E3%80%82%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%9A%E6%8C%89F2%EF%BC%88Fn%2BF2%EF%BC%89%E8%BF%9B%E5%85%A5BIOS%EF%BC%8C%E5%9C%A8secure%20Boot%20%E4%B8%ADsecurity%E9%80%89%E6%8B%A9disable%E3%80%82">解决：efi usb device has been blocked by the current security policy-阿里云</a>；<a href="https://zhuanlan.zhihu.com/p/376787855">2021【保姆级教程】Win+Manjaro双系统双硬盘安装-知乎</a></p></blockquote><p><strong>操作目的：</strong>Windows 设置了一个 Secure Boot 的限制，在开启安全启动的情况下，不能使用其他设备作为启动盘（如 U 盘，否则即便在启动时选择 U盘启动也会遇到 <code>efi usb device has been blocked by the current security policy</code> 的问题。</p><p><strong>说明：</strong>这里主要按照知乎文章进行操作即可，我的系统是 Win8，Win10 也可以使用这种方法。</p><p><strong>知乎文章方法摘录如下：</strong></p><ul><li>重启电脑，狂按 <code>F2</code> 进入 BIOS</li><li>进入 <code>Security</code> 选项，将 <code>Secure Boot</code> 改为 <code>Disabled</code>。</li><li>（改到这里就完了，知乎文章中进一步保证电脑可以通过 U 盘启动）进入 <code>Boot</code> 选项，确定 <code>Boot Mood</code> 为 <code>UEFI</code>，并且 <code>USB Boot</code> 为 <code>Enabled</code></li><li>按 <code>F10</code> 保存退出（系统将继续正常启动，不用担心）</li></ul><p><strong>Windows 8.1 还有另一种进入 BIOS 的方式：</strong></p><blockquote><p>参考博客：<a href="https://jingyan.baidu.com/article/2a13832881579e074b134f49.html">Windows 8系统怎么设置 U 盘启动-百度经验</a></p></blockquote><ul><li>进入“电脑设置”，找到“更新和恢复”（如下图所示）</li></ul><p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/image-20230110082750507.png" alt="image-20230110082750507"></p><ul><li>在“更新和恢复”中找到“恢复”，其中有“高级启动”，点击“立即重启”（如下图所示）</li></ul><p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/image-20230110084009483.png" alt="image-20230110084009483"></p><ul><li>选择“疑难解答”-进去之后选择“高级选项”（如下图，此处无法截屏，只能采用照片形式，请见谅）</li></ul><p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/image-20230110084406991.png" alt="image-20230110084406991"></p><p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/image-20230110084432853.png" alt="image-20230110084432853"></p><ul><li>在”高级选项“选择”UEFI固件设置“</li></ul><p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/image-20230110084500967.png" alt="image-20230110084500967"></p><p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/image-20230110084518938.png" alt="image-20230110084518938"></p><ul><li>可以直接进入”BIOS“</li></ul><p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/image-20230110084623104.png" alt="image-20230110084623104"></p><ul><li>BIOS 中通过键盘中的上下左右四个方向键控制，使用 Enter 键控制确定/取消。使用 F10 保存设置</li></ul><p><strong>注意事项：</strong>涉及到 BIOS 的一些设置，之前应该没有咋操作过。所以可能会有些畏手畏脚，别担心，敢想敢做，别担心干坏了</p><h3 id="U-盘启动"><a href="#U-盘启动" class="headerlink" title="U 盘启动"></a>U 盘启动</h3><blockquote><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/376787855">2021【保姆级教程】Win+Manjaro双系统双硬盘安装-知乎</a></p><p>由于操作过程比较简单，只要按照教程一步步来即可，所以部分图片来自知乎文章</p></blockquote><p><strong>操作目的：</strong>这步操作将从 U 盘中安装 Manjaro 的系统，全程需要保证 U 盘插入并且接触良好。注意，如果上一步没有设置将 Windows 的安全启动关闭的话，这一步是不能操作成功的。</p><ul><li>关机</li><li>插入之前制作好的 U 盘启动盘</li><li>启动电脑并狂按 ”F12“，选择 U 盘启动（如下图，下图的括号中将会<strong>显示你的 U 盘名称</strong>，这里的 U 盘名称是 SanDisk，可以通过这个确认 U 盘是否正确识别）</li></ul><p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/image-20230110085907794.png" alt="image-20230110085907794"></p><ul><li>等待进入系统（如下图）</li></ul><p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/image-20230110090027581.png" alt="image-20230110090027581"></p><p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/v2-912875052391adf756ea60828b29c86a_r.jpg" alt="img"></p><ul><li>点击“Launch Installer”（如下图，建议连上网，我连上了，不清楚不连接有什么问题）</li></ul><p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/v2-0373ea22af44b4d4e3a667e6cf043015_r.jpg" alt="img"></p><ul><li>进入“分区部分“，可以选择“并存安装”、“取代一个分区”、“抹除磁盘”和“手动分区”（如上图）<ul><li><strong>“并存安装”</strong>——应该可以选择一个卷（Windows成为卷，在 Manjaro 中称为分区），并可以手动将卷的空间压缩一些给 Manjaro</li><li><strong>“取代一个分区”</strong>——应该可以选择一个整体的分区，并将这个分区的内容清除，作为 Manjaro 的磁盘空间（由于我预先分出了一个整块的空间，总共 400GB 给 Manjaro，所以我选择的是这个）</li><li><strong>“抹除磁盘”</strong>——这样做会把你选择的一整个磁盘上的所有分区都清空，将整个磁盘作为 Manjaro 的磁盘空间（由于强哥将一个 1TB 的磁盘作为 Manjaro 的磁盘空间，所以他选择的是这个操作）</li><li><strong>“手动分区”</strong>——这个是知乎文章中采用的方法，本人在操作的时候选择了“取代一个分区”（这里可以推荐参考一下<a href="https://www.bilibili.com/video/BV1xb411b7qa/?spm_id_from=333.337.search-card.all.click&amp;vd_source=004adbd5ffedd22db638131ba0059a6d">【新手向】manjaro安装教程——推荐给从未使用过linux的小伙伴-B站视频</a>，这个视频中详细讲述了手动分区，但是本人没有尝试，仅供参考）</li></ul></li><li>“抹除磁盘”操作示意（可以看到抹除磁盘“之后”，整个磁盘的空间都变成 Manjaro 的了，由于我还有 Windows 环境，所以没有选择这个）</li></ul><p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/image-20230110091556805.png" alt="image-20230110091556805"></p><ul><li>“取代一个分区示意”（在这里点击选择提前为 Manjaro 准备好的空间，可以参考“之后”，选择的 sda7 变成了 Manjaro 的磁盘空间，大小是这块分区的大小）</li></ul><p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/image-20230110091701910.png" alt="image-20230110091701910"></p><ul><li>之后在“用户”界面，将会让你输入用户名，密码等信息</li><li>“摘要界面”，将通过文字简要介绍一下 Manjaro Linux 安装程序将要干的事情，包括分区操作信息，这里可以再次核对分区是否正确</li><li>之后点击“安装”即可安装，安装结束后（如下图，选择“现在重启”，此时电脑将会重启，这时候就可以拔出 U 盘了，稍等片刻，就会出现系统引导界面，指示选择 Linux 系统还是 Windows 系统。图片来自知乎文章）</li></ul><p><img src="https://raw.githubusercontent.com/Zhang-kg/cloud_img/master/v2-4ec7197415f2b1bc4405c5a35d8eaca2_r.jpg" alt="img"></p><ul><li>最终安装完成，可以开始基本的使用了</li></ul><p><strong>疑问：</strong></p><p>Q：进入安装后，不联网会怎么样？</p><ul><li>A：Chenrt：“以及安装不联网可能会比较快？因为不会有pacman syyu的时间，但装完得自己syyu一下，联网的话安装的时候就帮你syyu了吧”</li></ul><p>Q：之前分配出来的空间不是连续的，怎么办？</p><ul><li>A：你可以在“取代一个分区”处尝试能否选择多个分区，如果不能，或许只能手动操作了</li></ul><p><strong>接下来的文章，将会介绍 Manjaro 中文输入法的安装、Chrome 的安装、微信的安装，这些软件的安装着实让我抓狂</strong></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Manjaro </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2023/01/07/2023-1-7-%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2023/01/07/2023-1-7-%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第一篇文章"><a href="#这是我的第一篇文章" class="headerlink" title="这是我的第一篇文章"></a>这是我的第一篇文章</h2><p>adfadfa</p><p>张凯歌</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第三篇文章</title>
      <link href="/2023/01/07/2023-1-7-%E7%AC%AC%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2023/01/07/2023-1-7-%E7%AC%AC%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第二篇文章</title>
      <link href="/2023/01/07/2023-1-7-%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2023/01/07/2023-1-7-%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
